
# FileName: __init__.py
#
# version: 1.0
#
# Summary: Marks this directory as a Python package for curses-based front-end.
#
# Tags: package, curses

"""
Package for all curses-based front-end modules:
 - curses_input
 - curses_renderer
 - curses_menus
 - curses_map_ui
 - curses_common (shared drawing helpers)
 - curses_animations
 - curses_highlight
 - curses_art_skins
 - curses_utils
 - curses_color_init
"""


# FileName: curses_animations.py
#
# version: 2.0
#
# Summary: Houses drawing routines for sprite/scene animations (ASCII art, borders),
#          plus the subtle ASCII art shifting from the old animator_main.py.
#
# Tags: animation, drawing, curses

import time
import curses
import debug
from .curses_utils import safe_addstr, safe_addch, get_color_attr
from .curses_common import draw_screen_frame
from .curses_art_skins import DECORATION

def animate_art_subtle(stdscr, art_lines, title_text=None, max_shift=2, frame_delay_ms=50, shift_delay_frames=20):
    """
    Slowly shifts ASCII art left/right by ±max_shift columns, pausing shift_delay_frames frames
    between each shift. Press 'q'/'Q' or ESC to exit. Press 'v' to toggle debug.
    
    :param stdscr: The curses screen
    :param art_lines: list of strings for the ASCII art
    :param title_text: optional string displayed at row=1, col=2
    :param max_shift: maximum shift in columns (default 2)
    :param frame_delay_ms: time to sleep each frame, in milliseconds (default 50)
    :param shift_delay_frames: how many frames to wait before reversing shift direction
    """
    stdscr.nodelay(True)
    curses.curs_set(0)

    offset_x = -2
    direction = -1
    frame_count = 0

    while True:
        stdscr.erase()
        draw_screen_frame(stdscr)

        # If given, display some title text
        if title_text:
            try:
                safe_addstr(stdscr, 1, 2, title_text, get_color_attr("WHITE_TEXT"), clip_borders=False)
            except curses.error:
                pass

        # Render art offset by offset_x
        _draw_art(stdscr, art_lines, start_row=3, start_col=2 + offset_x)

        stdscr.noutrefresh()
        curses.doupdate()

        key = stdscr.getch()
        if key in (ord('q'), ord('Q'), 27):
            break
        elif key == ord('v'):
            debug.toggle_debug()

        frame_count += 1
        if frame_count % shift_delay_frames == 0:
            offset_x += direction
            if offset_x >= max_shift:
                offset_x = max_shift
                direction = -1
            elif offset_x <= -max_shift:
                offset_x = -max_shift
                direction = 1

        # Use time.sleep for frame delay (instead of curses.napms).
        time.sleep(frame_delay_ms / 1000.0)


def _draw_art(stdscr, art_lines, start_row=1, start_col=2, color_name="ASCII_ART"):
    """
    Renders 'art_lines' at (start_row, start_col), using a specified color_name.
    """
    attr = get_color_attr(color_name)
    max_h, max_w = stdscr.getmaxyx()
    row = start_row
    for line in art_lines:
        if row >= max_h - 1:
            break
        safe_addstr(stdscr, row, start_col, line, attr, clip_borders=True)
        row += 1


#def draw_border_old(stdscr, color_name="UI_CYAN"):
#    """
#    DEPRECATED: We keep this for reference, but prefer using 'draw_screen_frame' from curses_common.
#    """
#    draw_screen_frame(stdscr, color_name)


# FileName: curses_art_skins.py
#
# version: 1.2
#
# Summary: Stores ASCII art or special graphics needed for titles, load screens, or decorative UI elements.
#
# Tags: art, ui

HEADER_ART = [
    "=== HEADER ART PLACEHOLDER ===",
    "You can replace this with your own artwork."
]

LOADING_ART = [
    "--- LOADING ART PLACEHOLDER ---",
    "You can replace this with your own artwork."
]

HOMESCREEN_ART = [
    "::: HOMESCREEN ART PLACEHOLDER :::",
    "You can replace this with your own artwork."
]

DECORATION = [
    "... DECORATION PLACEHOLDER ...",
    "You can replace this with your own artwork."
]

BANNER = [
    "~~~ BANNER PLACEHOLDER ~~~"
]

BORDERS = [
    "+++ BORDERS PLACEHOLDER +++"
]

MAIN_MENU_ART = [
    "     .       +  ':.  .      *              '            *  '",
    "                  '::._                                      ",
    "                    '._)                 * +              ' ",
    "                          .              .        |         ",
    "           .      o.               +            - o -.      ",
    " o'          '    .    /  .         o             |         ",
    "    .  *   '          /                         +           ",
    "   .                 *          '                      .    ",
    "                 .             .             .  .           ",
    "   *         .   .       .                   | '.           ",
    "  +          '+                .           - o -            ",
    "          .                                . |              ",
    "            '  '     ..                   +  .  . +.        ",
    "  .                              |          .-.             ",
    " '                 .'  * '     - o -         ) )            ",
    " +        '   .                   |          '-´         '  ",
    "                       +      .'                   '.       ",
    " .           .           o      .       . .      .          ",
    "                       '       . +~~                       .",
]

CROCODILE = [
    "                _ ___                /^^\\ /^\\  /^^\\*",
    "    _          *@)@) \\            ,,/ '`~`'~~ ', `\\.",
    "  _/o\\_ _ _ _/~`.`...'~\\        ./~~..,'`','',.,' '  ~:",
    " / `','.~,~.~  .   , . , ~|,   ,/ .,' , ,. .. ,,.   `,  ~\\*",
    "( ' *' _ '*`_  '  .    ,`\\*/ .' ..' '  `  `   `..  `,   \\*",
    "  V~ V~ V~ ~\\ `   ' .  '    , ' .,.,''`.,.''`.,.``. ',   \\_",
    "  _/\\ /\\ /\\ /\\_/, . ' ,   `*/\\_ `. `. '.,  \\*",
    "< ~ ~ '~`'~'`, .,  .   `_: ::: \\_ '      `*/ ::: \\_ `.,' . ',  \\_",
    "  \\ ' `_  '`_    _    ',/ _::_::_ \\ _    _/ _::_::_ \\   `.,'.,`., \\-,-,-,_,_,",
    "   `'~~ `'~~ `'~~ `'~~  \\_)(_)(_)/  `~~' \\_)(*)(*)/ ~'`\\*..*,.*,'*;*;*;*;*;"
]

DEFAULT_SKIN = {
    "main_menu_art": MAIN_MENU_ART,
    "border_color":  "UI_CYAN",
    "title_color":   "UI_WHITE_ON_BLUE",
}

CURRENT_SKIN = DEFAULT_SKIN


# FileName: curses_color_init.py
#
# version: 3.3
#
# Summary: Initializes curses color pairs. Skips invalid indexes if terminal supports fewer colors.
#
# Tags: colors, curses, setup

import curses

# The standard 8 curses colors mapped to friendly names:
BASE_COLORS = {
    "black":   curses.COLOR_BLACK,
    "red":     curses.COLOR_RED,
    "green":   curses.COLOR_GREEN,
    "yellow":  curses.COLOR_YELLOW,
    "blue":    curses.COLOR_BLUE,
    "magenta": curses.COLOR_MAGENTA,
    "cyan":    curses.COLOR_CYAN,
    "white":   curses.COLOR_WHITE,
}

# Extended color indexes for e.g. light_gray, dark_gray, etc.
EXTENDED_COLORS = {
    "light_gray": 8,
    "dark_gray":  9,
    # Could add more if terminal supports it.
}

def define_extended_colors():
    """Attempt to initialize extra colors if the terminal supports color redefinition."""
    if not curses.can_change_color():
        return
    # light_gray => ~70% white
    curses.init_color(8, 700, 700, 700)
    # dark_gray  => ~30% white
    curses.init_color(9, 300, 300, 300)

color_pairs = {}

def init_colors():
    curses.start_color()
    curses.use_default_colors()

    # Attempt to define extended colors if supported
    define_extended_colors()

    # Merge base + extended
    all_colors = dict(BASE_COLORS)
    all_colors.update(EXTENDED_COLORS)

    pair_index = 1
    for fg_name, fg_val in all_colors.items():
        for bg_name, bg_val in all_colors.items():
            if fg_val < curses.COLORS and bg_val < curses.COLORS:
                pair_name = f"{fg_name}_on_{bg_name}"
                curses.init_pair(pair_index, fg_val, bg_val)
                color_pairs[pair_name] = pair_index
                pair_index += 1

    # Create alias names for legacy references
    ALIAS_MAP = {
        "WHITE_TEXT":        "white_on_black",
        "UI_CYAN":           "cyan_on_black",
        "UI_MAGENTA":        "magenta_on_black",
        "UI_WHITE_ON_BLUE":  "white_on_blue",
        "YELLOW_TEXT":       "yellow_on_black",
        "ASCII_ART":         "white_on_black",
        "TREE_TOP":          "green_on_black",
        "ROCK":              "white_on_black",
        "RIVER":             "white_on_blue",
        "GRASS":             "white_on_green",
        "PATH":              "black_on_yellow",
    }

    for alias_name, real_name in ALIAS_MAP.items():
        if real_name in color_pairs:
            color_pairs[alias_name] = color_pairs[real_name]
        else:
            color_pairs[alias_name] = color_pairs.get("white_on_black", 0)


# FileName: curses_common.py
#
# version: 2.9
#
# Summary: Provides functions and helpers for drawing frames, labels, etc. in curses.
#
# Tags: ui, rendering, curses

import curses
import debug
from .curses_color_init import color_pairs
from .curses_utils import safe_addstr, safe_addch, get_color_attr

INSTRUCTION_COLOR_NAME = "UI_MAGENTA"
BORDER_COLOR_NAME      = "UI_CYAN"
TITLE_COLOR_NAME       = "UI_WHITE_ON_BLUE"
TEXT_COLOR_NAME        = "YELLOW_TEXT"
ART_COLOR_NAME         = "ASCII_ART"

UI_FONT_CONFIG = {
    "font_color_name": TEXT_COLOR_NAME,
    "font_size": None,
    "font_type": None,
}

def set_ui_font_config(**kwargs):
    for key, val in kwargs.items():
        if key in UI_FONT_CONFIG:
            UI_FONT_CONFIG[key] = val

def draw_title(stdscr: curses.window, text: str, row: int = 1, color_name: str = TITLE_COLOR_NAME) -> None:
    max_h, max_w = stdscr.getmaxyx()
    if row < 0 or row >= max_h:
        return
    col = 2
    attr = get_color_attr(color_name, bold=True)
    safe_addstr(stdscr, row, col, text, attr, clip_borders=True)

def draw_instructions(stdscr: curses.window, lines: list[str], from_bottom: int = 2, color_name: str = INSTRUCTION_COLOR_NAME) -> None:
    """
    Draws a list of instruction lines near the bottom of the screen.
    """
    h, w = stdscr.getmaxyx()
    attr = get_color_attr(color_name)

    start_row = h - from_bottom - len(lines)
    if start_row < 1:
        start_row = 1

    row = start_row
    for line in lines:
        if row >= h - 1:
            break
        safe_addstr(stdscr, row, 2, line, attr, clip_borders=True)
        row += 1

def draw_screen_frame(stdscr: curses.window, color_name: str = BORDER_COLOR_NAME) -> None:
    """
    Draws a rectangular border around the entire screen, plus a "Debug mode" label if debug is enabled.
    """
    h, w = stdscr.getmaxyx()
    border_attr = get_color_attr(color_name)

    # Top line
    for x in range(w):
        safe_addch(stdscr, 0, x, curses.ACS_HLINE, border_attr, clip_borders=False)
    safe_addch(stdscr, 0, 0, curses.ACS_ULCORNER, border_attr, clip_borders=False)
    safe_addch(stdscr, 0, w - 1, curses.ACS_URCORNER, border_attr, clip_borders=False)

    # Bottom line
    for x in range(w):
        safe_addch(stdscr, h - 1, x, curses.ACS_HLINE, border_attr, clip_borders=False)
    safe_addch(stdscr, h - 1, 0, curses.ACS_LLCORNER, border_attr, clip_borders=False)
    safe_addch(stdscr, h - 1, w - 1, curses.ACS_LRCORNER, border_attr, clip_borders=False)

    # Left/right
    for y in range(1, h - 1):
        safe_addch(stdscr, y, 0, curses.ACS_VLINE, border_attr, clip_borders=False)
        safe_addch(stdscr, y, w - 1, curses.ACS_VLINE, border_attr, clip_borders=False)

    # Debug label
    if debug.DEBUG_CONFIG["enabled"]:
        label = "Debug mode: On"
        col = w - len(label) - 2
        dbg_attr = get_color_attr("WHITE_TEXT")
        safe_addstr(stdscr, 0, col, label, dbg_attr, clip_borders=False)

def draw_text(stdscr: curses.window, row: int, col: int, text: str,
              fg: str = "white", bg: str = "black",
              bold: bool = False, underline: bool = False) -> None:
    """
    Draw text at (row, col) with direct FG_on_BG approach.
    """
    from .curses_utils import parse_two_color_names
    pair_name = f"{fg}_on_{bg}"
    attr = get_color_attr(pair_name, bold=bold, underline=underline)
    safe_addstr(stdscr, row, col, text, attr, clip_borders=True)


# FileName: curses_highlight.py
#
# version: 1.4
#
# Summary: Provides a single, globally configurable highlight/selector system.
#
# Tags: selector, highlight, effects

import curses
from .curses_color_init import color_pairs
from .curses_utils import safe_addstr, get_color_attr

GLOBAL_HIGHLIGHT_CONFIG = {
    "selected_color_name":   "YELLOW_TEXT",
    "unselected_color_name": "WHITE_TEXT",
    "effect_name":           "REVERSE_BLINK",
    "speed_factor":          5,
}

def get_global_selector_config():
    return GLOBAL_HIGHLIGHT_CONFIG

def get_selector_effect_attrs(effect="REVERSE_BLINK", frame=0, speed_factor=10) -> int:
    toggle_state = (frame // speed_factor) % 2
    if effect == "NONE":
        return curses.A_NORMAL
    elif effect == "REVERSE":
        return curses.A_REVERSE
    elif effect == "BLINK":
        return curses.A_BLINK
    elif effect == "REVERSE_BLINK":
        return (curses.A_REVERSE | curses.A_BLINK)
    elif effect == "FLASH":
        return curses.A_REVERSE if toggle_state == 0 else curses.A_NORMAL
    elif effect == "GLOW":
        return curses.A_BOLD if toggle_state == 0 else curses.A_NORMAL
    elif effect == "SHIMMER":
        return (curses.A_BOLD | curses.A_BLINK) if toggle_state == 0 else curses.A_NORMAL
    return curses.A_REVERSE  # fallback

def draw_global_selector_line(stdscr, row: int, text: str, is_selected: bool=False, frame: int=0) -> None:
    config = get_global_selector_config()
    selected_color_name   = config["selected_color_name"]
    unselected_color_name = config["unselected_color_name"]
    effect_name           = config["effect_name"]
    speed_factor          = config["speed_factor"]

    if is_selected:
        attrs = get_selector_effect_attrs(effect=effect_name, frame=frame, speed_factor=speed_factor)
        color_attr = get_color_attr(selected_color_name) | attrs
    else:
        color_attr = get_color_attr(unselected_color_name)

    safe_addstr(stdscr, row, 2, text, color_attr)


# FileName: curses_input.py
#
# version: 2.2
#
# Summary: A curses-based front-end implementing IGameInput for user interaction.
#
# Tags: curses, ui, rendering

import curses
from interfaces import IGameInput

class CursesGameInput(IGameInput):
    """
    Implements IGameInput for curses: get_actions() reads the keyboard buffer,
    returns a list of action strings like ["MOVE_UP", "QUIT", "INTERACT", etc.].
    """

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.stdscr.nodelay(True)
        self.stdscr.keypad(True)
        curses.curs_set(0)

    def get_actions(self):
        actions = []
        # read up to ~5 keystrokes at once
        for _ in range(5):
            key = self.stdscr.getch()
            if key == -1:
                break
            act = self._interpret_key(key)
            if act:
                actions.append(act)
        return actions

    def _interpret_key(self, key):
        # yes-quit
        if key in (ord('y'), ord('Y')):
            return "YES_QUIT"
        # quit => q, Q, ESC
        if key in (ord('q'), ord('Q'), 27):
            return "QUIT"

        # movement
        if key in (ord('w'), curses.KEY_UP):
            return "MOVE_UP"
        if key in (ord('s'), curses.KEY_DOWN):
            return "MOVE_DOWN"
        if key in (ord('a'), curses.KEY_LEFT):
            return "MOVE_LEFT"
        if key in (ord('d'), curses.KEY_RIGHT):
            return "MOVE_RIGHT"

        # editor toggle
        if key == ord('e'):
            return "EDITOR_TOGGLE"

        # quick-save
        if key == ord('o'):
            return "SAVE_QUICK"

        # debug
        if key == ord('v'):
            return "DEBUG_TOGGLE"

        # interact
        if key == ord(' '):
            return "INTERACT"

        # editor keys
        if key == ord('p'):
            return "PLACE_ITEM"
        if key == ord('x'):
            return "REMOVE_TOP"
        if key == ord('u'):
            return "UNDO"
        if key == ord('l'):
            return "NEXT_ITEM"
        if key == ord('k'):
            return "PREV_ITEM"

        return None


# FileName: curses_map_ui.py
#
# version: 2.14
#
# Summary: Contains the shared restore_input_mode() function used by both
#          the load and save flows. (All other save-related functions have
#          been relocated to curses_scene_save.py.)
#
# Tags: map, ui, io

import curses

def restore_input_mode(stdscr):
    """
    Restore standard no-echo, invisible cursor, non-blocking input mode.
    Used by both load and save scenes.
    """
    curses.noecho()
    curses.curs_set(0)
    curses.napms(50)
    curses.flushinp()
    stdscr.nodelay(True)


# FileName: curses_menus.py
#
# version: 2.0
#
# Summary: High-level scene/menu functions (settings screen, layered scene example),
#          formerly included scene_home_screen and MenuFlowManager, which have been
#          refactored out into curses_scene_home.py and curses_scene_manager.py.
#
# Tags: scene, animation, menu

import curses
import debug

from .curses_common import draw_screen_frame, draw_title, draw_instructions
from .curses_animations import _draw_art
from .curses_art_skins import MAIN_MENU_ART, CROCODILE, CURRENT_SKIN
from .curses_highlight import draw_global_selector_line
from .curses_renderer import CursesGameRenderer  # For example usage if we want

# -- Removed scene_home_screen (now in curses_scene_home) --
# -- Removed MenuFlowManager (now in curses_scene_manager) --

def scene_settings_screen(stdscr):
    """
    A placeholder 'Settings' screen. Press 'q' or ESC to return to the main menu.
    """
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)

    while True:
        stdscr.erase()
        draw_screen_frame(stdscr)
        draw_title(stdscr, "Settings (Placeholder)", row=1)

        info_lines = [
            "Here is where you might configure volume, video settings, etc.",
            "Press 'q' or ESC to go back..."
        ]
        draw_instructions(stdscr, info_lines, from_bottom=2)

        stdscr.refresh()

        key = stdscr.getch()
        if key in (ord('q'), ord('Q'), 27):
            return
        elif key == ord('v'):
            debug.toggle_debug()


def example_layered_scene(curses_renderer):
    """
    Example of how layered rendering might be done, though not fully utilized here.
    """
    pass  # For demonstration, left as a placeholder.


# FileName: curses_renderer.py
# version: 3.6
#
# Summary: A curses-based in-game renderer implementing IGameRenderer,
#          plus a new layered render_scene(...) approach for menus or overlays.
#
# Tags: curses, ui, rendering

import curses
import debug
from interfaces import IGameRenderer
from .curses_color_init import init_colors, color_pairs
from .curses_highlight import get_color_attr
from .curses_utils import safe_addch, safe_addstr, parse_two_color_names
from .curses_common import draw_screen_frame
from scenery_defs import ALL_SCENERY_DEFS, TREE_TRUNK_ID, TREE_TOP_ID
from scenery_main import FLOOR_LAYER, OBJECTS_LAYER, ITEMS_LAYER, ENTITIES_LAYER

class CursesGameRenderer(IGameRenderer):
    """
    Implements IGameRenderer using curses: handles rendering the game world,
    partial or full redraw, etc. Also provides a 'render_scene(...)' method
    to draw layered scenes (menus, overlays).
    """

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.map_top_offset = 3

        self.stdscr.nodelay(True)
        self.stdscr.keypad(True)
        curses.curs_set(0)
        init_colors()

    ########################################################################
    # 1) NEW: LAYERED SCENE RENDERING
    ########################################################################

    def render_scene(self, model, scene_layers):
        """
        Render a scene composed of multiple layers. We'll sort them by z ascending,
        then call a sub-render function for each layer if 'visible' is True.
        """
        self.stdscr.erase()

        # Sort by z, then draw
        sorted_layers = sorted(scene_layers, key=lambda l: l["z"])
        for layer in sorted_layers:
            if layer.get("visible", True):
                layer_name = layer.get("name", "")
                self._render_layer(layer_name, model)

        self.stdscr.noutrefresh()
        curses.doupdate()

    def _render_layer(self, layer_name, model):
        """
        Actually draw the requested layer_name. For demonstration, we do placeholders.
        """
        if layer_name == "background":
            draw_screen_frame(self.stdscr, "UI_CYAN")

        elif layer_name == "game_world":
            if model:
                self._full_redraw(model)

        # Additional layers could be here:
        # elif layer_name == "menu_overlay": ...
        # etc.

    ########################################################################
    # 2) CLASSIC GAME RENDERING (used during normal gameplay)
    ########################################################################

    def render(self, model):
        if model.full_redraw_needed:
            self._full_redraw(model)
            model.full_redraw_needed = False
        else:
            self._update_dirty_tiles(model)

        self.stdscr.noutrefresh()
        curses.doupdate()

    def on_camera_move(self, dx, dy, model):
        if abs(dx) > 0 or abs(dy) > 1:
            model.full_redraw_needed = True
            return

        max_h, max_w = self.stdscr.getmaxyx()
        self.stdscr.setscrreg(self.map_top_offset, max_h - 1)

        try:
            if dy == 1:
                self.stdscr.scroll(1)
                new_row = model.camera_y + (max_h - self.map_top_offset) - 1
                for col in range(model.camera_x, model.camera_x + max_w):
                    model.dirty_tiles.add((col, new_row))
            elif dy == -1:
                self.stdscr.scroll(-1)
                new_row = model.camera_y
                for col in range(model.camera_x, model.camera_x + max_w):
                    model.dirty_tiles.add((col, new_row))
        except curses.error:
            model.full_redraw_needed = True

        self.stdscr.setscrreg(0, max_h - 1)

    def prompt_yes_no(self, question: str) -> bool:
        """
        A simple curses-based yes/no prompt at the bottom row, returning bool.
        """
        max_h, max_w = self.stdscr.getmaxyx()
        row = max_h - 2
        safe_addstr(self.stdscr, row, 0, " " * (max_w - 1), 0, clip_borders=False)
        safe_addstr(self.stdscr, row, 2, question, 0, clip_borders=False)
        self.stdscr.refresh()

        self.stdscr.nodelay(False)
        while True:
            c = self.stdscr.getch()
            if c in (ord('y'), ord('Y')):
                self.stdscr.nodelay(True)
                return True
            elif c in (ord('n'), ord('N'), ord('q'), 27):
                self.stdscr.nodelay(True)
                return False

    def get_curses_window(self):
        return self.stdscr

    ########################################################################
    # 3) INTERNAL GAME RENDER UTILS
    ########################################################################

    def _full_redraw(self, model):
        self.stdscr.clear()
        self._draw_screen_frame()

        # Show either editor info or player's inventory
        if model.context.enable_editor_commands and model.editor_scenery_list:
            sel_def_id = model.editor_scenery_list[model.editor_scenery_index][0]
            self._draw_text(1, 2, f"Editor Mode - Selected: {sel_def_id}", "WHITE_TEXT")
        else:
            inv_text = (
                f"Inventory: Gold={model.player.gold}, "
                f"Wood={model.player.wood}, Stone={model.player.stone}"
            )
            self._draw_text(1, 2, inv_text, "WHITE_TEXT")

        max_h, max_w = self.stdscr.getmaxyx()
        visible_cols = max_w
        visible_rows = max_h - self.map_top_offset

        for wx in range(model.camera_x, min(model.camera_x + visible_cols, model.world_width)):
            for wy in range(model.camera_y, min(model.camera_y + visible_rows, model.world_height)):
                model.dirty_tiles.add((wx, wy))

        self._update_dirty_tiles(model)

    def _update_dirty_tiles(self, model):
        max_h, max_w = self.stdscr.getmaxyx()
        for (wx, wy) in model.dirty_tiles:
            if 0 <= wx < model.world_width and 0 <= wy < model.world_height:
                sx = wx - model.camera_x
                sy = wy - model.camera_y + self.map_top_offset
                if 0 <= sx < max_w and 0 <= sy < max_h:
                    self._draw_single_tile(wx, wy, sx, sy, model)

        self._draw_player_on_top(model)

    def _draw_single_tile(self, wx, wy, sx, sy, model):
        # clear background first
        blank_attr = get_color_attr("white_on_black")
        safe_addch(self.stdscr, sy, sx, " ", blank_attr, clip_borders=True)

        tile_layers = model.placed_scenery.get((wx, wy), None)
        if not tile_layers:
            return

        # Floor
        floor_obj = tile_layers.get(FLOOR_LAYER)
        floor_color_name = "white_on_black"
        if floor_obj:
            info = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {})
            ch = info.get("ascii_char", floor_obj.char)
            floor_color_name = info.get("color_name", "white_on_black")
            floor_attr = get_color_attr(floor_color_name)
            safe_addch(self.stdscr, sy, sx, ch, floor_attr, clip_borders=True)

        # Now draw objects, items, entities on top
        # Each object gets the floor's background but overrides the foreground
        obj_list = tile_layers.get(OBJECTS_LAYER, [])
        obj_list += tile_layers.get(ITEMS_LAYER, [])
        obj_list += tile_layers.get(ENTITIES_LAYER, [])

        for obj in obj_list:
            # if it's a tree trunk or top in player's tile, we might skip drawing over them later
            info = ALL_SCENERY_DEFS.get(obj.definition_id, {})
            ch = info.get("ascii_char", obj.char)
            obj_color_name = info.get("color_name", "white_on_black")

            # If it's specifically TreeTop on the player's tile, we do special logic later.
            if obj.definition_id == TREE_TOP_ID and (wx, wy) == (model.player.x, model.player.y):
                continue

            # Parse floor color to get background
            fg_floor, bg_floor = parse_two_color_names(floor_color_name)
            # Parse object color to get foreground
            fg_obj, _ = parse_two_color_names(obj_color_name)
            final_color = f"{fg_obj}_on_{bg_floor}"
            attr = get_color_attr(final_color)

            safe_addch(self.stdscr, sy, sx, ch, attr, clip_borders=True)

    def _draw_player_on_top(self, model):
        px = model.player.x - model.camera_x
        py = model.player.y - model.camera_y + self.map_top_offset
        max_h, max_w = self.stdscr.getmaxyx()

        if 0 <= px < max_w and 0 <= py < max_h:
            # Get floor color at player's tile
            tile_layers = model.placed_scenery.get((model.player.x, model.player.y), {})
            floor_obj = tile_layers.get(FLOOR_LAYER)
            floor_color_name = "white_on_black"
            if floor_obj:
                finfo = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {})
                floor_color_name = finfo.get("color_name", "white_on_black")

            fg_floor, bg_floor = parse_two_color_names(floor_color_name)
            # Player is typically "white" on the floor's background
            player_color = f"white_on_{bg_floor}"
            attr_bold = get_color_attr(player_color, bold=True)
            safe_addch(self.stdscr, py, px, "@", attr_bold, clip_borders=True)

            # If there's a trunk/top in the same tile, it might appear over the player
            objects_list = tile_layers.get(OBJECTS_LAYER, [])
            trunk_tops = [o for o in objects_list if o.definition_id in (TREE_TRUNK_ID, TREE_TOP_ID)]
            for t_obj in trunk_tops:
                info = ALL_SCENERY_DEFS.get(t_obj.definition_id, {})
                ch = info.get("ascii_char", t_obj.char)
                top_color = info.get("color_name", "white_on_black")

                # Overwrite the tile with trunk or top, ignoring player's sprite
                fg_obj, _ = parse_two_color_names(top_color)
                final_color = f"{fg_obj}_on_{bg_floor}"
                trunk_attr = get_color_attr(final_color)
                safe_addch(self.stdscr, py, px, ch, trunk_attr, clip_borders=True)

    def _draw_screen_frame(self):
        draw_screen_frame(self.stdscr)

    def _draw_text(self, row, col, text, color_name, bold=False, underline=False):
        attr = get_color_attr(color_name, bold=bold, underline=underline)
        safe_addstr(self.stdscr, row, col, text, attr, clip_borders=True)


# FileName: curses_scene_home.py
#
# version: 1.0 (extracted from curses_menus)
#
# Summary: Defines the 'scene_home_screen' function for the main / title screen.
#
# Tags: scene, home, menu

import curses
import debug

from .curses_common import draw_screen_frame, draw_title
from .curses_animations import _draw_art
from .curses_art_skins import MAIN_MENU_ART
from .curses_highlight import draw_global_selector_line

def scene_home_screen(stdscr):
    """
    Example 'home screen' that animates MAIN_MENU_ART left/right ±2 columns,
    then shows menu instructions. Returns:
      1 => Play
      2 => Quit
      3 => Settings
    """
    stdscr.nodelay(True)
    stdscr.keypad(True)
    curses.curs_set(0)

    max_shift = 2
    frame_delay_ms = 50
    shift_delay_frames = 20

    offset_x = 0
    direction = -1
    frame_count = 0

    main_menu_lines = MAIN_MENU_ART
    menu_lines = [
        "~~~~~~~~~",
        "1) Play",
        "2) Quit",
        # "3) Settings"  # We keep the placeholder index for reference
        "~~~~~~~~~"
    ]
    # We'll consider lines #1 => "1) Play", #2 => "2) Quit", #3 => "3) Settings"
    selectable_indices = [1, 2, 3]  # even though line 3 is commented, we keep the logic

    current_select_slot = 0

    while True:
        stdscr.erase()
        draw_screen_frame(stdscr)

        draw_title(stdscr, "Welcome to Retro RPG!", row=1)
        _draw_art(stdscr, main_menu_lines, start_row=3, start_col=2 + offset_x)

        # Draw menu near the bottom
        h, w = stdscr.getmaxyx()
        from_bottom = 2
        start_row = h - from_bottom - len(menu_lines)
        if start_row < 1:
            start_row = 1

        row = start_row
        for i, line_text in enumerate(menu_lines):
            is_selected = False
            if i in selectable_indices:
                sel_index = selectable_indices.index(i)
                if sel_index == current_select_slot:
                    is_selected = True
            draw_global_selector_line(
                stdscr,
                row,
                line_text,
                is_selected=is_selected,
                frame=frame_count
            )
            row += 1

        stdscr.noutrefresh()
        curses.doupdate()

        key = stdscr.getch()
        if key != -1:
            # Simple up/down to cycle among 3 "slots"
            if key in (curses.KEY_UP, ord('w'), ord('W')):
                current_select_slot = max(0, current_select_slot - 1)
            elif key in (curses.KEY_DOWN, ord('s'), ord('S')):
                if current_select_slot < len(selectable_indices) - 1:
                    current_select_slot += 1
            elif key in (curses.KEY_ENTER, 10, 13):
                # user pressed Enter on the current slot
                if current_select_slot == 0:
                    return 1  # Play
                elif current_select_slot == 1:
                    return 2  # Quit
                else:
                    return 3  # Settings
            elif key == ord('1'):
                return 1  # Play
            elif key == ord('2'):
                return 2  # Quit
            elif key == ord('3'):
                return 3  # Settings
            elif key in (ord('q'), ord('Q'), 27):
                return 2  # user pressed Esc => Quit
            elif key == ord('v'):
                debug.toggle_debug()

        frame_count += 1
        if frame_count % shift_delay_frames == 0:
            offset_x += direction
            if offset_x >= max_shift:
                offset_x = max_shift
                direction = -1
            elif offset_x <= -max_shift:
                offset_x = -max_shift
                direction = 1

        curses.napms(frame_delay_ms)



# FileName: curses_scene_load.py
#
# version: 1.0
#
# Summary: Extracted load-scene logic from curses_map_ui. Handles displaying
#          maps for loading, generating new maps, or editing existing ones.
#
# Tags: map, load, scene

import curses
import os
import debug

from .curses_color_init import init_colors
from .curses_common import draw_screen_frame, draw_title, draw_instructions
from .curses_animations import _draw_art
from .curses_art_skins import CROCODILE
from .curses_highlight import draw_global_selector_line
from .curses_utils import safe_addstr, get_color_attr
from .curses_map_ui import restore_input_mode

def draw_load_map_screen(stdscr):
    """
    Draw the screen layout for loading a map.
    """
    stdscr.clear()
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)
    draw_screen_frame(stdscr)
    draw_title(stdscr, "Load Map", row=1)
    _draw_art(stdscr, CROCODILE, start_row=3, start_col=2)

    instructions = [
        "↑/↓ = select, ENTER=load, 'd'=del, 'q'=back, 'v'=toggle debug"
    ]
    draw_instructions(stdscr, instructions, from_bottom=3, color_name="WHITE_TEXT")


def prompt_delete_confirmation(stdscr, filename):
    """
    Prompt the user: 'Delete X? (y/n)'. Return True if 'y', else False.
    """
    max_h, max_w = stdscr.getmaxyx()
    question = f"Delete '{filename}'? (y/n)"
    attr = get_color_attr("WHITE_TEXT")

    row = max_h - 2
    blank_line = " " * (max_w - 4)
    safe_addstr(stdscr, row, 2, blank_line, attr, clip_borders=False)
    safe_addstr(stdscr, row, 2, question, attr, clip_borders=False)
    stdscr.refresh()

    stdscr.nodelay(False)
    curses.curs_set(1)
    curses.echo()

    while True:
        c = stdscr.getch()
        if c in (ord('y'), ord('Y')):
            restore_input_mode(stdscr)
            return True
        elif c in (ord('n'), ord('N'), ord('q'), 27):
            restore_input_mode(stdscr)
            return False


def display_map_list(stdscr):
    """
    Show the 'load map' screen. Let user select a .json or generate a new map.
    Return:
      - The filename chosen,
      - "GENERATE" if user selects 'Generate a new map',
      - A tuple like ("EDIT", filename) if user chooses 'e' for edit mode,
      - "" if user cancels,
      - or ("EDIT_GENERATE", data) if user wants to edit a newly generated map.
    """
    init_colors()
    maps_dir = "maps"
    if not os.path.isdir(maps_dir):
        os.makedirs(maps_dir, exist_ok=True)

    files = [f for f in os.listdir(maps_dir) if f.endswith(".json")]
    files.sort()
    files.insert(0, "0) Generate a new map>")

    selected_index = 0
    frame_count = 0

    while True:
        draw_load_map_screen(stdscr)
        max_h, max_w = stdscr.getmaxyx()
        row = 10

        for i, fname in enumerate(files):
            if row >= max_h - 2:
                break
            if i == 0:
                display_text = "Generate a new map"
            else:
                display_text = f"{i}) {fname}"

            is_sel = (i == selected_index)
            draw_global_selector_line(
                stdscr,
                row,
                f"> {display_text}" if is_sel else f"  {display_text}",
                is_selected=is_sel,
                frame=frame_count
            )
            row += 1

        stdscr.refresh()
        key = stdscr.getch()

        if key in (curses.KEY_UP, ord('w'), ord('W')):
            selected_index = max(0, selected_index - 1)
        elif key in (curses.KEY_DOWN, ord('s'), ord('S')):
            selected_index = min(len(files) - 1, selected_index + 1)
        elif key in (curses.KEY_ENTER, 10, 13):
            if selected_index == 0:
                return "GENERATE"
            else:
                return files[selected_index]
        elif key in (ord('q'), ord('y')):
            return ""
        elif key == ord('e'):
            if selected_index == 0:
                return ("EDIT_GENERATE", None)
            else:
                return ("EDIT", files[selected_index])
        elif key == ord('v'):
            debug.toggle_debug()
        elif key == ord('d'):
            # Deleting a file only makes sense if selected_index > 0
            if selected_index > 0:
                to_delete = files[selected_index]
                confirm = prompt_delete_confirmation(stdscr, to_delete)
                if confirm:
                    try:
                        os.remove(os.path.join(maps_dir, to_delete))
                    except OSError:
                        pass
                    del files[selected_index]
                    if selected_index >= len(files):
                        selected_index = len(files) - 1
        elif ord('0') <= key <= ord('9'):
            typed = key - ord('0')
            if 0 <= typed < len(files):
                selected_index = typed

        if len(files) == 1:
            selected_index = 0

        frame_count += 1


def load_map_ui(stdscr):
    """
    The user flow for loading a map or generating a new one.
    Returns either:
      - "" if canceled,
      - "GENERATE" => dict of newly generated map,
      - A tuple like ("EDIT", filename),
      - or just the filename string if user loads an existing map.
    """
    selection = display_map_list(stdscr)
    if not selection:
        # user canceled => back to main menu
        return ""

    if selection == "GENERATE":
        from procedural_map_generator.generator import generate_procedural_map
        return generate_procedural_map()

    if isinstance(selection, tuple):
        if selection[0] == "EDIT_GENERATE":
            from procedural_map_generator.generator import generate_procedural_map
            data = generate_procedural_map()
            return ("EDIT_GENERATE", data)
        elif selection[0] == "EDIT":
            return ("EDIT", selection[1])

    elif isinstance(selection, dict):
        # user chose a newly generated dict
        return selection

    # Otherwise it's a filename
    return selection



# FileName: curses_scene_manager.py
#
# version: 2.1
#
# Summary: Contains the high-level MenuFlowManager class that organizes
#          the main menu screens (home, settings, play, etc.), now
#          incorporating the former play_main.py logic into "PLAY".
#
# Tags: scene, menu, manager

import curses
import debug

from .curses_scene_home import scene_home_screen
from .curses_menus import scene_settings_screen
# We now load maps directly from curses_scene_load:
from .curses_scene_load import load_map_ui
# And run the game engine from play_runner:
from play_runner import parse_and_run_play


class MenuFlowManager:
    """
    A simple controller that organizes the main menu screens (HOME, SETTINGS, PLAY)
    and transitions between them. The PLAY flow now directly loads a map
    or generates a new one, then calls parse_and_run_play from play_runner.
    """

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.current_state = "HOME"
        self.running = True

    def run(self):
        while self.running:
            if self.current_state == "HOME":
                choice = scene_home_screen(self.stdscr)
                if choice == 1:
                    # user selected "Play"
                    self.current_state = "PLAY"
                elif choice == 2:
                    # user selected "Quit"
                    self.current_state = "QUIT"
                else:
                    # user selected "Settings" (choice == 3)
                    self.current_state = "SETTINGS"

            elif self.current_state == "PLAY":
                #
                # We fold the old play_main.py loop in here:
                #
                while True:
                    selection = load_map_ui(self.stdscr)
                    if not selection:
                        # user canceled => back to main menu
                        self.current_state = "HOME"
                        break

                    # If load_map_ui returns a tuple (e.g. ("EDIT", filename)):
                    if isinstance(selection, tuple):
                        action_type, actual_map = selection
                        if action_type == "EDIT_GENERATE":
                            parse_and_run_play(self.stdscr, actual_map, is_generated=True)
                        elif action_type == "EDIT":
                            parse_and_run_play(self.stdscr, actual_map, is_generated=False)

                    elif isinstance(selection, dict):
                        # user generated a new map => is_generated = True
                        parse_and_run_play(self.stdscr, selection, is_generated=True)

                    else:
                        # user picked an existing map filename => is_generated = False
                        parse_and_run_play(self.stdscr, selection, is_generated=False)

                # Once the user cancels the load screen, we break out of the loop
                # and go back to HOME.

            elif self.current_state == "SETTINGS":
                scene_settings_screen(self.stdscr)
                self.current_state = "HOME"

            elif self.current_state == "QUIT":
                self.running = False


# FileName: curses_scene_save.py
#
# version: 1.0
#
# Summary: Extracted save-scene logic from curses_map_ui. Handles displaying
#          maps for saving (overwrite or create new) and performs the save UI flow.
#
# Tags: map, save, scene

import curses
import os
import debug

from .curses_color_init import init_colors
from .curses_common import draw_screen_frame, draw_title, draw_instructions
from .curses_animations import _draw_art
from .curses_art_skins import CROCODILE
from .curses_highlight import draw_global_selector_line
from .curses_utils import safe_addstr, get_color_attr
# Import the shared restore_input_mode from curses_map_ui:
from .curses_map_ui import restore_input_mode


def draw_save_map_screen(stdscr):
    """
    Draw the screen layout for saving a map.
    """
    stdscr.clear()
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)
    draw_screen_frame(stdscr)
    draw_title(stdscr, "Save Map", row=1)
    _draw_art(stdscr, CROCODILE, start_row=3, start_col=2)

    instructions = [
        "Select a map to overwrite, 'n'=new, ENTER=cancel, 'v'=toggle debug"
    ]
    draw_instructions(stdscr, instructions, from_bottom=3, color_name="WHITE_TEXT")


def prompt_for_filename(stdscr, prompt):
    """
    Prompt user for a filename (used by the save flow).
    """
    init_colors()
    draw_save_map_screen(stdscr)
    max_h, max_w = stdscr.getmaxyx()

    curses.echo()
    curses.curs_set(1)
    stdscr.nodelay(False)

    row = 10
    if row < max_h - 1:
        attr = get_color_attr("UI_CYAN")
        safe_addstr(stdscr, row, 2, prompt, attr, clip_borders=True)
        stdscr.refresh()

        filename_bytes = stdscr.getstr(row, 2 + len(prompt) + 1, 20)

        restore_input_mode(stdscr)

        if filename_bytes:
            return filename_bytes.decode('utf-8', errors='ignore').strip()

    restore_input_mode(stdscr)
    return ""


def display_map_list_for_save(stdscr):
    """
    Show a list of existing map files for overwriting,
    or let the user create a new one. Return:
     - map filename to overwrite,
     - "NEW_FILE" for a new filename,
     - "" if canceled.
    """
    init_colors()
    maps_dir = "maps"
    if not os.path.isdir(maps_dir):
        os.makedirs(maps_dir, exist_ok=True)

    files = [f for f in os.listdir(maps_dir) if f.endswith(".json")]
    files.sort()

    while True:
        draw_save_map_screen(stdscr)
        max_h, max_w = stdscr.getmaxyx()
        row = 10

        if files:
            attr_cyan = get_color_attr("UI_CYAN")
            _draw_global_text(stdscr, row,
                "Maps (pick number to overwrite) or 'n' for new, or Enter to cancel:",
                attr_cyan
            )
            row += 1

            for i, filename in enumerate(files, start=1):
                if row >= max_h - 1:
                    break
                attr_yellow = get_color_attr("YELLOW_TEXT")
                _draw_global_text(stdscr, row, f"{i}. {filename}", attr_yellow)
                row += 1

            if row < max_h - 1:
                _draw_global_text(stdscr, row,
                    "Enter choice or press Enter to cancel:",
                    attr_cyan
                )
                row += 1
        else:
            attr_cyan = get_color_attr("UI_CYAN")
            _draw_global_text(stdscr, row,
                "No existing maps. Press 'n' to create new, 'v' toggles debug, or Enter to cancel:",
                attr_cyan
            )
            row += 1

        stdscr.refresh()

        stdscr.nodelay(False)
        curses.curs_set(1)
        curses.echo()

        if row < max_h:
            try:
                selection_bytes = stdscr.getstr(row, 2, 20)
                if not selection_bytes:
                    restore_input_mode(stdscr)
                    return ""
                selection = selection_bytes.decode('utf-8').strip()
            except:
                restore_input_mode(stdscr)
                return ""
        else:
            restore_input_mode(stdscr)
            return ""

        restore_input_mode(stdscr)

        if not selection:
            return ""
        if selection.lower() == 'n':
            return "NEW_FILE"
        elif selection.lower() == 'v':
            debug.toggle_debug()
            continue
        elif selection.isdigit():
            idx = int(selection) - 1
            if 0 <= idx < len(files):
                return files[idx]


def _draw_global_text(stdscr, row, text, attr):
    safe_addstr(stdscr, row, 2, text, attr, clip_borders=True)


def save_map_ui(stdscr, placed_scenery, player=None,
                world_width=100, world_height=100,
                filename_override=None, notify_overwrite=False):
    """
    The user flow for saving a map. Potentially prompts for a filename,
    or overwriting an existing file.
    """
    import map_io_main
    from map_io_storage import save_map_file

    if filename_override:
        filename = filename_override
    else:
        overwrite_or_new = display_map_list_for_save(stdscr)
        if not overwrite_or_new:
            return
        if overwrite_or_new == "NEW_FILE":
            filename = prompt_for_filename(stdscr, "Enter filename to save as: ")
            if not filename:
                return
            if not filename.endswith(".json"):
                filename += ".json"
        else:
            filename = overwrite_or_new

    maps_dir = "maps"
    if not os.path.isdir(maps_dir):
        os.makedirs(maps_dir, exist_ok=True)

    save_path = os.path.join(maps_dir, filename)
    file_existed = os.path.exists(save_path)

    map_data = map_io_main.build_map_data(
        placed_scenery,
        player=player,
        world_width=world_width,
        world_height=world_height
    )

    save_map_file(save_path, map_data)

    if file_existed and notify_overwrite:
        curses.napms(500)



# FileName: curses_theme_styles.py
# version: 1.2
# Summary: Provides a centralized theming/border styling system for RetroRPG,
#          now using ASCII-only borders, unified across scenes.
# Tags: theme, style, border, curses

import curses

##############################################################################
# THEME DICTIONARY
##############################################################################
THEME = {
    "background":       "black_on_black",    # default fallback background color
    "title_color":      "white_on_black",    # color for titles
    "text_color":       "white_on_black",    # main text color
    "instruction_color":"magenta_on_black",  # instructions / footers
}

##############################################################################
# BORDER_STYLES (ASCII-only)
# We define two distinct ones: "home_box" and "white_box"
##############################################################################
BORDER_STYLES = {
    "home_box": {
        "color_name":        "WHITE_TEXT",  # or any valid color alias from curses_color_init
        "corner_tl":         "+",
        "corner_tr":         "+",
        "corner_bl":         "+",
        "corner_br":         "+",
        "line_horizontal":   "-",
        "line_vertical":     "|",
    },
    "white_box": {
        "color_name":        "WHITE_TEXT",
        "corner_tl":         "+",
        "corner_tr":         "+",
        "corner_bl":         "+",
        "corner_br":         "+",
        "line_horizontal":   "-",
        "line_vertical":     "|",
    },
}

##############################################################################
# SCENE_BORDER_MAP
# Which border style to use for each scene name.
##############################################################################
SCENE_BORDER_MAP = {
    "HOME":     "home_box",
    "SETTINGS": "white_box",
    "LOAD":     "white_box",
    "SAVE":     "white_box",
    "GAME":     "white_box",
}

##############################################################################
# OPTIONAL PER-SCENE OVERRIDES
# If you want certain scenes to override the default THEME keys.
##############################################################################
SCENE_THEME_OVERRIDES = {
    "HOME": {
        "background":  "black_on_white",
        # "title_color": "white_on_red",
    },
    "SETTINGS": {
        "title_color": "white_on_magenta",
    },
    # e.g., "LOAD" or "SAVE" could override other aspects if desired.
}


# FileName: curses_utils.py
#
# version: 1.1
#
# Summary: Provides safe curses output helpers and color attribute assembly.
#
# Tags: curses, utils

import curses
from typing import Optional
from .curses_color_init import color_pairs

def get_color_attr(color_name: str, bold: bool = False, blink: bool = False, underline: bool = False) -> int:
    """
    Given a color name like "white_on_black", returns a curses attribute
    including optional BOLD/BLINK/UNDERLINE bits.
    """
    pair_id = color_pairs.get(color_name, 0)
    attr = curses.color_pair(pair_id)
    if bold:
        attr |= curses.A_BOLD
    if blink:
        attr |= curses.A_BLINK
    if underline:
        attr |= curses.A_UNDERLINE
    return attr

def parse_two_color_names(fg_bg: str) -> (str, str):
    """
    Splits a string like "white_on_blue" into ("white","blue").
    If invalid, returns ("white","black").
    """
    parts = fg_bg.split("_on_")
    if len(parts) == 2:
        return parts[0], parts[1]
    return ("white", "black")

def _clip_coords_for_borders(row: int, col: int, max_h: int, max_w: int) -> (int, int):
    if row < 1 or row > (max_h - 2):
        return (-1, -1)
    if col < 1:
        col = 1
    if col > (max_w - 2):
        return (-1, -1)
    return (row, col)

def _truncate_for_borders_text(col: int, text: str, max_w: int) -> str:
    available_width = (max_w - 2) - col + 1
    if available_width < 1:
        return ""
    return text[:available_width]

def safe_addstr(stdscr: curses.window, row: int, col: int, text: str, attr: int, clip_borders: bool = True) -> None:
    """
    Safely add a string at (row, col), optionally clipping to a border if clip_borders=True.
    """
    max_h, max_w = stdscr.getmaxyx()

    if clip_borders:
        row2, col2 = _clip_coords_for_borders(row, col, max_h, max_w)
        if row2 < 0 or col2 < 0:
            return
        text = _truncate_for_borders_text(col2, text, max_w)
        if not text:
            return
        row, col = row2, col2
    else:
        if row < 0 or row >= max_h:
            return
        if col < 0 or col >= max_w:
            return
        available_width = max_w - col
        if available_width < 1:
            return
        text = text[:available_width]

    try:
        stdscr.addstr(row, col, text, attr)
    except curses.error:
        pass

def safe_addch(stdscr: curses.window, row: int, col: int, ch, attr: int, clip_borders: bool = True) -> None:
    """
    Safely add a single character at (row, col).
    """
    max_h, max_w = stdscr.getmaxyx()

    if clip_borders:
        row2, col2 = _clip_coords_for_borders(row, col, max_h, max_w)
        if row2 < 0 or col2 < 0:
            return
        row, col = row2, col2
    else:
        if row < 0 or row >= max_h:
            return
        if col < 0 or col >= max_w:
            return

    try:
        stdscr.addch(row, col, ch, attr)
    except curses.error:
        pass

