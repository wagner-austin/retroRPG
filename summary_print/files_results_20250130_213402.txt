
# FileName: __init__.py
#
# version: 1.0
#
# Summary: Marks this directory as a Python package for curses-based front-end.
#
# Tags: package, curses

"""
Package for all curses-based front-end modules:
 - curses_input
 - curses_renderer
 - curses_menus
 - curses_map_ui
 - curses_common (shared drawing helpers)
 - curses_animations
 - curses_highlight
 - curses_art_skins
 - curses_utils
 - curses_color_init
"""


# FileName: curses_animations.py
#
# version: 2.2
#
# Summary: Houses drawing routines for sprite/scene animations (ASCII art, borders),
#          with no permanent loops or direct user input logic. 
#
# Tags: animation, drawing, curses

import curses
import debug
from .curses_utils import safe_addstr, safe_addch, get_color_attr
from .curses_common import draw_screen_frame
from .curses_art_skins import DECORATION

def draw_subtle_art_frame(stdscr, art_lines, offset_x, start_row=3, start_col=2, color_name="ASCII_ART"):
    """
    Draw one 'frame' of the ASCII art shifted horizontally by offset_x.
    Currently unused in the home screen, but kept here in case you 
    want to re-enable animations in the future.
    """
    _draw_art(stdscr, art_lines, start_row=start_row, start_col=start_col + offset_x, color_name=color_name)

def _draw_art(stdscr, art_lines, start_row=1, start_col=2, color_name="ASCII_ART"):
    """
    Renders 'art_lines' at (start_row, start_col), using a specified color_name.
    Safe for static or single-frame usage.
    """
    attr = get_color_attr(color_name)
    max_h, max_w = stdscr.getmaxyx()
    row = start_row
    for line in art_lines:
        if row >= max_h - 1:
            break
        safe_addstr(stdscr, row, start_col, line, attr, clip_borders=True)
        row += 1


# FileName: curses_art_skins.py
#
# version: 1.2
#
# Summary: Stores ASCII art or special graphics needed for titles, load screens, or decorative UI elements.
#
# Tags: art, ui

HEADER_ART = [
    "=== HEADER ART PLACEHOLDER ===",
    "You can replace this with your own artwork."
]

LOADING_ART = [
    "--- LOADING ART PLACEHOLDER ---",
    "You can replace this with your own artwork."
]

HOMESCREEN_ART = [
    "::: HOMESCREEN ART PLACEHOLDER :::",
    "You can replace this with your own artwork."
]

DECORATION = [
    "... DECORATION PLACEHOLDER ...",
    "You can replace this with your own artwork."
]

BANNER = [
    "~~~ BANNER PLACEHOLDER ~~~"
]

BORDERS = [
    "+++ BORDERS PLACEHOLDER +++"
]

MAIN_MENU_ART = [
    "     .       +  ':.  .      *              '            *  '",
    "                  '::._                                      ",
    "                    '._)                 * +              ' ",
    "                          .              .        |         ",
    "           .      o.               +            - o -.      ",
    " o'          '    .    /  .         o             |         ",
    "    .  *   '          /                         +           ",
    "   .                 *          '                      .    ",
    "                 .             .             .  .           ",
    "   *         .   .       .                   | '.           ",
    "  +          '+                .           - o -            ",
    "          .                                . |              ",
    "            '  '     ..                   +  .  . +.        ",
    "  .                              |          .-.             ",
    " '                 .'  * '     - o -         ) )            ",
    " +        '   .                   |          '-´         '  ",
    "                       +      .'                   '.       ",
    " .           .           o      .       . .      .          ",
    "                       '       . +~~                       .",
]

CROCODILE = [
    "                _ ___                /^^\\ /^\\  /^^\\*",
    "    _          *@)@) \\            ,,/ '`~`'~~ ', `\\.",
    "  _/o\\_ _ _ _/~`.`...'~\\        ./~~..,'`','',.,' '  ~:",
    " / `','.~,~.~  .   , . , ~|,   ,/ .,' , ,. .. ,,.   `,  ~\\*",
    "( ' *' _ '*`_  '  .    ,`\\*/ .' ..' '  `  `   `..  `,   \\*",
    "  V~ V~ V~ ~\\ `   ' .  '    , ' .,.,''`.,.''`.,.``. ',   \\_",
    "  _/\\ /\\ /\\ /\\_/, . ' ,   `*/\\_ `. `. '.,  \\*",
    "< ~ ~ '~`'~'`, .,  .   `_: ::: \\_ '      `*/ ::: \\_ `.,' . ',  \\_",
    "  \\ ' `_  '`_    _    ',/ _::_::_ \\ _    _/ _::_::_ \\   `.,'.,`., \\-,-,-,_,_,",
    "   `'~~ `'~~ `'~~ `'~~  \\_)(_)(_)/  `~~' \\_)(*)(*)/ ~'`\\*..*,.*,'*;*;*;*;*;"
]

DEFAULT_SKIN = {
    "main_menu_art": MAIN_MENU_ART,
    "border_color":  "UI_CYAN",
    "title_color":   "UI_WHITE_ON_BLUE",
}

CURRENT_SKIN = DEFAULT_SKIN


# FileName: curses_color_init.py
#
# version: 3.3
#
# Summary: Initializes curses color pairs. Skips invalid indexes if terminal supports fewer colors.
#
# Tags: colors, curses, setup

import curses

# The standard 8 curses colors mapped to friendly names:
BASE_COLORS = {
    "black":   curses.COLOR_BLACK,
    "red":     curses.COLOR_RED,
    "green":   curses.COLOR_GREEN,
    "yellow":  curses.COLOR_YELLOW,
    "blue":    curses.COLOR_BLUE,
    "magenta": curses.COLOR_MAGENTA,
    "cyan":    curses.COLOR_CYAN,
    "white":   curses.COLOR_WHITE,
}

# Extended color indexes for e.g. light_gray, dark_gray, etc.
EXTENDED_COLORS = {
    "light_gray": 8,
    "dark_gray":  9,
    # Could add more if terminal supports it.
}

def define_extended_colors():
    """Attempt to initialize extra colors if the terminal supports color redefinition."""
    if not curses.can_change_color():
        return
    # light_gray => ~70% white
    curses.init_color(8, 700, 700, 700)
    # dark_gray  => ~30% white
    curses.init_color(9, 300, 300, 300)

color_pairs = {}

def init_colors():
    curses.start_color()
    curses.use_default_colors()

    # Attempt to define extended colors if supported
    define_extended_colors()

    # Merge base + extended
    all_colors = dict(BASE_COLORS)
    all_colors.update(EXTENDED_COLORS)

    pair_index = 1
    for fg_name, fg_val in all_colors.items():
        for bg_name, bg_val in all_colors.items():
            if fg_val < curses.COLORS and bg_val < curses.COLORS:
                pair_name = f"{fg_name}_on_{bg_name}"
                curses.init_pair(pair_index, fg_val, bg_val)
                color_pairs[pair_name] = pair_index
                pair_index += 1

    # Create alias names for legacy references
    ALIAS_MAP = {
        "WHITE_TEXT":        "white_on_black",
        "UI_CYAN":           "cyan_on_black",
        "UI_MAGENTA":        "magenta_on_black",
        "UI_WHITE_ON_BLUE":  "white_on_blue",
        "YELLOW_TEXT":       "yellow_on_black",
        "ASCII_ART":         "white_on_black",
        "TREE_TOP":          "green_on_black",
        "ROCK":              "white_on_black",
        "RIVER":             "white_on_blue",
        "GRASS":             "white_on_green",
        "PATH":              "black_on_yellow",
    }

    for alias_name, real_name in ALIAS_MAP.items():
        if real_name in color_pairs:
            color_pairs[alias_name] = color_pairs[real_name]
        else:
            color_pairs[alias_name] = color_pairs.get("white_on_black", 0)


# FileName: curses_common.py
#
# version: 2.9
#
# Summary: Provides functions and helpers for drawing frames, labels, etc. in curses.
#
# Tags: ui, rendering, curses

import curses
import debug
from .curses_color_init import color_pairs
from .curses_utils import safe_addstr, safe_addch, get_color_attr

INSTRUCTION_COLOR_NAME = "UI_MAGENTA"
BORDER_COLOR_NAME      = "UI_CYAN"
TITLE_COLOR_NAME       = "UI_WHITE_ON_BLUE"
TEXT_COLOR_NAME        = "YELLOW_TEXT"
ART_COLOR_NAME         = "ASCII_ART"


def draw_title(stdscr: curses.window, text: str, row: int = 1, color_name: str = TITLE_COLOR_NAME) -> None:
    max_h, max_w = stdscr.getmaxyx()
    if row < 0 or row >= max_h:
        return
    col = 2
    attr = get_color_attr(color_name, bold=True)
    safe_addstr(stdscr, row, col, text, attr, clip_borders=True)

def draw_instructions(stdscr: curses.window, lines: list[str], from_bottom: int = 2, color_name: str = INSTRUCTION_COLOR_NAME) -> None:
    """
    Draws a list of instruction lines near the bottom of the screen.
    """
    h, w = stdscr.getmaxyx()
    attr = get_color_attr(color_name)

    start_row = h - from_bottom - len(lines)
    if start_row < 1:
        start_row = 1

    row = start_row
    for line in lines:
        if row >= h - 1:
            break
        safe_addstr(stdscr, row, 2, line, attr, clip_borders=True)
        row += 1

def draw_screen_frame(stdscr: curses.window, color_name: str = BORDER_COLOR_NAME) -> None:
    """
    Draws a rectangular border around the entire screen, plus a "Debug mode" label if debug is enabled.
    """
    h, w = stdscr.getmaxyx()
    border_attr = get_color_attr(color_name)

    # Top line
    for x in range(w):
        safe_addch(stdscr, 0, x, curses.ACS_HLINE, border_attr, clip_borders=False)
    safe_addch(stdscr, 0, 0, curses.ACS_ULCORNER, border_attr, clip_borders=False)
    safe_addch(stdscr, 0, w - 1, curses.ACS_URCORNER, border_attr, clip_borders=False)

    # Bottom line
    for x in range(w):
        safe_addch(stdscr, h - 1, x, curses.ACS_HLINE, border_attr, clip_borders=False)
    safe_addch(stdscr, h - 1, 0, curses.ACS_LLCORNER, border_attr, clip_borders=False)
    safe_addch(stdscr, h - 1, w - 1, curses.ACS_LRCORNER, border_attr, clip_borders=False)

    # Left/right
    for y in range(1, h - 1):
        safe_addch(stdscr, y, 0, curses.ACS_VLINE, border_attr, clip_borders=False)
        safe_addch(stdscr, y, w - 1, curses.ACS_VLINE, border_attr, clip_borders=False)

    # Debug label
    if debug.DEBUG_CONFIG["enabled"]:
        label = "Debug mode: On"
        col = w - len(label) - 2
        dbg_attr = get_color_attr("WHITE_TEXT")
        safe_addstr(stdscr, 0, col, label, dbg_attr, clip_borders=False)

def draw_text(stdscr: curses.window, row: int, col: int, text: str,
              fg: str = "white", bg: str = "black",
              bold: bool = False, underline: bool = False) -> None:
    """
    Draw text at (row, col) with direct FG_on_BG approach.
    """
    from .curses_utils import parse_two_color_names
    pair_name = f"{fg}_on_{bg}"
    attr = get_color_attr(pair_name, bold=bold, underline=underline)
    safe_addstr(stdscr, row, col, text, attr, clip_borders=True)


# FileName: controls_ui.py
#
# version: 1.0
#
# Summary: Provides UI-related helpers for controls, including quick-saving
#          (which uses curses_scene_save) and yes/no prompts using the renderer.
#
# Tags: controls, ui

def prompt_yes_no(renderer, question):
    """
    Wrapper to ask the renderer to show a yes/no prompt. Return True if "yes".
    We keep it outside controls_main so that controls_main isn't importing UI directly.
    """
    if not renderer:
        return False
    if not hasattr(renderer, "prompt_yes_no"):
        return False
    return renderer.prompt_yes_no(question)


def perform_quick_save(model, renderer):
    """
    Performs a quick save of the map data, using curses_scene_save if we have a valid renderer.
    """
    if not renderer:
        return
    if not hasattr(renderer, "get_curses_window"):
        return

    ui_win = renderer.get_curses_window()
    if not ui_win:
        return

    from curses_frontend.curses_scene_save import save_map_ui
    player = model.player

    if model.loaded_map_filename:
        # Overwrite existing
        save_map_ui(
            ui_win,
            model.placed_scenery,
            player=player,
            world_width=model.world_width,
            world_height=model.world_height,
            filename_override=model.loaded_map_filename
        )
    else:
        # Prompt user for new name
        save_map_ui(
            ui_win,
            model.placed_scenery,
            player=player,
            world_width=model.world_width,
            world_height=model.world_height,
            filename_override=None
        )

    model.full_redraw_needed = True



# FileName: curses_highlight.py
#
# version: 1.4
#
# Summary: Provides a single, globally configurable highlight/selector system.
#
# Tags: selector, highlight, effects

import curses
from .curses_color_init import color_pairs
from .curses_utils import safe_addstr, get_color_attr

GLOBAL_HIGHLIGHT_CONFIG = {
    "selected_color_name":   "YELLOW_TEXT",
    "unselected_color_name": "WHITE_TEXT",
    "effect_name":           "REVERSE_BLINK",
    "speed_factor":          5,
}

def get_global_selector_config():
    return GLOBAL_HIGHLIGHT_CONFIG

def get_selector_effect_attrs(effect="REVERSE_BLINK", frame=0, speed_factor=10) -> int:
    toggle_state = (frame // speed_factor) % 2
    if effect == "NONE":
        return curses.A_NORMAL
    elif effect == "REVERSE":
        return curses.A_REVERSE
    elif effect == "BLINK":
        return curses.A_BLINK
    elif effect == "REVERSE_BLINK":
        return (curses.A_REVERSE | curses.A_BLINK)
    elif effect == "FLASH":
        return curses.A_REVERSE if toggle_state == 0 else curses.A_NORMAL
    elif effect == "GLOW":
        return curses.A_BOLD if toggle_state == 0 else curses.A_NORMAL
    elif effect == "SHIMMER":
        return (curses.A_BOLD | curses.A_BLINK) if toggle_state == 0 else curses.A_NORMAL
    return curses.A_REVERSE  # fallback

def draw_global_selector_line(stdscr, row: int, text: str, is_selected: bool=False, frame: int=0) -> None:
    config = get_global_selector_config()
    selected_color_name   = config["selected_color_name"]
    unselected_color_name = config["unselected_color_name"]
    effect_name           = config["effect_name"]
    speed_factor          = config["speed_factor"]

    if is_selected:
        attrs = get_selector_effect_attrs(effect=effect_name, frame=frame, speed_factor=speed_factor)
        color_attr = get_color_attr(selected_color_name) | attrs
    else:
        color_attr = get_color_attr(unselected_color_name)

    safe_addstr(stdscr, row, 2, text, color_attr)


# FileName: curses_input.py
#
# version: 2.2
#
# Summary: A curses-based front-end implementing IGameInput for user interaction.
#
# Tags: curses, ui, rendering

import curses
from engine_interfaces import IGameInput

class CursesGameInput(IGameInput):
    """
    Implements IGameInput for curses: get_actions() reads the keyboard buffer,
    returns a list of action strings like ["MOVE_UP", "QUIT", "INTERACT", etc.].
    """

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.stdscr.nodelay(True)
        self.stdscr.keypad(True)
        curses.curs_set(0)

    def get_actions(self):
        actions = []
        # read up to ~5 keystrokes at once
        for _ in range(5):
            key = self.stdscr.getch()
            if key == -1:
                break
            act = self._interpret_key(key)
            if act:
                actions.append(act)
        return actions

    def _interpret_key(self, key):
        # yes-quit
        if key in (ord('y'), ord('Y')):
            return "YES_QUIT"
        # quit => q, Q, ESC
        if key in (ord('q'), ord('Q'), 27):
            return "QUIT"

        # movement
        if key in (ord('w'), curses.KEY_UP):
            return "MOVE_UP"
        if key in (ord('s'), curses.KEY_DOWN):
            return "MOVE_DOWN"
        if key in (ord('a'), curses.KEY_LEFT):
            return "MOVE_LEFT"
        if key in (ord('d'), curses.KEY_RIGHT):
            return "MOVE_RIGHT"

        # editor toggle
        if key == ord('e'):
            return "EDITOR_TOGGLE"

        # quick-save
        if key == ord('o'):
            return "SAVE_QUICK"

        # debug
        if key == ord('v'):
            return "DEBUG_TOGGLE"

        # interact
        if key == ord(' '):
            return "INTERACT"

        # editor keys
        if key == ord('p'):
            return "PLACE_ITEM"
        if key == ord('x'):
            return "REMOVE_TOP"
        if key == ord('u'):
            return "UNDO"
        if key == ord('l'):
            return "NEXT_ITEM"
        if key == ord('k'):
            return "PREV_ITEM"

        return None


# FileName: curses_renderer.py
# version: 3.8 (updated to remove camera logic)
#
# Summary: A curses-based in-game renderer implementing IGameRenderer,
#          with partial scrolling as a rendering optimization only.
#          No camera or game logic in this file.
#
# Tags: curses, ui, rendering

import curses
import debug

# Note: 'IGameRenderer' is now in engine_interfaces.py
from engine_interfaces import IGameRenderer

from .curses_color_init import init_colors
from .curses_highlight import get_color_attr
from .curses_utils import safe_addch, safe_addstr, parse_two_color_names
from .curses_common import draw_screen_frame
from scenery_defs import ALL_SCENERY_DEFS, TREE_TRUNK_ID, TREE_TOP_ID
from scenery_main import FLOOR_LAYER, OBJECTS_LAYER, ITEMS_LAYER, ENTITIES_LAYER

class CursesGameRenderer(IGameRenderer):
    """
    Implements IGameRenderer using curses: strictly drawing logic only.
    Partial scrolling is done as a rendering optimization if the camera
    has moved by exactly +1 or -1 row. No camera logic here.
    """

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.map_top_offset = 3

        self.stdscr.nodelay(True)
        self.stdscr.keypad(True)
        curses.curs_set(0)
        init_colors()

    ########################################################################
    # 1) LAYERED SCENE RENDERING
    ########################################################################

    def render_scene(self, model, scene_layers):
        """
        Render a scene composed of multiple layers. We'll sort them by z ascending,
        then call a sub-render function for each layer if 'visible' is True.
        """
        self.stdscr.erase()

        # Sort by z, then draw
        sorted_layers = sorted(scene_layers, key=lambda l: l["z"])
        for layer in sorted_layers:
            if layer.get("visible", True):
                layer_name = layer.get("name", "")
                self._render_layer(layer_name, model)

        self.stdscr.noutrefresh()
        curses.doupdate()

    def _render_layer(self, layer_name, model):
        """
        Actually draw the requested layer_name. For demonstration, we do placeholders.
        """
        if layer_name == "background":
            draw_screen_frame(self.stdscr, "UI_CYAN")

        elif layer_name == "game_world":
            if model:
                self._full_redraw(model)

    ########################################################################
    # 2) CLASSIC GAME RENDERING (used during normal gameplay)
    ########################################################################

    def render(self, model):
        # Decide if we can do partial scrolling in Y direction
        dx = getattr(model, "ui_scroll_dx", 0)
        dy = getattr(model, "ui_scroll_dy", 0)

        if model.full_redraw_needed:
            self._full_redraw(model)
            model.full_redraw_needed = False
        else:
            # If camera moved exactly ±1 row in Y (and no X movement),
            # we try partial scroll. Otherwise, just update dirty tiles.
            if dx == 0 and abs(dy) == 1:
                self._partial_scroll(dy, model)
            else:
                self._update_dirty_tiles(model)

        # Reset the scroll deltas after we have rendered this frame
        model.ui_scroll_dx = 0
        model.ui_scroll_dy = 0

        self.stdscr.noutrefresh()
        curses.doupdate()

    ########################################################################
    # 3) INTERNAL RENDERING FUNCTIONS
    ########################################################################

    def _partial_scroll(self, dy, model):
        """
        Curses-specific partial scrolling optimization when camera moves by ±1 row.
        """
        max_h, max_w = self.stdscr.getmaxyx()
        self.stdscr.setscrreg(self.map_top_offset, max_h - 1)

        try:
            if dy == 1:
                # Scrolling down -> camera moved up by 1
                self.stdscr.scroll(1)
                new_row = model.camera_y + (max_h - self.map_top_offset) - 1
                for col in range(model.camera_x, model.camera_x + max_w):
                    model.dirty_tiles.add((col, new_row))
            elif dy == -1:
                # Scrolling up -> camera moved down by 1
                self.stdscr.scroll(-1)
                new_row = model.camera_y
                for col in range(model.camera_x, model.camera_x + max_w):
                    model.dirty_tiles.add((col, new_row))

        except curses.error:
            model.full_redraw_needed = True

        self.stdscr.setscrreg(0, max_h - 1)

        # We still need to refresh the newly exposed row
        self._update_dirty_tiles(model)

    def _full_redraw(self, model):
        self.stdscr.clear()
        self._draw_screen_frame()

        # Show either editor info or player's inventory
        if model.context.enable_editor_commands and model.editor_scenery_list:
            sel_def_id = model.editor_scenery_list[model.editor_scenery_index][0]
            self._draw_text(1, 2, f"Editor Mode - Selected: {sel_def_id}", "WHITE_TEXT")
        else:
            inv_text = (
                f"Inventory: Gold={model.player.gold}, "
                f"Wood={model.player.wood}, Stone={model.player.stone}"
            )
            self._draw_text(1, 2, inv_text, "WHITE_TEXT")

        max_h, max_w = self.stdscr.getmaxyx()
        visible_cols = max_w
        visible_rows = max_h - self.map_top_offset

        # Mark everything visible as dirty
        for wx in range(model.camera_x, min(model.camera_x + visible_cols, model.world_width)):
            for wy in range(model.camera_y, min(model.camera_y + visible_rows, model.world_height)):
                model.dirty_tiles.add((wx, wy))

        self._update_dirty_tiles(model)

    def _update_dirty_tiles(self, model):
        max_h, max_w = self.stdscr.getmaxyx()
        for (wx, wy) in model.dirty_tiles:
            if 0 <= wx < model.world_width and 0 <= wy < model.world_height:
                sx = wx - model.camera_x
                sy = wy - model.camera_y + self.map_top_offset
                if 0 <= sx < max_w and 0 <= sy < max_h:
                    self._draw_single_tile(wx, wy, sx, sy, model)

        self._draw_player_on_top(model)

    def _draw_single_tile(self, wx, wy, sx, sy, model):
        blank_attr = get_color_attr("white_on_black")
        safe_addch(self.stdscr, sy, sx, " ", blank_attr, clip_borders=True)

        tile_layers = model.placed_scenery.get((wx, wy), None)
        if not tile_layers:
            return

        # Floor
        floor_obj = tile_layers.get(FLOOR_LAYER)
        floor_color_name = "white_on_black"
        if floor_obj:
            info = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {})
            ch = info.get("ascii_char", floor_obj.char)
            floor_color_name = info.get("color_name", "white_on_black")
            floor_attr = get_color_attr(floor_color_name)
            safe_addch(self.stdscr, sy, sx, ch, floor_attr, clip_borders=True)

        # Objects, items, entities
        obj_list = tile_layers.get(OBJECTS_LAYER, []) + \
                   tile_layers.get(ITEMS_LAYER, []) + \
                   tile_layers.get(ENTITIES_LAYER, [])

        for obj in obj_list:
            info = ALL_SCENERY_DEFS.get(obj.definition_id, {})
            ch = info.get("ascii_char", obj.char)
            obj_color_name = info.get("color_name", "white_on_black")

            # If it's specifically TreeTop on the player's tile, we handle later
            if obj.definition_id == TREE_TOP_ID and (wx, wy) == (model.player.x, model.player.y):
                continue

            fg_floor, bg_floor = parse_two_color_names(floor_color_name)
            fg_obj, _ = parse_two_color_names(obj_color_name)
            final_color = f"{fg_obj}_on_{bg_floor}"
            attr = get_color_attr(final_color)

            safe_addch(self.stdscr, sy, sx, ch, attr, clip_borders=True)

    def _draw_player_on_top(self, model):
        px = model.player.x - model.camera_x
        py = model.player.y - model.camera_y + self.map_top_offset
        max_h, max_w = self.stdscr.getmaxyx()

        if 0 <= px < max_w and 0 <= py < max_h:
            tile_layers = model.placed_scenery.get((model.player.x, model.player.y), {})
            floor_obj = tile_layers.get(FLOOR_LAYER)
            floor_color_name = "white_on_black"
            if floor_obj:
                finfo = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {})
                floor_color_name = finfo.get("color_name", "white_on_black")

            fg_floor, bg_floor = parse_two_color_names(floor_color_name)
            player_color = f"white_on_{bg_floor}"
            attr_bold = get_color_attr(player_color, bold=True)
            safe_addch(self.stdscr, py, px, "@", attr_bold, clip_borders=True)

            # Overwrite with trunk/top if present
            objects_list = tile_layers.get(OBJECTS_LAYER, [])
            trunk_tops = [o for o in objects_list if o.definition_id in (TREE_TRUNK_ID, TREE_TOP_ID)]
            for t_obj in trunk_tops:
                info = ALL_SCENERY_DEFS.get(t_obj.definition_id, {})
                ch = info.get("ascii_char", t_obj.char)
                top_color = info.get("color_name", "white_on_black")

                fg_obj, _ = parse_two_color_names(top_color)
                final_color = f"{fg_obj}_on_{bg_floor}"
                trunk_attr = get_color_attr(final_color)
                safe_addch(self.stdscr, py, px, ch, trunk_attr, clip_borders=True)

    def _draw_screen_frame(self):
        draw_screen_frame(self.stdscr)

    def _draw_text(self, row, col, text, color_name, bold=False, underline=False):
        attr = get_color_attr(color_name, bold=bold, underline=underline)
        safe_addstr(self.stdscr, row, col, text, attr, clip_borders=True)


# FileName: curses_scene_game.py
# version: 1.0
#
# Summary: This scene sets up the curses-based input & renderer and calls run_game_loop from engine_main.
# 
# Tags: scene, game, curses

import curses
from .curses_input import CursesGameInput
from .curses_renderer import CursesGameRenderer
from engine_main import run_game_loop

def game_scene_ui(stdscr, model, context):
    """
    Sets up the curses-based input & rendering, then runs the main game loop
    with the given model & context. Returns when the loop ends.
    """
    # Basic curses setup
    stdscr.nodelay(True)
    stdscr.keypad(True)
    curses.curs_set(0)

    # Create front-end objects
    game_input = CursesGameInput(stdscr)
    game_renderer = CursesGameRenderer(stdscr)

    # Enter the main logic loop (in engine_main)
    run_game_loop(model, context, game_input, game_renderer)



# FileName: curses_scene_home.py
#
# version: 1.1
#
# Summary: Defines the 'scene_home_screen' function for the main / title screen.
#          Now with no animation loop; we simply draw a static banner (if desired).
#
# Tags: scene, home, menu

import curses
import debug

from .curses_common import draw_screen_frame, draw_title
# We still import _draw_art if you want a STATIC display of the ASCII art:
from .curses_animations import _draw_art
from .curses_art_skins import MAIN_MENU_ART
from .curses_highlight import draw_global_selector_line

def home_scene_ui(stdscr):
    """
    The main 'home screen' with a static ASCII banner (optional)
    and a simple menu for Play/Quit/Settings. Returns:
      1 => Play
      2 => Quit
      3 => Settings
    """
    stdscr.nodelay(True)
    stdscr.keypad(True)
    curses.curs_set(0)

    main_menu_lines = MAIN_MENU_ART  # ASCII lines if you'd like to display them
    menu_lines = [
        "~~~~~~~~~",
        "1) Play",
        "2) Quit",
        "3) Settings",
        "~~~~~~~~~"
    ]
    # We'll consider lines #1 => "1) Play", #2 => "2) Quit", #3 => "3) Settings"
    selectable_indices = [1, 2, 3]

    current_select_slot = 0
    frame_count = 0

    while True:
        stdscr.erase()
        draw_screen_frame(stdscr)
        draw_title(stdscr, "Welcome to Retro RPG!", row=1)

        # If you want to show a *static* ASCII banner, do it here:
        _draw_art(stdscr, main_menu_lines, start_row=3, start_col=2)

        # Draw menu near the bottom
        h, w = stdscr.getmaxyx()
        from_bottom = 2
        start_row = h - from_bottom - len(menu_lines)
        if start_row < 1:
            start_row = 1

        row = start_row
        for i, line_text in enumerate(menu_lines):
            is_selected = False
            if i in selectable_indices:
                sel_index = selectable_indices.index(i)
                if sel_index == current_select_slot:
                    is_selected = True
            draw_global_selector_line(
                stdscr,
                row,
                line_text,
                is_selected=is_selected,
                frame=frame_count
            )
            row += 1

        stdscr.noutrefresh()
        curses.doupdate()

        key = stdscr.getch()
        if key != -1:
            # Simple up/down to cycle among 3 menu items
            if key in (curses.KEY_UP, ord('w'), ord('W')):
                current_select_slot = max(0, current_select_slot - 1)
            elif key in (curses.KEY_DOWN, ord('s'), ord('S')):
                if current_select_slot < len(selectable_indices) - 1:
                    current_select_slot += 1
            elif key in (curses.KEY_ENTER, 10, 13):
                # user pressed Enter on the current slot
                if current_select_slot == 0:
                    return 1  # Play
                elif current_select_slot == 1:
                    return 2  # Quit
                else:
                    return 3  # Settings
            elif key == ord('1'):
                return 1  # Play
            elif key == ord('2'):
                return 2  # Quit
            elif key == ord('3'):
                return 3  # Settings
            elif key in (ord('q'), ord('Q'), 27):
                return 2  # user pressed Esc => Quit
            elif key == ord('v'):
                debug.toggle_debug()


# FileName: curses_scene_load.py
# version: 1.3 (extracted load UI from curses_scene_file_select.py)
#
# Summary: Contains the user flow for loading or generating a map.
#          Now calls the local function select_map_file_load_mode(...) 
#          for the file-list logic, instead of referencing curses_scene_file_select.
#
# Tags: map, load, scene

import curses
import debug

from procedural_map_generator.generator import generate_procedural_map
from .curses_common import draw_screen_frame, draw_title, draw_instructions
from .curses_animations import _draw_art
from .curses_art_skins import CROCODILE
from .curses_utils import safe_addstr, get_color_attr
from .curses_highlight import draw_global_selector_line

from map_list_logic import get_map_list, delete_map_file

def load_scene_ui(stdscr):
    """
    The user flow for loading a map or generating a new one.
    Returns either:
      - "" if canceled,
      - a dict (procedurally generated) if user picks "Generate a new map",
      - a tuple like ("EDIT", filename) or ("EDIT_GENERATE", data),
      - or just the filename string if user loads an existing map.
    """
    while True:
        selection = select_map_file_load_mode(stdscr)
        if not selection:
            # user canceled => back to main menu
            return ""

        if selection == "GENERATE":
            # user wants to generate a new map
            data = generate_procedural_map()
            return data

        if isinstance(selection, tuple):
            # The "EDITOR" variants
            action_type, actual_map = selection
            if action_type == "EDIT_GENERATE":
                data = generate_procedural_map()
                return (action_type, data)
            elif action_type == "EDIT":
                return (action_type, actual_map)

        elif isinstance(selection, dict):
            # If for some reason it returned a dict, just return it
            return selection

        else:
            # user picked an existing file by name
            return selection


def select_map_file_load_mode(stdscr):
    """
    Displays a list of .json map files in 'maps' directory for load usage.
    Returns "GENERATE", a filename string, "", or a tuple like ("EDIT", filename),
    or ("EDIT_GENERATE", None).
    """
    files = get_map_list(maps_dir="maps", extension=".json")
    return _select_map_file_load_mode(stdscr, files)


def _select_map_file_load_mode(stdscr, files):
    # Insert "Generate a new map>" at index 0
    files.insert(0, "0) Generate a new map>")

    selected_index = 0
    frame_count = 0

    while True:
        _draw_load_map_screen(stdscr)
        max_h, max_w = stdscr.getmaxyx()
        row = 10

        # Display the list of maps
        for i, fname in enumerate(files):
            if row >= max_h - 2:
                break

            if i == 0:
                display_text = "Generate a new map"
            else:
                display_text = f"{i}) {fname}"

            is_sel = (i == selected_index)
            draw_global_selector_line(
                stdscr,
                row,
                f"> {display_text}" if is_sel else f"  {display_text}",
                is_selected=is_sel,
                frame=frame_count
            )
            row += 1

        stdscr.refresh()
        key = stdscr.getch()

        if key in (curses.KEY_UP, ord('w'), ord('W')):
            selected_index = max(0, selected_index - 1)
        elif key in (curses.KEY_DOWN, ord('s'), ord('S')):
            selected_index = min(len(files) - 1, selected_index + 1)
        elif key in (curses.KEY_ENTER, 10, 13):
            # Enter = pick
            if selected_index == 0:
                return "GENERATE"
            else:
                return files[selected_index]
        elif key in (ord('q'), ord('y')):
            return ""
        elif key == ord('v'):
            debug.toggle_debug()
        elif key == ord('d'):
            # Deleting a file only if selected_index > 0
            if selected_index > 0:
                to_delete = files[selected_index]
                confirm = prompt_delete_confirmation(stdscr, to_delete)
                if confirm:
                    success = delete_map_file(to_delete, maps_dir="maps")
                    if success:
                        del files[selected_index]
                        if selected_index >= len(files):
                            selected_index = len(files) - 1
        elif key == ord('e'):
            # Editor mode
            if selected_index == 0:
                return ("EDIT_GENERATE", None)
            else:
                return ("EDIT", files[selected_index])
        elif ord('0') <= key <= ord('9'):
            # Quick numeric selection
            typed = key - ord('0')
            if 0 <= typed < len(files):
                selected_index = typed

        if len(files) == 1:
            # Only "Generate a new map" remains
            selected_index = 0

        frame_count += 1


def prompt_delete_confirmation(stdscr, filename):
    """
    Prompt the user: 'Delete X? (y/n)'. Return True if 'y', else False.
    """
    max_h, max_w = stdscr.getmaxyx()
    question = f"Delete '{filename}'? (y/n)"
    attr = get_color_attr("WHITE_TEXT")

    row = max_h - 2
    blank_line = " " * (max_w - 4)
    safe_addstr(stdscr, row, 2, blank_line, attr, clip_borders=False)
    safe_addstr(stdscr, row, 2, question, attr, clip_borders=False)
    stdscr.refresh()

    stdscr.nodelay(False)
    curses.curs_set(1)
    curses.echo()

    while True:
        c = stdscr.getch()
        if c in (ord('y'), ord('Y')):
            _restore_input_mode(stdscr)
            return True
        elif c in (ord('n'), ord('N'), ord('q'), 27):
            _restore_input_mode(stdscr)
            return False


def _draw_load_map_screen(stdscr):
    stdscr.clear()
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)
    draw_screen_frame(stdscr)
    draw_title(stdscr, "Load Map", row=1)
    _draw_art(stdscr, CROCODILE, start_row=3, start_col=2)

    instructions = [
        "↑/↓ = select, ENTER=load, 'd'=del, 'q'=back, 'v'=dbg, 'e'=editor"
    ]
    draw_instructions(stdscr, instructions, from_bottom=3, color_name="WHITE_TEXT")


def _restore_input_mode(stdscr):
    curses.noecho()
    curses.curs_set(0)
    curses.napms(50)
    curses.flushinp()
    stdscr.nodelay(True)


# FileName: curses_scene_manager.py
# version: 3.2 (now prompts y/n to save if leaving a newly generated map)
#
# Summary: Contains the high-level MenuFlowManager class that organizes
#          the main menu screens (HOME, SETTINGS, PLAY, EDIT).
#          Uses 'play_runner' purely for building the model,
#          calls 'curses_scene_game.game_scene_ui' for curses I/O,
#          then adds a y/n save prompt if the map was newly generated.
#
# Tags: scene, menu, manager

import os
import json
import curses  # needed for user input in the prompt method

from .curses_scene_home import home_scene_ui
from .curses_scene_settings import settings_scene_ui
from .curses_scene_load import load_scene_ui
from .curses_scene_game import game_scene_ui
from .curses_scene_save import save_map_ui

from player_char_io import save_player
from map_io_storage import save_map_file
from play_runner import (
    build_model_for_play,
    build_model_for_editor
)


class MenuFlowManager:
    """
    A controller that organizes the main menu screens (HOME, SETTINGS, GAME).
    The GAME flow loads or generates a map, then calls game_scene_ui(...) for
    actual gameplay/editor usage. If the map is new, we prompt y/n to save.
    Finally, we update the player's data or map file if needed, then
    return to the main menu or quit.
    """

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.current_state = "HOME"
        self.running = True

    def run(self):
        while self.running:
            if self.current_state == "HOME":
                choice = home_scene_ui(self.stdscr)
                if choice == 1:  # Play
                    self.current_state = "PLAY"
                elif choice == 2:  # Quit
                    self.current_state = "QUIT"
                else:             # Settings
                    self.current_state = "SETTINGS"

            elif self.current_state == "PLAY":
                # Keep letting the user pick a map or "Generate new" until they cancel
                while True:
                    selection = load_scene_ui(self.stdscr)
                    if not selection:
                        # user canceled => back to main menu
                        self.current_state = "HOME"
                        break

                    # 1) "Generate new map" => special string "GENERATE"
                    if selection == "GENERATE":
                        model, context = build_model_for_play({}, is_generated=True)
                        if not model:
                            self.current_state = "HOME"
                            break

                        game_scene_ui(self.stdscr, model, context)
                        save_player(model.player)

                        # If brand new, prompt user y/n to save
                        self._post_game_scene_save(model)
                        continue

                    # 2) If we got a dict => newly generated (procedural) map
                    if isinstance(selection, dict):
                        model, context = build_model_for_play(selection, is_generated=True)
                        if not model:
                            self.current_state = "HOME"
                            break

                        game_scene_ui(self.stdscr, model, context)
                        save_player(model.player)

                        # If brand new, prompt user y/n to save
                        self._post_game_scene_save(model)
                        continue

                    # 3) A tuple => user wants Editor mode
                    if isinstance(selection, tuple):
                        action_type, actual_map = selection
                        if action_type == "EDIT_GENERATE":
                            model, context = build_model_for_editor({}, is_generated=True)
                        elif action_type == "EDIT":
                            model, context = build_model_for_editor(actual_map, is_generated=False)
                        else:
                            self.current_state = "HOME"
                            break

                        if not model:
                            self.current_state = "HOME"
                            break

                        game_scene_ui(self.stdscr, model, context)
                        save_player(model.player)

                        # If brand new, prompt user y/n to save
                        self._post_game_scene_save(model)

                        # If it was an existing file, update the JSON with new x,y
                        if action_type == "EDIT" and model.loaded_map_filename:
                            self._update_player_coords_in_map(
                                model.loaded_map_filename,
                                model.player.x,
                                model.player.y
                            )
                        continue

                    # 4) Otherwise, it's a string => a filename (existing map)
                    filename = selection
                    model, context = build_model_for_play(filename, is_generated=False)
                    if not model:
                        self.current_state = "HOME"
                        break

                    game_scene_ui(self.stdscr, model, context)
                    save_player(model.player)

                    # If brand new, prompt user y/n to save (rare, but in theory possible)
                    self._post_game_scene_save(model)

                    # If we loaded from an actual file, store new x,y
                    if model.loaded_map_filename:
                        self._update_player_coords_in_map(
                            model.loaded_map_filename,
                            model.player.x,
                            model.player.y
                        )
                # Done handling all "PLAY" cycles

            elif self.current_state == "SETTINGS":
                settings_scene_ui(self.stdscr)
                self.current_state = "HOME"

            elif self.current_state == "QUIT":
                self.running = False

    def _update_player_coords_in_map(self, filename, px, py):
        """
        Helper to store player's final x,y into an existing map file (JSON).
        """
        maps_dir = "maps"
        map_path = os.path.join(maps_dir, filename)
        if not os.path.exists(map_path):
            return
        try:
            with open(map_path, "r") as f:
                data = json.load(f)
            data["player_x"] = px
            data["player_y"] = py
            save_map_file(map_path, data)
        except:
            pass

    def _post_game_scene_save(self, model):
        """
        If 'model' has no 'loaded_map_filename', it means it's a new map.
        Prompt the user whether to save. If yes, show the standard save UI.
        If no, do nothing (skip) and return to the load screen (next iteration).
        """
        is_new = (model.loaded_map_filename is None)
        if is_new:
            # Prompt user "Save new map? (y/n)" at bottom of screen
            wants_save = self._prompt_save_new_map()
            if wants_save:
                # Proceed with standard save UI
                placed_scenery = getattr(model, 'placed_scenery', {})
                w = getattr(model, 'width', 100)
                h = getattr(model, 'height', 100)
                save_map_ui(
                    self.stdscr,
                    placed_scenery=placed_scenery,
                    player=model.player,
                    world_width=w,
                    world_height=h,
                    filename_override=None,  # user picks or creates a name
                    notify_overwrite=False
                )
            # If user says no, we skip saving and go back to the load scene
            # (the 'while True' will continue -> calls load_scene_ui again)
        else:
            # If it's an existing file, no special prompt is needed.
            # The user might still have the auto "save_map_ui" for existing
            # maps, if you want that logic. But in the current code, we only
            # auto-update x,y in the file.
            pass

    def _prompt_save_new_map(self):
        """
        Displays a yes/no prompt at the bottom: "Save new map? (y/n)"
        Returns True if user selects 'y', False if 'n' or ESC.
        """
        max_h, max_w = self.stdscr.getmaxyx()
        question = "Save new map? (y/n)"
        row = max_h - 2
        col = 2

        # Prepare the screen for input
        self.stdscr.nodelay(False)
        curses.curs_set(1)
        curses.echo()

        # Clear the line
        blank_line = " " * (max_w - 4)
        self.stdscr.addstr(row, col, blank_line)
        self.stdscr.move(row, col)
        self.stdscr.addstr(row, col, question)
        self.stdscr.refresh()

        while True:
            c = self.stdscr.getch()
            if c in (ord('y'), ord('Y')):
                self._restore_input_mode()
                return True
            elif c in (ord('n'), ord('N'), ord('q'), 27):  # ESC or n => no
                self._restore_input_mode()
                return False

    def _restore_input_mode(self):
        """
        Return terminal to a no-echo, no-cursor, non-blocking mode.
        """
        curses.noecho()
        curses.curs_set(0)
        curses.napms(50)
        curses.flushinp()
        self.stdscr.nodelay(True)


# FileName: curses_scene_save.py
# version: 1.5 (merged with file_select bridging; removed curses_scene_file_select.py)
#
# Summary: Contains all save-scene logic for picking/creating filenames,
#          prompting for overwrites, and storing map data.
#
# Tags: map, save, scene

import curses
import debug

import map_io_main
from map_io_storage import save_map_file
from map_list_logic import file_exists_in_maps_dir, get_map_list
from .curses_utils import safe_addstr, get_color_attr
from .curses_common import draw_screen_frame, draw_title, draw_instructions
from .curses_animations import _draw_art
from .curses_art_skins import CROCODILE


def select_map_file(stdscr, mode='save'):
    """
    Bridging function to display a file list for 'save' usage.

    - If mode != 'save', raises ValueError.
    - Fetches existing .json files from 'maps' dir,
      then calls select_map_file_save_mode(...).
    - Returns either the chosen filename, "NEW_FILE", or "" if canceled.
    """
    if mode != 'save':
        raise ValueError("select_map_file(...) now only supports 'save' mode.")

    files = get_map_list(maps_dir="maps", extension=".json")
    return select_map_file_save_mode(stdscr, files)


def select_map_file_save_mode(stdscr, files):
    """
    Displays a list of .json map files for 'save' usage.

    Returns one of:
      - "NEW_FILE": user wants to create a new filename
      - a filename string (chosen from the list)
      - "" if canceled
    """
    while True:
        _draw_save_map_screen(stdscr)
        max_h, max_w = stdscr.getmaxyx()
        row = 10

        attr_cyan = get_color_attr("UI_CYAN")
        attr_yellow = get_color_attr("YELLOW_TEXT")

        if files:
            safe_addstr(
                stdscr, row, 2,
                "Maps (pick number to overwrite) or 'n' for new, or Enter to cancel:",
                attr_cyan, clip_borders=True
            )
            row += 1

            for i, filename in enumerate(files, start=1):
                if row >= max_h - 1:
                    break
                safe_addstr(stdscr, row, 2, f"{i}. {filename}", attr_yellow, clip_borders=True)
                row += 1

            if row < max_h - 1:
                safe_addstr(
                    stdscr, row, 2,
                    "Enter choice or press Enter to cancel:",
                    attr_cyan, clip_borders=True
                )
                row += 1
        else:
            # No existing files found
            safe_addstr(
                stdscr, row, 2,
                "No existing maps. Press 'n' to create new, 'v' toggles debug, or Enter to cancel:",
                attr_cyan, clip_borders=True
            )
            row += 1

        stdscr.refresh()

        stdscr.nodelay(False)
        curses.curs_set(1)
        curses.echo()

        # Get user input on the same row (if we still have space)
        if row < max_h:
            try:
                selection_bytes = stdscr.getstr(row, 2, 20)
                if not selection_bytes:
                    # User pressed Enter with no input => canceled
                    _restore_input_mode(stdscr)
                    return ""
                selection = selection_bytes.decode('utf-8').strip()
            except:
                _restore_input_mode(stdscr)
                return ""
        else:
            _restore_input_mode(stdscr)
            return ""

        # Restore normal (no-echo) mode
        _restore_input_mode(stdscr)

        if not selection:
            # User canceled
            return ""
        if selection.lower() == 'n':
            return "NEW_FILE"
        elif selection.lower() == 'v':
            debug.toggle_debug()
            continue
        elif selection.isdigit():
            idx = int(selection) - 1
            if 0 <= idx < len(files):
                return files[idx]


def _draw_save_map_screen(stdscr):
    """
    Draws the "Save Map" header/art/instructions at the top.
    """
    stdscr.clear()
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)

    draw_screen_frame(stdscr)
    draw_title(stdscr, "Save Map", row=1)
    _draw_art(stdscr, CROCODILE, start_row=3, start_col=2)

    instructions = [
        "Select a map to overwrite, 'n'=new, ENTER=cancel, 'v'=toggle debug"
    ]
    draw_instructions(stdscr, instructions, from_bottom=3, color_name="WHITE_TEXT")


def prompt_for_filename(stdscr, prompt):
    """
    Prompt user for a new filename (used by the save flow).
    Returns the typed string or "" if canceled/empty.
    """
    max_h, max_w = stdscr.getmaxyx()

    curses.echo()
    curses.curs_set(1)
    stdscr.nodelay(False)

    row = 10
    if row < max_h - 1:
        attr = get_color_attr("UI_CYAN")
        safe_addstr(stdscr, row, 2, prompt, attr, clip_borders=True)
        stdscr.refresh()

        filename_bytes = stdscr.getstr(row, 2 + len(prompt) + 1, 20)
        _restore_input_mode(stdscr)

        if filename_bytes:
            return filename_bytes.decode('utf-8', errors='ignore').strip()

    # If user didn't enter anything or row is out of range:
    _restore_input_mode(stdscr)
    return ""


def save_map_ui(stdscr,
                placed_scenery,
                player=None,
                world_width=100,
                world_height=100,
                filename_override=None,
                notify_overwrite=False):
    """
    The user flow for saving a map. Potentially prompts for a filename or overwriting.
    If filename_override is given, skip the selection and use that name directly.
    Otherwise:
      1) We show a "save" list of existing files (via select_map_file(..., mode='save')).
      2) User can pick a file to overwrite or type 'n' for new => new filename prompt.
      3) If user cancels at any point, we just return.
    """
    if filename_override:
        # If we have a forced filename, skip the UI and use that
        filename = filename_override
    else:
        overwrite_or_new = select_map_file(stdscr, mode='save')
        if not overwrite_or_new:
            # user canceled => return
            return

        if overwrite_or_new == "NEW_FILE":
            filename = prompt_for_filename(stdscr, "Enter filename to save as: ")
            if not filename:
                return
            if not filename.endswith(".json"):
                filename += ".json"
        else:
            filename = overwrite_or_new

    # Check if the file already existed (so we can notify about overwriting)
    file_existed = file_exists_in_maps_dir(filename)

    # Build the map data from the given scenery/player
    map_data = map_io_main.build_map_data(
        placed_scenery,
        player=player,
        world_width=world_width,
        world_height=world_height
    )

    # Actually write the map data to disk
    save_map_file(f"maps/{filename}", map_data)

    # If we overwrote an existing file and want a brief pause:
    if file_existed and notify_overwrite:
        curses.napms(0)


def _restore_input_mode(stdscr):
    """
    Helper to restore no-echo, no-delay mode after user input.
    """
    curses.noecho()
    curses.curs_set(0)
    curses.napms(50)
    curses.flushinp()
    stdscr.nodelay(True)


# FileName: curses_scene_settings.py
#
# version: 1.0
#
# Summary: Defines the "Settings" scene, with its own while-True loop for user input.
#
# Tags: scene, settings

import curses
import debug
from .curses_common import draw_screen_frame, draw_title, draw_instructions

def settings_scene_ui (stdscr):
    """
    A placeholder 'Settings' screen. Press 'q' or ESC to return to the main menu.
    """
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)

    while True:
        stdscr.erase()
        draw_screen_frame(stdscr)
        draw_title(stdscr, "Settings (Placeholder)", row=1)

        info_lines = [
            "Here is where you might configure volume, video settings, etc.",
            "Press 'q' or ESC to go back..."
        ]
        draw_instructions(stdscr, info_lines, from_bottom=2)

        stdscr.refresh()

        key = stdscr.getch()
        if key in (ord('q'), ord('Q'), 27):
            # 'q' or ESC => exit settings
            return
        elif key == ord('v'):
            debug.toggle_debug()



# FileName: curses_utils.py
#
# version: 1.1
#
# Summary: Provides safe curses output helpers and color attribute assembly.
#
# Tags: curses, utils

import curses
from typing import Optional
from .curses_color_init import color_pairs

def get_color_attr(color_name: str, bold: bool = False, blink: bool = False, underline: bool = False) -> int:
    """
    Given a color name like "white_on_black", returns a curses attribute
    including optional BOLD/BLINK/UNDERLINE bits.
    """
    pair_id = color_pairs.get(color_name, 0)
    attr = curses.color_pair(pair_id)
    if bold:
        attr |= curses.A_BOLD
    if blink:
        attr |= curses.A_BLINK
    if underline:
        attr |= curses.A_UNDERLINE
    return attr

def parse_two_color_names(fg_bg: str) -> (str, str):
    """
    Splits a string like "white_on_blue" into ("white","blue").
    If invalid, returns ("white","black").
    """
    parts = fg_bg.split("_on_")
    if len(parts) == 2:
        return parts[0], parts[1]
    return ("white", "black")

def _clip_coords_for_borders(row: int, col: int, max_h: int, max_w: int) -> (int, int):
    if row < 1 or row > (max_h - 2):
        return (-1, -1)
    if col < 1:
        col = 1
    if col > (max_w - 2):
        return (-1, -1)
    return (row, col)

def _truncate_for_borders_text(col: int, text: str, max_w: int) -> str:
    available_width = (max_w - 2) - col + 1
    if available_width < 1:
        return ""
    return text[:available_width]

def safe_addstr(stdscr: curses.window, row: int, col: int, text: str, attr: int, clip_borders: bool = True) -> None:
    """
    Safely add a string at (row, col), optionally clipping to a border if clip_borders=True.
    """
    max_h, max_w = stdscr.getmaxyx()

    if clip_borders:
        row2, col2 = _clip_coords_for_borders(row, col, max_h, max_w)
        if row2 < 0 or col2 < 0:
            return
        text = _truncate_for_borders_text(col2, text, max_w)
        if not text:
            return
        row, col = row2, col2
    else:
        if row < 0 or row >= max_h:
            return
        if col < 0 or col >= max_w:
            return
        available_width = max_w - col
        if available_width < 1:
            return
        text = text[:available_width]

    try:
        stdscr.addstr(row, col, text, attr)
    except curses.error:
        pass

def safe_addch(stdscr: curses.window, row: int, col: int, ch, attr: int, clip_borders: bool = True) -> None:
    """
    Safely add a single character at (row, col).
    """
    max_h, max_w = stdscr.getmaxyx()

    if clip_borders:
        row2, col2 = _clip_coords_for_borders(row, col, max_h, max_w)
        if row2 < 0 or col2 < 0:
            return
        row, col = row2, col2
    else:
        if row < 0 or row >= max_h:
            return
        if col < 0 or col >= max_w:
            return

    try:
        stdscr.addch(row, col, ch, attr)
    except curses.error:
        pass

