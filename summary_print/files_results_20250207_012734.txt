
# FileName: __init__.py
#
# version: 1.0
#
# Summary: Marks this directory as a Python package for curses-based front-end.
#
# Tags: package, curses

"""
Package for all curses-based front-end modules:
 - curses_input
 - curses_renderer
 - curses_menus
 - curses_map_ui
 - curses_common (shared drawing helpers)
 - curses_animations
 - curses_highlight
 - curses_art_skins
 - curses_utils
 - curses_color_init
"""


# FileName: curses_animations.py
#
# version: 2.2
#
# Summary: Houses drawing routines for sprite/scene animations (ASCII art, borders), with no permanent loops or direct user input logic.
#
# Tags: animation, drawing, curses

import curses
import debug
from .curses_utils import safe_addstr, safe_addch, get_color_attr
from .curses_common import draw_screen_frame, _draw_art
from .where_curses_themes_lives import CURRENT_THEME  # Newly added for default color usage


def draw_subtle_art_frame(stdscr, art_lines, offset_x, start_row=3, start_col=2, color_name=None):
    """
    Draw one 'frame' of the ASCII art shifted horizontally by offset_x.
    If color_name is None, we use CURRENT_THEME's 'ascii_art_color'.
    """
    if color_name is None:
        color_name = CURRENT_THEME["ascii_art_color"]
    _draw_art(stdscr, art_lines, start_row=start_row, start_col=start_col + offset_x, color_name=color_name)



# FileName: curses_color_init.py
#
# version: 3.3
#
# Summary: Initializes curses color pairs. Skips invalid indexes if terminal supports fewer colors.
#
# Tags: colors, curses, setup

import curses

# The standard 8 curses colors mapped to friendly names:
BASE_COLORS = {
    "black":   curses.COLOR_BLACK,
    "red":     curses.COLOR_RED,
    "green":   curses.COLOR_GREEN,
    "yellow":  curses.COLOR_YELLOW,
    "blue":    curses.COLOR_BLUE,
    "magenta": curses.COLOR_MAGENTA,
    "cyan":    curses.COLOR_CYAN,
    "white":   curses.COLOR_WHITE,
}

# Extended color indexes for e.g. light_gray, dark_gray, etc.
EXTENDED_COLORS = {
    "light_gray": 8,
    "dark_gray":  9,
    # Could add more if terminal supports it.
}

def define_extended_colors():
    """Attempt to initialize extra colors if the terminal supports color redefinition."""
    if not curses.can_change_color():
        return
    # light_gray => ~70% white
    curses.init_color(8, 700, 700, 700)
    # dark_gray  => ~30% white
    curses.init_color(9, 300, 300, 300)

color_pairs = {}

def init_colors():
    curses.start_color()
    curses.use_default_colors()

    # Attempt to define extended colors if supported
    define_extended_colors()

    # Merge base + extended colors
    all_colors = dict(BASE_COLORS)
    all_colors.update(EXTENDED_COLORS)

    pair_index = 1
    for fg_name, fg_val in all_colors.items():
        for bg_name, bg_val in all_colors.items():
            if fg_val < curses.COLORS and bg_val < curses.COLORS:
                pair_name = f"{fg_name}_on_{bg_name}"
                curses.init_pair(pair_index, fg_val, bg_val)
                color_pairs[pair_name] = pair_index
                pair_index += 1

    # Removed alias mapping in favor of a standardized naming system.


# File: curses_common.py
# version: 2.10
#
# Summary: Provides functions and helpers for drawing frames, labels, etc. in curses.
#          Now ensures that nothing is drawn outside of the frame.
#
# Tags: ui, rendering, curses

import curses
import tools.debug as debug
from .curses_utils import safe_addstr, safe_addch, get_color_attr
from .where_curses_themes_lives import CURRENT_THEME  # Newly added for default color usage

def _draw_art(stdscr, art_lines, start_row=1, start_col=2, color_name=None):
    """
    Renders 'art_lines' at (start_row, start_col), using a specified color_name.
    If color_name is None, we use CURRENT_THEME's 'ascii_art_color'.
    Safe for static or single-frame usage.
    """
    if color_name is None:
        color_name = CURRENT_THEME["ascii_art_color"]

    attr = get_color_attr(color_name)
    max_h, max_w = stdscr.getmaxyx()
    row = start_row
    for line in art_lines:
        if row >= max_h - 1:
            break
        safe_addstr(stdscr, row, start_col, line, attr, clip_borders=True)
        row += 1

def draw_title(stdscr: curses.window, text: str, row: int = 1, color_name: str = None) -> None:
    """
    Draw a title string at the given row. If color_name is not provided,
    use CURRENT_THEME's 'title_color'.
    """
    if color_name is None:
        color_name = CURRENT_THEME["title_color"]

    max_h, max_w = stdscr.getmaxyx()
    if row < 0 or row >= max_h:
        return
    col = 2
    attr = get_color_attr(color_name, bold=True)
    safe_addstr(stdscr, row, col, text, attr, clip_borders=True)

def draw_instructions(stdscr: curses.window, lines: list[str], from_bottom: int = 2, color_name: str = None) -> None:
    """
    Draws a list of instruction lines near the bottom of the screen. 
    If color_name not provided, use CURRENT_THEME's 'instructions_color'.
    """
    if color_name is None:
        color_name = CURRENT_THEME["instructions_color"]

    h, w = stdscr.getmaxyx()
    attr = get_color_attr(color_name)

    start_row = h - from_bottom - len(lines)
    if start_row < 1:
        start_row = 1

    row = start_row
    for line in lines:
        if row >= h - 1:
            break
        safe_addstr(stdscr, row, 2, line, attr, clip_borders=True)
        row += 1

def draw_screen_frame(stdscr: curses.window, color_name: str = None) -> None:
    """
    Draws a rectangular border around the entire screen, plus a "Debug mode" label if debug is enabled.
    If color_name not provided, use CURRENT_THEME's 'border_color'.
    """
    if color_name is None:
        color_name = CURRENT_THEME["border_color"]

    h, w = stdscr.getmaxyx()
    border_attr = get_color_attr(color_name)

    # Top line
    for x in range(w):
        safe_addch(stdscr, 0, x, curses.ACS_HLINE, border_attr, clip_borders=False)
    safe_addch(stdscr, 0, 0, curses.ACS_ULCORNER, border_attr, clip_borders=False)
    safe_addch(stdscr, 0, w - 1, curses.ACS_URCORNER, border_attr, clip_borders=False)

    # Bottom line
    for x in range(w):
        safe_addch(stdscr, h - 1, x, curses.ACS_HLINE, border_attr, clip_borders=False)
    safe_addch(stdscr, h - 1, 0, curses.ACS_LLCORNER, border_attr, clip_borders=False)
    safe_addch(stdscr, h - 1, w - 1, curses.ACS_LRCORNER, border_attr, clip_borders=False)

    # Left/right
    for y in range(1, h - 1):
        safe_addch(stdscr, y, 0, curses.ACS_VLINE, border_attr, clip_borders=False)
        safe_addch(stdscr, y, w - 1, curses.ACS_VLINE, border_attr, clip_borders=False)

    # Debug label
    if debug.DEBUG_CONFIG["enabled"]:
        label = "Debug mode: On"
        col = w - len(label) - 6
        dbg_attr = get_color_attr("white_on_black")
        safe_addstr(stdscr, 0, col, label, dbg_attr, clip_borders=False)

def draw_text(stdscr: curses.window, row: int, col: int, text: str,
              fg: str = "white", bg: str = "black",
              bold: bool = False, underline: bool = False) -> None:
    """
    Draw text at (row, col) with direct FG_on_BG approach.
    """
    pair_name = f"{fg}_on_{bg}"
    attr = get_color_attr(pair_name, bold=bold, underline=underline)
    safe_addstr(stdscr, row, col, text, attr, clip_borders=True)

def draw_inside_frame_ch(stdscr: curses.window, y: int, x: int, ch: str, attr) -> None:
    """
    Draws a single character inside the frame boundaries.
    Only draws if (y, x) is inside the frame (i.e., between the border lines).
    """
    max_h, max_w = stdscr.getmaxyx()
    if 1 <= y < max_h - 1 and 1 <= x < max_w - 1:
        safe_addch(stdscr, y, x, ch, attr, clip_borders=True)


# File: curses_effect_layers.py
# version: 1.2
#
# Summary:
#   Provides plugin layer classes for dynamic weather effects: Snow and Rain.
#   These layers now use drawing helpers to prevent drawing outside of the frame.
#
# Tags: effects, snow, rain, scene, plugin

import curses
import random
from .scene_layer_base import SceneLayer
from .curses_utils import get_color_attr
from .curses_common import draw_inside_frame_ch  # New helper to enforce in-frame drawing

class SnowEffectLayer(SceneLayer):
    def __init__(self, num_flakes=50, color_name="white_on_black"):
        # Set a high z_index so the snow appears on top of all other layers.
        super().__init__(name="snow_effect", z_index=300)
        self.num_flakes = num_flakes
        self.color_name = color_name
        self.snowflakes = []
        self.initialized = False
        self.last_w = None
        self.last_h = None

    def _initialize_snowflakes(self, max_w, max_h):
        self.snowflakes = []
        for _ in range(self.num_flakes):
            # Ensure the snowflake is drawn inside the frame.
            x = random.randint(1, max_w - 2)
            y = random.randint(1, max_h - 2)
            self.snowflakes.append({"x": x, "y": y})
        self.last_w = max_w
        self.last_h = max_h
        self.initialized = True

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        max_h, max_w = stdscr.getmaxyx()
        # Reinitialize if the screen size has changed or if not yet initialized.
        if (not self.initialized) or (max_w != self.last_w or max_h != self.last_h):
            self._initialize_snowflakes(max_w, max_h)
        # Update snowflake positions every 100 frames.
        if dt % 100 == 0:
            for flake in self.snowflakes:
                flake["y"] += 1
                if flake["y"] >= max_h - 1:
                    flake["y"] = 1
                    flake["x"] = random.randint(1, max_w - 2)
        attr = get_color_attr(self.color_name)
        for flake in self.snowflakes:
            ch = random.choice(['*', '.'])
            draw_inside_frame_ch(stdscr, flake["y"], flake["x"], ch, attr)

class RainEffectLayer(SceneLayer):
    def __init__(self, num_drops=50, color_name="blue_on_black", direction="down"):
        # Use a high z_index so rain appears above other layers.
        super().__init__(name="rain_effect", z_index=300)
        self.num_drops = num_drops
        self.color_name = color_name
        self.direction = direction.lower()  # Accept "down", "left", or "right"
        self.raindrops = []
        self.initialized = False
        self.last_w = None
        self.last_h = None

    def _initialize_raindrops(self, max_w, max_h):
        self.raindrops = []
        for _ in range(self.num_drops):
            # Ensure the raindrop is drawn inside the frame.
            x = random.randint(1, max_w - 2)
            y = random.randint(1, max_h - 2)
            self.raindrops.append({"x": x, "y": y})
        self.last_w = max_w
        self.last_h = max_h
        self.initialized = True

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        max_h, max_w = stdscr.getmaxyx()
        # Reinitialize if needed.
        if (not self.initialized) or (max_w != self.last_w or max_h != self.last_h):
            self._initialize_raindrops(max_w, max_h)
        # Update raindrop positions every 100 frames for smoothness.
        if dt % 100 == 0:
            for drop in self.raindrops:
                if self.direction == "down":
                    drop["y"] += 1
                    if drop["y"] >= max_h - 1:
                        drop["y"] = 1
                        drop["x"] = random.randint(1, max_w - 2)
                elif self.direction == "left":
                    drop["x"] -= 1
                    if drop["x"] < 1:
                        drop["x"] = max_w - 2
                        drop["y"] = random.randint(1, max_h - 2)
                elif self.direction == "right":
                    drop["x"] += 1
                    if drop["x"] >= max_w - 1:
                        drop["x"] = 1
                        drop["y"] = random.randint(1, max_h - 2)
        attr = get_color_attr(self.color_name)
        for drop in self.raindrops:
            ch = '|' if self.direction == "down" else '-'
            draw_inside_frame_ch(stdscr, drop["y"], drop["x"], ch, attr)


# FileName: curses_game_renderer.py
# version: 4.2 (modified to delegate inventory display to curses_scene_inventory and to call draw_editor_overlay from curses_scene_editor)
#
# Summary: A curses-based in-game renderer implementing IGameRenderer. Renders only the camera region.
#
# Tags: curses, ui, rendering

import curses
from engine.engine_interfaces import IGameRenderer

from .curses_selector_highlight import get_color_attr
from .curses_utils import safe_addstr
from .curses_common import draw_screen_frame
from .where_curses_themes_lives import CURRENT_THEME

# The tile-drawing logic is in curses_tile_drawing.py
from .curses_tile_drawing import draw_single_tile, draw_player_on_top

# Import the inventory summary drawer
from .curses_scene_inventory import draw_inventory_summary

# Import the editor overlay drawer
from .curses_scene_editor import draw_editor_overlay


class CursesGameRenderer(IGameRenderer):
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.map_top_offset = 3
        self.map_side_offset = 0

        self.stdscr.nodelay(True)
        self.stdscr.keypad(True)
        curses.curs_set(0)

    def get_curses_window(self):
        """
        Provide access to the underlying curses window, in case other logic needs it.
        """
        return self.stdscr

    def get_visible_size(self):
        """
        Overridden to return the actual curses screen size minus any offsets.
        """
        max_h, max_w = self.stdscr.getmaxyx()
        visible_rows = max_h - self.map_top_offset
        if visible_rows < 0:
            visible_rows = 0
        visible_cols = max_w - self.map_side_offset
        return (visible_cols, visible_rows)


    def render_scene(self, scene, dt=0, context=None):
        """
        Renders a Scene object that provides .get_layers().
        :param scene: a Scene instance containing SceneLayer objects.
        :param dt: a frame counter or time delta.
        :param context: the game model or other relevant data.
        """
        self.stdscr.erase()

        # 1) Retrieve layers from the scene.
        layers = scene.get_layers()  # This returns a list of SceneLayer objects.

        # 2) Sort layers by their z_index.
        layers_sorted = sorted(layers, key=lambda layer: layer.z_index)

        # 3) Draw each layer (lowest z_index drawn first).
        for layer in layers_sorted:
            layer.draw(self, dt, context)

        # 4) Refresh the screen.
        self.stdscr.noutrefresh()
        curses.doupdate()

    def _render_layer(self, layer_name, model):
        """
        By default, we only handle 'background' or 'game_world' here.
        """
        if layer_name == "background":
            border_col = CURRENT_THEME["border_color"]
            draw_screen_frame(self.stdscr, border_col)
        elif layer_name == "game_world":
            if model:
                self._full_redraw(model)

    def render(self, model):
        """
        Called each frame to render the current game state, possibly partially.
        """
        dx = getattr(model, "ui_scroll_dx", 0)
        dy = getattr(model, "ui_scroll_dy", 0)

        # If camera moved or a full redraw is requested, do a full update
        if model.full_redraw_needed or dx != 0 or dy != 0:
            self._full_redraw(model)
            model.full_redraw_needed = False
        else:
            self._update_dirty_tiles(model)

        # Reset the scroll deltas
        model.ui_scroll_dx = 0
        model.ui_scroll_dy = 0

        self.stdscr.noutrefresh()
        curses.doupdate()

    def _full_redraw(self, model):
        self.stdscr.clear()
        self._draw_screen_frame()

        # New approach: delegate the editor overlay to curses_scene_editor,
        # and if it's not in editor mode, show inventory summary
        draw_editor_overlay(self.stdscr, model)
        if not (model.context.enable_editor_commands and model.editor_scenery_list):
            draw_inventory_summary(self.stdscr, model, row=1, col=2)

        max_h, max_w = self.stdscr.getmaxyx()
        visible_cols = max_w
        visible_rows = max_h - self.map_top_offset

        # Mark every tile in the visible region as dirty
        for wx in range(model.camera_x, model.camera_x + visible_cols):
            for wy in range(model.camera_y, model.camera_y + visible_rows):
                model.dirty_tiles.add((wx, wy))

        self._update_dirty_tiles(model)

    def _update_dirty_tiles(self, model):
        """
        Re-draw only the tiles in model.dirty_tiles, then draw the player on top.
        """
        max_h, max_w = self.stdscr.getmaxyx()
        blank_attr = get_color_attr("white_on_black")

        for (wx, wy) in model.dirty_tiles:
            sx = wx - model.camera_x
            sy = wy - model.camera_y + self.map_top_offset
            if 0 <= sx < max_w and 0 <= sy < max_h:
                # Paint this tile
                draw_single_tile(self.stdscr, wx, wy, sx, sy, model, blank_attr)

        # After drawing all tiles, draw the player on top
        draw_player_on_top(self.stdscr, model, self.map_top_offset)

    def _draw_screen_frame(self):
        draw_screen_frame(self.stdscr)

    def _draw_text(self, row, col, text, color_name=None, bold=False, underline=False):
        if color_name is None:
            color_name = CURRENT_THEME["text_color"]
        attr = get_color_attr(color_name, bold=bold, underline=underline)
        safe_addstr(self.stdscr, row, col, text, attr, clip_borders=True)


# File: curses_menu_flow_manager.py
# version: 4.8
#
# Summary:
#   High-level MenuFlowManager for main menu screens (HOME, SETTINGS, PLAY).
#   Uses plugin-based scenes. Global effect layers (e.g. snow and rain) are applied
#   automatically to every scene via the base Scene class.
#
#   Transitions between scenes are now completely controlled by curses_scene_transition.py.
#   The menu flow manager simply calls run_transition() with the current and next scenes.
#
#   This update adds a transition between the LoadScene and the GameScene (the actual map).
#
# Tags: scene, menu, manager, transition

import time
import curses
from .curses_color_init import init_colors

# Import plugin-based scene classes
from .curses_scene_home import HomeScene
from .curses_scene_settings import SettingsScene
from .curses_scene_load import LoadScene
from .curses_scene_game import GameScene

# Import the transition helper from curses_scene_transition.py
from .curses_scene_transition import run_transition

# Import dedicated save logic
from .curses_scene_save import handle_post_game_scene_save

from map_system.map_model_builder import build_model_common
from map_system.mapgen.map_generator_pipeline import create_procedural_model

# Import the renderer for scenes
from .curses_game_renderer import CursesGameRenderer

# Import global effects manager and effect layers (aggregated in one place)
from .global_effects_manager import add_effect_layer
from .curses_effect_layers import SnowEffectLayer, RainEffectLayer

class MenuFlowManager:
    """
    Manages the main menu screens (HOME, SETTINGS, PLAY).
    Global effect layers are automatically applied to every scene.
    Transitions between scenes are now set solely by curses_scene_transition.py.
    """
    def __init__(self, stdscr):
        self.stdscr = stdscr
        init_colors()
        self.current_state = "HOME"
        self.running = True

        # Add global effect layers once.
        add_effect_layer(SnowEffectLayer(num_flakes=10, color_name="white_on_black"))
        add_effect_layer(RainEffectLayer(num_drops=10, color_name="blue_on_black", direction="down"))

    def run_scene(self, scene):
        """
        Render the given scene in a loop until it returns a menu choice.
        """
        renderer = CursesGameRenderer(self.stdscr)
        dt = 0
        while True:
            renderer.render_scene(scene, dt=dt, context=None)
            dt += 1
            key = self.stdscr.getch()
            if key != -1:
                choice = scene.handle_input(key)
                if choice is not None:
                    return choice

    def run_transition(self, current_scene, next_scene):
        """
        Calls the global run_transition() helper from curses_scene_transition.py.
        This helper reads all transition parameters from TRANSITION_CONFIG.
        """
        run_transition(self.stdscr, current_scene, next_scene)

    def run(self):
        while self.running:
            if self.current_state == "HOME":
                # Use the plugin-based HomeScene.
                home_scene = HomeScene()
                user_choice = self.run_scene(home_scene)
                if user_choice == 1:  # Play selected
                    load_scene = LoadScene()
                    self.run_transition(home_scene, load_scene)
                    self.current_state = "PLAY"
                elif user_choice == 2:  # Quit selected
                    self.current_state = "QUIT"
                elif user_choice == 3:  # Settings selected
                    settings_scene = SettingsScene()
                    self.run_transition(home_scene, settings_scene)
                    _ = self.run_scene(settings_scene)
                    self.run_transition(settings_scene, home_scene)
                    self.current_state = "HOME"
            elif self.current_state == "PLAY":
                load_scene = LoadScene()
                selection = self.run_scene(load_scene)
                if not selection:
                    # User canceled map selection; transition from LoadScene to HomeScene.
                    self.run_transition(load_scene, HomeScene())
                    self.current_state = "HOME"
                    continue

                # For any valid selection (GENERATE, dict, or string),
                # create the GameScene and transition from the LoadScene into it.
                if selection == "GENERATE":
                    model, context = create_procedural_model()
                    if not model:
                        self.current_state = "HOME"
                        continue
                    game_scene = GameScene(model, context)
                    self.run_transition(load_scene, game_scene)
                    _ = game_scene.run(self.stdscr)
                    handle_post_game_scene_save(self.stdscr, model)
                    continue

                if isinstance(selection, dict):
                    model, context = build_model_common(selection, is_generated=True, mode_name="play")
                    if not model:
                        self.current_state = "HOME"
                        continue
                    game_scene = GameScene(model, context)
                    self.run_transition(load_scene, game_scene)
                    _ = game_scene.run(self.stdscr)
                    handle_post_game_scene_save(self.stdscr, model)
                    continue

                if isinstance(selection, str):
                    model, context = build_model_common(selection, is_generated=False, mode_name="play")
                    if not model:
                        self.current_state = "HOME"
                        continue
                    game_scene = GameScene(model, context)
                    self.run_transition(load_scene, game_scene)
                    _ = game_scene.run(self.stdscr)
                    handle_post_game_scene_save(self.stdscr, model)
            # The dedicated SETTINGS branch has been removed to avoid duplicate transitions.
            elif self.current_state == "QUIT":
                self.running = False

# Legacy functions (such as home_scene_ui, load_scene_ui, game_scene_ui) have been commented out.


# File: curses_scene_editor.py
# version: 1.0
#
# Summary: Renders an overlay at the top of the screen when the editor is active,
#          showing the currently selected scenery item and minimal controls.
#
# Tags: editor, overlay, ui

import curses
from .curses_utils import safe_addstr, get_color_attr
from .where_curses_themes_lives import CURRENT_THEME

def draw_editor_overlay(stdscr, model):
    """
    Draw a small overlay at the top if the editor is active,
    showing the currently selected item and short controls help.
    """
    if not model or not model.context.enable_editor_commands:
        return
    editor_list = model.editor_scenery_list
    idx = model.editor_scenery_index
    if not editor_list or idx < 0 or idx >= len(editor_list):
        return
    current_def_id = editor_list[idx][0]
    overlay_text = (
        f"[EDITOR MODE] Selected: {current_def_id}  "
        "(p=place, x=remove top, l=next, k=prev, u=undo, e=exit editor)"
    )
    overlay_color = CURRENT_THEME["text_color"]
    overlay_attr = get_color_attr(overlay_color)
    max_h, max_w = stdscr.getmaxyx()
    row = 1
    col = 2
    blank_line = " " * (max_w - 4)
    safe_addstr(stdscr, row, 1, blank_line, overlay_attr, clip_borders=False)
    safe_addstr(stdscr, row, col, overlay_text, overlay_attr, clip_borders=False)


# File: curses_scene_game.py
# version: 2.0 (refactored to plugin architecture)
#
# Summary:
#   Defines a GameScene that encapsulates the game loop.
#   This scene sets up the curses‐based input and rendering,
#   and then calls run_game_loop from engine_main.
#
#   Note: Because the existing run_game_loop is a blocking call,
#         the integration is not fully “non‑blocking” yet.
#         In the future you might refactor engine_main.py to split updates
#         and rendering into per‑frame steps.
#
# Tags: scene, game

import curses
from .scene_base import Scene
from .scene_layer_base import SceneLayer
from .curses_game_renderer import CursesGameRenderer
from .where_curses_input_is_handled import CursesGameInput
from engine.engine_main import run_game_loop

class GameBackgroundLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="game_background", z_index=0)
    
    def draw(self, renderer, dt, context):
        # Optionally add extra background effects here.
        # For now, we leave this empty because run_game_loop handles full
        # drawing of the game world.
        pass

class GameOverlayLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="game_overlay", z_index=100)
    
    def draw(self, renderer, dt, context):
        # Here you could add HUD elements, inventory displays, or an editor overlay.
        # For example, you might call a function such as:
        #   from .curses_scene_inventory import draw_inventory_summary
        #   draw_inventory_summary(renderer.stdscr, context, row=1, col=2)
        pass

class GameScene(Scene):
    def __init__(self, model, context):
        super().__init__()
        self.model = model
        self.context = context
        # Setup plugin layers (for future use) if you want to draw additional overlays.
        self.background_layer = GameBackgroundLayer()
        self.overlay_layer = GameOverlayLayer()
        self.layers = [self.background_layer, self.overlay_layer]
    
    def run(self, stdscr):
        """
        Run the game scene. This method sets up input and rendering,
        then calls the main game loop. (Currently, run_game_loop is blocking.)
        """
        # Setup the input and renderer as usual
        game_input = CursesGameInput(stdscr)
        game_renderer = CursesGameRenderer(stdscr)
        
        # (Optionally, before entering the game loop, you could draw your plugin layers.
        #  For example, you might call:
        #      for layer in self.get_layers():
        #          layer.draw(game_renderer, dt=0, context=self.context)
        #  so that any static overlays are drawn.)
        
        # Delegate to the existing game loop.
        # In the future, you might refactor run_game_loop to a per-frame update,
        # and then call update() and render() methods on your GameScene instance.
        run_game_loop(self.model, self.context, game_input, game_renderer)
        
        # After the game loop exits, return a value or perform cleanup if needed.
        return "EXIT"

    def handle_input(self, key):
        # This method would be used if you want non-blocking input handling
        # while in the game scene. Since run_game_loop is blocking, this is not used.
        pass

# Legacy function (deprecated):
#
# def game_scene_ui(stdscr, model, context):
#     game_input = CursesGameInput(stdscr)
#     game_renderer = CursesGameRenderer(stdscr)
#     run_game_loop(model, context, game_input, game_renderer)


# File: curses_scene_home.py
# version: 2.2 (refactored to plugin architecture with separated base background)
#
# Summary:
#   Defines HomeScene, which uses plugin layers for the base background,
#   background art, menu, and title.
#
# Tags: scene, home, menu

import curses
import tools.debug as debug
from .scene_base import Scene
from .scene_layer_base import SceneLayer
from .curses_common import draw_screen_frame, draw_title, _draw_art
from .curses_selector_highlight import draw_global_selector_line
from .where_curses_themes_lives import CURRENT_THEME

class HomeBaseLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="home_base", z_index=0)
    
    def draw(self, renderer, dt, context):
        # Clear the screen or fill with a base color.
        stdscr = renderer.stdscr
        stdscr.erase()
        # Optionally, set a background fill:
        # stdscr.bkgd(' ', curses.color_pair(0))

class HomeBackgroundLayer(SceneLayer):
    def __init__(self):
        # Background art layer above the base.
        super().__init__(name="home_background", z_index=100)

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        draw_screen_frame(stdscr)
        # Legacy: Removed drawing the title here.
        # draw_title(stdscr, "Welcome to Retro RPG!", row=1)
        main_menu_lines = CURRENT_THEME.get("main_menu_art", [])
        _draw_art(stdscr, main_menu_lines, start_row=3, start_col=2)

class HomeTitleLayer(SceneLayer):
    def __init__(self):
        # Title layer drawn on top.
        super().__init__(name="home_title", z_index=500)

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        draw_title(stdscr, "Welcome to Retro RPG!", row=1)

class HomeMenuLayer(SceneLayer):
    def __init__(self):
        # Menu layer (drawn above background art but below the title).
        super().__init__(name="home_menu", z_index=400)
        self.menu_lines = [
            "~~~~~~~~~",
            "1) Play",
            "2) Quit",
            "3) Settings",
            "~~~~~~~~~"
        ]
        self.current_select_slot = 0  # index into selectable menu items

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        max_h, max_w = stdscr.getmaxyx()
        from_bottom = 2
        start_row = max_h - from_bottom - len(self.menu_lines)
        if start_row < 1:
            start_row = 1

        row = start_row
        selectable_indices = [1, 2, 3]  # assume lines 1-3 (after the decorative line) are selectable
        for i, line_text in enumerate(self.menu_lines):
            is_selected = False
            if i in selectable_indices:
                sel_index = selectable_indices.index(i)
                if sel_index == self.current_select_slot:
                    is_selected = True
            draw_global_selector_line(
                stdscr, row, line_text,
                is_selected=is_selected,
                frame=dt  # use dt as frame count for animation
            )
            row += 1

    def move_selection_up(self):
        self.current_select_slot = max(0, self.current_select_slot - 1)

    def move_selection_down(self):
        self.current_select_slot = min(2, self.current_select_slot + 1)  # for 3 choices

    def get_current_choice(self):
        if self.current_select_slot == 0:
            return 1  # "Play"
        elif self.current_select_slot == 1:
            return 2  # "Quit"
        else:
            return 3  # "Settings"

class HomeScene(Scene):
    def __init__(self):
        super().__init__()
        self.base_layer = HomeBaseLayer()
        self.bg_layer = HomeBackgroundLayer()
        self.menu_layer = HomeMenuLayer()
        self.title_layer = HomeTitleLayer()
        # Layer order:
        # 1. Base background (z_index 0)
        # 2. Background art (z_index 100)
        # 3. Global effects (z_index 300, added via the global_effects_manager)
        # 4. Menu (z_index 400)
        # 5. Title (z_index 500)
        self.layers = [self.base_layer, self.bg_layer, self.menu_layer, self.title_layer]

    def handle_input(self, key):
        if key in (ord('v'), ord('V')):
            debug.toggle_debug()
        if key in (curses.KEY_UP, ord('w'), ord('W')):
            self.menu_layer.move_selection_up()
        elif key in (curses.KEY_DOWN, ord('s'), ord ('S')):
            self.menu_layer.move_selection_down()
        elif key in (curses.KEY_ENTER, 10, 13, 32):
            return self.menu_layer.get_current_choice()
        elif key == ord('1'):
            return 1
        elif key == ord('2'):
            return 2
        elif key == ord('3'):
            return 3
        return None


# FileName: curses_scene_inventory.py
# version: 1.1 (added draw_inventory_summary to unify inventory display)
#
# Summary: Dedicated screen to display the player's inventory (full) 
#          or a short summary of the player's inventory if needed.
#
# Tags: curses, ui, inventory

import curses
from .curses_common import draw_screen_frame, draw_title, draw_instructions
from .curses_utils import safe_addstr, get_color_attr
from .where_curses_themes_lives import CURRENT_THEME


def draw_inventory_summary(stdscr, model, row=1, col=2):
    """
    Draws a single-line summary of the player's inventory. 
    Called by the main renderer when not in editor mode.
    """
    text_color = CURRENT_THEME["text_color"]
    text_attr = get_color_attr(text_color)

    inv_text = (
        f"Inventory: Gold={model.player.gold}, "
        f"Wood={model.player.wood}, Stone={model.player.stone}"
    )

    safe_addstr(stdscr, row, col, inv_text, text_attr, clip_borders=True)


def show_inventory_screen(stdscr, model):
    """
    Shows the player's current inventory in a separate, blocking screen.
    Waits for any key to be pressed before returning.
    """
    stdscr.clear()
    draw_screen_frame(stdscr)

    # Optional: a title at the top
    draw_title(stdscr, "Inventory", row=1)

    # Build inventory text lines
    inventory_lines = [
        f"  Gold  = {model.player.gold}",
        f"  Wood  = {model.player.wood}",
        f"  Stone = {model.player.stone}"
    ]

    text_color = CURRENT_THEME["text_color"]
    text_attr = get_color_attr(text_color)

    row = 3
    for line in inventory_lines:
        safe_addstr(stdscr, row, 2, line, text_attr, clip_borders=True)
        row += 1

    # Provide consistent instructions near the bottom
    instructions = ["Press any key to return..."]
    draw_instructions(stdscr, instructions, from_bottom=2)

    stdscr.refresh()

    # Wait for a keypress
    stdscr.nodelay(False)
    curses.curs_set(0)
    stdscr.getch()
    stdscr.nodelay(True)


# File: curses_scene_load.py
# version: 2.3
#
# Summary:
#   Defines LoadScene – a plugin‑based scene for loading or generating a map.
#   The scene now uses layered drawing:
#       - Base background (lowest) for clearing/filling the screen.
#       - Background art (frame and theme art) above the base.
#       - Global rain effect (z_index=300, from global_effects_manager)
#       - Map list (z_index=400)
#       - Header (title and instructions, z_index=500)
#
# Tags: map, load, scene

import curses
import tools.debug as debug
from .scene_base import Scene
from .scene_layer_base import SceneLayer
from .curses_common import draw_screen_frame, draw_title, draw_instructions, _draw_art
from .where_curses_themes_lives import CURRENT_THEME
from .curses_utils import safe_addstr, get_color_attr
from .curses_selector_highlight import draw_global_selector_line

from map_system.map_list_logic import get_map_list, delete_map_file

def _restore_input_mode(stdscr):
    curses.noecho()
    curses.curs_set(0)
    curses.napms(50)
    curses.flushinp()
    stdscr.nodelay(True)

def prompt_delete_confirmation(stdscr, filename):
    max_h, max_w = stdscr.getmaxyx()
    question = f"Delete '{filename}'? (y/n)"
    attr = get_color_attr(CURRENT_THEME["confirmation_color"])

    row = max_h - 2
    blank_line = " " * (max_w - 4)
    safe_addstr(stdscr, row, 2, blank_line, attr, clip_borders=False)
    safe_addstr(stdscr, row, 2, question, attr, clip_borders=False)
    stdscr.refresh()

    stdscr.nodelay(False)
    curses.curs_set(1)
    curses.echo()

    while True:
        c = stdscr.getch()
        if c in (ord('y'), ord('Y')):
            _restore_input_mode(stdscr)
            return True
        elif c in (ord('n'), ord('N'), ord('q'), 27):
            _restore_input_mode(stdscr)
            return False

def _draw_load_background_art(stdscr):
    stdscr.keypad(True)
    curses.curs_set(0)
    draw_screen_frame(stdscr)
    crocodile_lines = CURRENT_THEME.get("crocodile_art", [])
    _draw_art(stdscr, crocodile_lines, start_row=3, start_col=2)

class LoadBaseLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="load_base", z_index=0)
      
    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        # Clear the screen (base background)
        stdscr.erase()

class LoadBackgroundLayer(SceneLayer):
    def __init__(self):
        # Background art layer above the base.
        super().__init__(name="load_background", z_index=100)
      
    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        _draw_load_background_art(stdscr)

class LoadHeaderLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="load_header", z_index=500)
      
    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        draw_title(stdscr, "Load Map", row=1)
        instructions = [
            "↑/↓ = select, ENTER = load, 'd' = del, 'q' = back, 'v' = dbg"
        ]
        draw_instructions(stdscr, instructions, from_bottom=3)

class LoadMenuLayer(SceneLayer):
    def __init__(self):
        # Map list layer.
        super().__init__(name="load_menu", z_index=400)
        self.options = ["Generate a new map"]
        # Now uses the default maps directory defined in map_list_logic.py
        maps = get_map_list(extension=".json")
        self.options.extend(maps)
        self.current_index = 0
        self.frame_count = 0

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        max_h, max_w = stdscr.getmaxyx()
        row = 10  # Start drawing the options at row 10.
        for i, option in enumerate(self.options):
            display_text = option if i == 0 else f"{i}) {option}"
            is_selected = (i == self.current_index)
            draw_global_selector_line(
                stdscr,
                row,
                f"> {display_text}" if is_selected else f"  {display_text}",
                is_selected=is_selected,
                frame=self.frame_count
            )
            row += 1
        self.frame_count += 1

    def handle_key(self, key, stdscr):
        if key in (curses.KEY_UP, ord('w'), ord('W')):
            self.current_index = max(0, self.current_index - 1)
        elif key in (curses.KEY_DOWN, ord('s'), ord('S')):
            self.current_index = min(len(self.options) - 1, self.current_index + 1)
        elif key in (curses.KEY_ENTER, 10, 13, 32):
            if self.current_index == 0:
                return "GENERATE"
            else:
                return self.options[self.current_index]
        elif key in (ord('q'), ord('Q'), 27):
            return ""  # Cancel and return to main menu.
        elif key in (ord('v'), ord('V')):
            debug.toggle_debug()
        elif key in (ord('d'), ord('D')):
            if self.current_index > 0:
                to_delete = self.options[self.current_index]
                confirm = prompt_delete_confirmation(stdscr, to_delete)
                if confirm:
                    success = delete_map_file(to_delete)
                    if success:
                        del self.options[self.current_index]
                        if self.current_index >= len(self.options):
                            self.current_index = len(self.options) - 1
        elif ord('0') <= key <= ord('9'):
            typed = key - ord('0')
            if 0 <= typed < len(self.options):
                self.current_index = typed
        return None

class LoadScene(Scene):
    def __init__(self):
        super().__init__()
        self.base_layer = LoadBaseLayer()
        self.bg_layer = LoadBackgroundLayer()
        self.menu_layer = LoadMenuLayer()
        self.header_layer = LoadHeaderLayer()
        # Layer order:
        # 1. Base background (z_index 0)
        # 2. Background art (z_index 100)
        # 3. Global rain effect (z_index 300, from global_effects_manager)
        # 4. Map list (z_index 400)
        # 5. Header (z_index 500)
        self.layers = [self.base_layer, self.bg_layer, self.menu_layer, self.header_layer]

    def handle_input(self, key):
        stdscr = self._get_stdscr()
        result = self.menu_layer.handle_key(key, stdscr)
        if result is not None:
            return result
        return None

    def _get_stdscr(self):
        return curses.initscr()


# File: curses_scene_save.py
# version: 2.0
#
# Summary:
#   Contains all save‑scene UI flows for picking/creating filenames,
#   prompting for overwrites, and calling the logic to store map data.
#   Now implemented as a plugin‑based scene similar to Home, Load, and Settings.
#
#   Transitions are no longer handled inside this module; instead, the flow manager
#   handles transitions when returning from the save scene.
#
# Tags: map, save, scene

import curses
import tools.debug as debug
from map_system.map_list_logic import get_map_list
from .curses_utils import safe_addstr, get_color_attr
from .curses_common import draw_screen_frame, draw_title, draw_instructions, _draw_art
from .where_curses_themes_lives import CURRENT_THEME
from map_system.scene_save_logic import (
    save_player_data,
    does_file_exist_in_maps_dir,
    build_and_save_map,
    update_player_coords_in_map
)
from .scene_base import Scene
from .scene_layer_base import SceneLayer
from .curses_game_renderer import CursesGameRenderer

# ---------------------------------------------------------------------
# Plugin Layers for the Save Scene
# ---------------------------------------------------------------------

class SaveBaseLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="save_base", z_index=0)
    def draw(self, renderer, dt, context):
        renderer.stdscr.erase()

class SaveBackgroundLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="save_background", z_index=100)
    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        draw_screen_frame(stdscr)
        crocodile_lines = CURRENT_THEME.get("crocodile_art", [])
        _draw_art(stdscr, crocodile_lines, start_row=3, start_col=2)

class SaveHeaderLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="save_header", z_index=500)
    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        draw_title(stdscr, "Save Map", row=1)
        instructions = ["Select a map to overwrite, 'n' for new, ENTER to cancel, 'v' toggles debug"]
        draw_instructions(stdscr, instructions, from_bottom=3)

class SaveMenuLayer(SceneLayer):
    def __init__(self, files):
        super().__init__(name="save_menu", z_index=400)
        self.files = files
        self.current_index = 0
    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        max_h, max_w = stdscr.getmaxyx()
        row = 10
        attr_prompt = get_color_attr(CURRENT_THEME["prompt_color"])
        attr_menu_item = get_color_attr(CURRENT_THEME["menu_item_color"])
        if self.files:
            safe_addstr(stdscr, row, 2, "Maps (pick number to overwrite) or 'n' for new, or ENTER to cancel:", attr_prompt, clip_borders=True)
            row += 1
            for i, filename in enumerate(self.files, start=1):
                indicator = ">" if (i-1) == self.current_index else " "
                safe_addstr(stdscr, row, 2, f"{indicator} {i}. {filename}", attr_menu_item, clip_borders=True)
                row += 1
            safe_addstr(stdscr, row, 2, "Enter choice or press ENTER to cancel:", attr_prompt, clip_borders=True)
        else:
            safe_addstr(stdscr, row, 2, "No existing maps. Press 'n' for new, 'v' toggles debug, or ENTER to cancel:", attr_prompt, clip_borders=True)
    def handle_key(self, key):
        if key in (curses.KEY_UP, ord('w'), ord('W')):
            self.current_index = max(0, self.current_index - 1)
        elif key in (curses.KEY_DOWN, ord('s'), ord('S')):
            self.current_index = min(len(self.files) - 1, self.current_index + 1)
        elif key in (curses.KEY_ENTER, 10, 13):
            if self.files:
                return self.files[self.current_index]
            else:
                return ""
        elif key in (ord('n'), ord('N')):
            return "NEW_FILE"
        elif key in (ord('v'), ord('V')):
            debug.toggle_debug()
        elif ord('0') <= key <= ord('9'):
            digit = key - ord('0')
            if 1 <= digit <= len(self.files):
                return self.files[digit - 1]
        return None

class SaveScene(Scene):
    """
    Plugin-based scene for saving maps.
    Returns a filename (string) if an existing file is selected,
    "NEW_FILE" if the user chooses to create a new file,
    or an empty string if cancelled.
    """
    def __init__(self):
        super().__init__()
        files = get_map_list(extension=".json")
        self.base_layer = SaveBaseLayer()
        self.background_layer = SaveBackgroundLayer()
        self.menu_layer = SaveMenuLayer(files)
        self.header_layer = SaveHeaderLayer()
        self.layers = [self.base_layer, self.background_layer, self.menu_layer, self.header_layer]
    def handle_input(self, key):
        result = self.menu_layer.handle_key(key)
        if result is not None:
            return result
        return None

def run_save_scene(stdscr):
    renderer = CursesGameRenderer(stdscr)
    dt = 0
    save_scene = SaveScene()
    while True:
        renderer.render_scene(save_scene, dt=dt, context=None)
        dt += 1
        key = stdscr.getch()
        if key != -1:
            result = save_scene.handle_input(key)
            if result is not None:
                return result

def prompt_for_filename(stdscr, prompt):
    max_h, max_w = stdscr.getmaxyx()
    curses.echo()
    curses.curs_set(1)
    stdscr.nodelay(False)
    row = 10
    if row < max_h - 1:
        attr = get_color_attr(CURRENT_THEME["prompt_color"])
        safe_addstr(stdscr, row, 2, prompt, attr, clip_borders=True)
        stdscr.refresh()
        filename_bytes = stdscr.getstr(row, 2 + len(prompt) + 1, 20)
        _restore_input_mode(stdscr)
        if filename_bytes:
            return filename_bytes.decode('utf-8', errors='ignore').strip()
    _restore_input_mode(stdscr)
    return ""

def _restore_input_mode(stdscr):
    curses.noecho()
    curses.curs_set(0)
    curses.napms(50)
    curses.flushinp()
    stdscr.nodelay(True)

def save_map_ui(stdscr,
                placed_scenery,
                player=None,
                world_width=100,
                world_height=100,
                filename_override=None,
                notify_overwrite=False):
    if filename_override:
        filename = filename_override
    else:
        overwrite_or_new = run_save_scene(stdscr)
        if not overwrite_or_new:
            return
        if overwrite_or_new == "NEW_FILE":
            filename = prompt_for_filename(stdscr, "Enter filename to save as: ")
            if not filename:
                return
            if not filename.endswith(".json"):
                filename += ".json"
        else:
            filename = overwrite_or_new

    file_existed = does_file_exist_in_maps_dir(filename)
    build_and_save_map(filename, placed_scenery, player, world_width, world_height)
    if file_existed and notify_overwrite:
        curses.napms(0)
    # NOTE: Transition from the save scene back to HomeScene is now handled by MenuFlowManager.
    
def handle_post_game_scene_save(stdscr, model):
    """
    Called after the player returns from the game scene.
    Determines whether to save a new map or update an existing one,
    then calls the save UI flow.
    """
    save_player_data(model.player)
    if model.loaded_map_filename is None:
        wants_save = prompt_yes_no_curses(stdscr, "Save new map? (y/n)")
        if wants_save:
            placed_scenery = getattr(model, 'placed_scenery', {})
            w = getattr(model, 'world_width', 100)
            h = getattr(model, 'world_height', 100)
            save_map_ui(
                stdscr,
                placed_scenery=placed_scenery,
                player=model.player,
                world_width=w,
                world_height=h,
                filename_override=None,
                notify_overwrite=False
            )
    else:
        update_player_coords_in_map(model.loaded_map_filename, model.player.x, model.player.y)
        placed_scenery = getattr(model, 'placed_scenery', {})
        w = getattr(model, 'world_width', 100)
        h = getattr(model, 'world_height', 100)
        save_map_ui(
            stdscr,
            placed_scenery=placed_scenery,
            player=model.player,
            world_width=w,
            world_height=h,
            filename_override=model.loaded_map_filename,
            notify_overwrite=False
        )

def prompt_yes_no_curses(stdscr, question):
    max_h, max_w = stdscr.getmaxyx()
    row = max_h - 2
    col = 2
    stdscr.nodelay(False)
    curses.curs_set(1)
    curses.echo(0)
    blank_line = " " * (max_w - 4)
    safe_addstr(stdscr, row, col, blank_line, 0, clip_borders=True)
    stdscr.move(row, col)
    safe_addstr(stdscr, row, col, question, 0, clip_borders=True)
    stdscr.refresh()
    while True:
        c = stdscr.getch()
        if c in (ord('y'), ord('Y')):
            _restore_input_mode(stdscr)
            return True
        else:
            _restore_input_mode(stdscr)
            return False

def perform_quick_save(model, renderer):
    if not renderer:
        return
    if not hasattr(renderer, "get_curses_window"):
        return
    ui_win = renderer.get_curses_window()
    if not ui_win:
        return
    player = model.player
    if model.loaded_map_filename:
        save_map_ui(
            ui_win,
            model.placed_scenery,
            player=player,
            world_width=model.world_width,
            world_height=model.world_height,
            filename_override=model.loaded_map_filename
        )
    else:
        save_map_ui(
            ui_win,
            model.placed_scenery,
            player=player,
            world_width=model.world_width,
            world_height=model.world_height,
            filename_override=None
        )
    model.full_redraw_needed = True

# Legacy (non-plugin) implementations have been commented out.


# File: curses_scene_settings.py
# version: 2.3
#
# Summary:
#   Defines the SettingsScene using plugin layers.
#   The scene now uses layered drawing:
#       - Base background (lowest) for clearing/filling the screen.
#       - Background art (same art setup as LoadScene) above the base.
#       - Global rain effect (z_index=300 from global_effects_manager)
#       - Title and options menu (z_index=500) on top.
#
# Tags: scene, settings

import curses
import tools.debug as debug
from .scene_base import Scene
from .scene_layer_base import SceneLayer
from .curses_common import draw_screen_frame, draw_title, _draw_art, draw_instructions
from .where_curses_themes_lives import CURRENT_THEME

def _draw_settings_background_art(stdscr):
    stdscr.keypad(True)
    curses.curs_set(0)
    draw_screen_frame(stdscr)
    art_lines = CURRENT_THEME.get("crocodile_art", [])
    _draw_art(stdscr, art_lines, start_row=3, start_col=2)

class SettingsBaseLayer(SceneLayer):
    def __init__(self):
        super().__init__(name="settings_base", z_index=0)
    
    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        # Clear the screen (base background)
        stdscr.erase()

class SettingsBackgroundLayer(SceneLayer):
    def __init__(self):
        # Background art layer above base.
        super().__init__(name="settings_background", z_index=100)

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        _draw_settings_background_art(stdscr)
        # Legacy: Removed drawing title here.
        # draw_title(stdscr, "Settings (Placeholder)", row=1)

class SettingsMenuLayer(SceneLayer):
    def __init__(self):
        # Menu layer with title and options, on top.
        super().__init__(name="settings_menu", z_index=500)
        self.menu_lines = [
            "1) Toggle Debug",
            "q) Quit Settings"
        ]
        self.current_select_slot = 0

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        # Draw header (title) at the top.
        draw_title(stdscr, "Settings (Placeholder)", row=1)
        max_h, max_w = stdscr.getmaxyx()
        start_row = 4
        row = start_row
        for i, line in enumerate(self.menu_lines):
            if i == self.current_select_slot:
                stdscr.attron(curses.A_REVERSE)
            stdscr.addstr(row, 2, line)
            if i == self.current_select_slot:
                stdscr.attroff(curses.A_REVERSE)
            row += 1

    def handle_key(self, key):
        if key in (ord('v'), ord('V')):
            debug.toggle_debug()
        if key in (curses.KEY_UP, ord('w')):
            self.current_select_slot = max(0, self.current_select_slot - 1)
        elif key in (curses.KEY_DOWN, ord('s')):
            self.current_select_slot = min(len(self.menu_lines) - 1, self.current_select_slot + 1)
        elif key in (curses.KEY_ENTER, 10, 13, 32):
            if self.current_select_slot == 0:
                debug.toggle_debug()
                return None
            elif self.current_select_slot == 1:
                return "QUIT"
        return None

class SettingsScene(Scene):
    def __init__(self):
        super().__init__()
        self.base_layer = SettingsBaseLayer()
        self.background_layer = SettingsBackgroundLayer()
        self.menu_layer = SettingsMenuLayer()
        # Layer order:
        # 1. Base background (z_index 0)
        # 2. Background art (z_index 100)
        # 3. Global rain effect (z_index 300, from global_effects_manager)
        # 4. Title and menu (z_index 500)
        self.layers = [self.base_layer, self.background_layer, self.menu_layer]

    def handle_input(self, key):
        result = self.menu_layer.handle_key(key)
        if result is not None:
            return result
        if key in (ord('q'), ord('Q'), 27):
            return "QUIT"
        return None


# File: curses_scene_transition.py
# version: 1.1
#
# Summary:
#   Provides a CrossFadeTransitionScene that smoothly blends from one scene to another
#   using an overlaid rain effect. Also contains a helper function (run_transition)
#   that runs the transition based on a centralized configuration (TRANSITION_CONFIG).
#
#   To change the duration, color, dt increment, or even disable transitions,
#   simply modify the TRANSITION_CONFIG dictionary in this file.
#
# Tags: transition, scene, effects, helper

import curses
import random
from .scene_base import Scene
from .scene_layer_base import SceneLayer
from .curses_common import draw_inside_frame_ch
from .curses_utils import get_color_attr

# Global configuration for transitions.
TRANSITION_CONFIG = {
    "enabled": True,             # Set to False to disable transitions.
    "effect": "crossfade",       # Currently, only "crossfade" is implemented.
    "phase1_duration": 150,      # Duration (in dt units) for Phase 1 (rain increases over current scene).
    "phase2_duration": 150,      # Duration for Phase 2 (rain fades over next scene).
    "dt_increment": 10,          # Time increment (dt) per frame.
    "napms": 10,                 # Delay (in ms) between frames.
    "color": "blue_on_black",    # Color for the rain effect.
}

class CrossFadeBackgroundLayer(SceneLayer):
    """
    Renders the background for the transition.
    For dt < phase1_duration, it draws the entire current scene;
    for dt ≥ phase1_duration, it draws the entire next scene.
    """
    def __init__(self, current_scene, next_scene, phase1_duration, phase2_duration):
        super().__init__(name="crossfade_background", z_index=100)
        self.current_scene = current_scene
        self.next_scene = next_scene
        self.phase1_duration = phase1_duration
        self.phase2_duration = phase2_duration

    def draw(self, renderer, dt, context):
        if dt < self.phase1_duration:
            for layer in self.current_scene.layers:
                layer.draw(renderer, dt, context)
        else:
            for layer in self.next_scene.layers:
                layer.draw(renderer, dt, context)

class CrossFadeRainLayer(SceneLayer):
    """
    Overlays a rain effect whose density varies with dt.
    In Phase 1, density increases linearly from 0 to max_drops;
    in Phase 2, density decreases linearly from max_drops to 0.
    """
    def __init__(self, max_drops=100, color_name="blue_on_black", phase1_duration=500, phase2_duration=500):
        super().__init__(name="crossfade_rain", z_index=600)
        self.max_drops = max_drops
        self.color_name = color_name
        self.phase1_duration = phase1_duration
        self.phase2_duration = phase2_duration

    def _generate_raindrops(self, stdscr, num_drops):
        max_h, max_w = stdscr.getmaxyx()
        drops = []
        for _ in range(num_drops):
            # Ensure drops appear inside the frame (avoid drawing over borders).
            x = random.randint(1, max_w - 2)
            y = random.randint(1, max_h - 2)
            drops.append({"x": x, "y": y})
        return drops

    def draw(self, renderer, dt, context):
        stdscr = renderer.stdscr
        if dt < self.phase1_duration:
            density_factor = dt / self.phase1_duration
        else:
            phase2_dt = dt - self.phase1_duration
            density_factor = max(0, 1 - (phase2_dt / self.phase2_duration))
        num_drops = int(self.max_drops * density_factor)
        drops = self._generate_raindrops(stdscr, num_drops)
        attr = get_color_attr(self.color_name)
        for drop in drops:
            try:
                ch = '|'
                draw_inside_frame_ch(stdscr, drop["y"], drop["x"], ch, attr)
            except curses.error:
                pass

class CrossFadeTransitionScene(Scene):
    """
    A scene that performs a cross-fade transition between two scenes using a rain overlay.
    The transition is complete when dt >= (phase1_duration + phase2_duration).
    """
    def __init__(self, current_scene, next_scene, phase_duration=(500, 500)):
        super().__init__()
        self.current_scene = current_scene
        self.next_scene = next_scene
        self.phase1_duration, self.phase2_duration = phase_duration
        self.frame_count = 0  # Updated externally via run_transition.
        self.background_layer = CrossFadeBackgroundLayer(current_scene, next_scene, self.phase1_duration, self.phase2_duration)
        self.rain_layer = CrossFadeRainLayer(max_drops=100, color_name=TRANSITION_CONFIG["color"],
                                              phase1_duration=self.phase1_duration,
                                              phase2_duration=self.phase2_duration)
        self.layers = [self.background_layer, self.rain_layer]

    def handle_input(self, key):
        # Ignore user input during transition.
        return None

    def is_complete(self):
        total_duration = self.phase1_duration + self.phase2_duration
        return self.frame_count >= total_duration

def run_transition(stdscr, current_scene, next_scene):
    """
    Runs a transition from current_scene to next_scene based on the global TRANSITION_CONFIG.
    This helper handles all timing, color, effect type, and enabling/disabling.
    Modify TRANSITION_CONFIG here to change the transition globally.
    """
    if not TRANSITION_CONFIG.get("enabled", True):
        return
    phase1 = TRANSITION_CONFIG.get("phase1_duration", 500)
    phase2 = TRANSITION_CONFIG.get("phase2_duration", 500)
    dt_increment = TRANSITION_CONFIG.get("dt_increment", 10)
    napms_delay = TRANSITION_CONFIG.get("napms", 10)
    # Currently, only "crossfade" is implemented.
    transition_scene = CrossFadeTransitionScene(current_scene, next_scene, phase_duration=(phase1, phase2))
    # Update rain color from configuration.
    transition_scene.rain_layer.color_name = TRANSITION_CONFIG.get("color", "blue_on_black")
    from .curses_game_renderer import CursesGameRenderer
    renderer = CursesGameRenderer(stdscr)
    dt = 0
    while not transition_scene.is_complete():
        renderer.render_scene(transition_scene, dt=dt, context=None)
        dt += dt_increment
        curses.napms(napms_delay)
        transition_scene.frame_count = dt


# FileName: curses_selector_highlight.py
#
# version: 1.4
#
# Summary: Provides a single, globally configurable highlight/selector system.
#
# Tags: selector, highlight, effects

import curses
from .curses_utils import safe_addstr, get_color_attr
from .where_curses_themes_lives import CURRENT_THEME

GLOBAL_HIGHLIGHT_CONFIG = {
    # We set them to None; we will fetch from CURRENT_THEME at runtime.
    "selected_color_name":   None,
    "unselected_color_name": None,
    "effect_name":           "REVERSE_BLINK",
    "speed_factor":          5,
}

def get_global_selector_config():
    """
    Returns the global highlight config, filling in selected/unselected
    color names from the CURRENT_THEME if they are None.
    """
    config = GLOBAL_HIGHLIGHT_CONFIG.copy()
    if config["selected_color_name"] is None:
        config["selected_color_name"] = CURRENT_THEME["highlight_selected_color"]
    if config["unselected_color_name"] is None:
        config["unselected_color_name"] = CURRENT_THEME["highlight_unselected_color"]
    return config

def get_selector_effect_attrs(effect="REVERSE_BLINK", frame=0, speed_factor=10) -> int:
    toggle_state = (frame // speed_factor) % 2
    if effect == "NONE":
        return curses.A_NORMAL
    elif effect == "REVERSE":
        return curses.A_REVERSE
    elif effect == "BLINK":
        return curses.A_BLINK
    elif effect == "REVERSE_BLINK":
        return (curses.A_REVERSE | curses.A_BLINK)
    elif effect == "FLASH":
        return curses.A_REVERSE if toggle_state == 0 else curses.A_NORMAL
    elif effect == "GLOW":
        return curses.A_BOLD if toggle_state == 0 else curses.A_NORMAL
    elif effect == "SHIMMER":
        return (curses.A_BOLD | curses.A_BLINK) if toggle_state == 0 else curses.A_NORMAL
    return curses.A_REVERSE  # fallback

def draw_global_selector_line(stdscr, row: int, text: str, is_selected: bool=False, frame: int=0) -> None:
    config = get_global_selector_config()
    selected_color_name   = config["selected_color_name"]
    unselected_color_name = config["unselected_color_name"]
    effect_name           = config["effect_name"]
    speed_factor          = config["speed_factor"]

    if is_selected:
        attrs = get_selector_effect_attrs(effect=effect_name, frame=frame, speed_factor=speed_factor)
        color_attr = get_color_attr(selected_color_name) | attrs
    else:
        color_attr = get_color_attr(unselected_color_name)

    safe_addstr(stdscr, row, 2, text, color_attr)


# FileName: curses_tile_drawing.py
# version: 1.2 (refactored to remove layer_for_def_id usage in rendering)
#
# Summary:
#   Contains common tile-drawing logic for the curses UI. Moved here from
#   curses_renderer.py to allow a cleaner separation of responsibilities.
#
# ChangeLog:
#   v1.1:  - Added `compose_fg_with_floor_bg` helper to remove repeated code.
#          - Updated `draw_single_tile` & `draw_player_on_top` to use helper.
#   v1.2:  - Now draws floor + other layers from layer_manager.get_layers_in_draw_order().
#          - The old code referencing layer_for_def_id is commented out.
#
# Tags: curses, ui, rendering

from .curses_utils import safe_addch, parse_two_color_names
from .curses_selector_highlight import get_color_attr

# We still need ALL_SCENERY_DEFS for char/color lookups.
from scenery.scenery_manager import ALL_SCENERY_DEFS

# NEW: import the layer order helper so we can draw in ascending z-index
from scenery.layer_manager import get_layers_in_draw_order

# If you have special logic for "TreeTop" or "TreeTrunk", you might import them:
# from scenery_placement_utils import TREE_TOP_ID, TREE_TRUNK_ID
# or just compare definition_id == "TreeTop"/"TreeTrunk" inline.

def compose_fg_with_floor_bg(floor_color_name, fg_object_color_name):
    """
    Given a floor color name (e.g. "white_on_black") and an object's
    foreground color name (e.g. "red_on_black"), combine them so that:
      - The object's foreground remains the same,
      - The background becomes whatever the floor's background was.
    Returns a curses color attribute (int).
    """
    fg_floor, bg_floor = parse_two_color_names(floor_color_name)
    fg_obj, _ = parse_two_color_names(fg_object_color_name)
    final_color_name = f"{fg_obj}_on_{bg_floor}"
    return get_color_attr(final_color_name)


def draw_single_tile(stdscr, wx, wy, sx, sy, model, blank_attr):
    """
    Draw the background/floor plus any objects, items, or entities for tile (wx, wy).
    Painted at screen coords (sx, sy). The player is NOT drawn here; that is handled
    separately to ensure the player remains above (or below) certain objects.
    """

    # Erase any leftover character first.
    safe_addch(stdscr, sy, sx, " ", blank_attr, clip_borders=True)

    tile_dict = model.placed_scenery.get((wx, wy), None)
    if not tile_dict:
        return  # nothing to draw

    # NEW: multi-layer drawing approach
    # 1) Draw the floor first
    floor_obj = tile_dict.get("floor")
    floor_color_name = "white_on_black"

    if floor_obj:
        fdef = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {})
        ch_floor = fdef.get("ascii_char", floor_obj.char)
        floor_color_name = fdef.get("color_name", "white_on_black")
        floor_attr = get_color_attr(floor_color_name)
        safe_addch(stdscr, sy, sx, ch_floor, floor_attr, clip_borders=True)

    # 2) Draw every other layer in ascending z‐order,
    #    skipping "floor" because we already drew it above
    layers_in_order = get_layers_in_draw_order()
    for layer_name in layers_in_order:
        if layer_name == "floor":
            continue  # already handled

        # tile_dict might have e.g. tile_dict["objects"] = [...]
        layer_contents = tile_dict.get(layer_name, [])
        if not isinstance(layer_contents, list):
            # It's not a list if it's e.g. None or _prev_floor, skip
            continue

        for obj in layer_contents:
            info = ALL_SCENERY_DEFS.get(obj.definition_id, {})
            ch_obj = info.get("ascii_char", obj.char)
            obj_color_name = info.get("color_name", "white_on_black")

            # Example: if you want to skip "TreeTop" where the player stands,
            # you can do something like:
            # if obj.definition_id == "TreeTop" and (wx, wy) == (model.player.x, model.player.y):
            #     continue

            # Compose object FG with the floor's BG color
            obj_attr = compose_fg_with_floor_bg(floor_color_name, obj_color_name)
            safe_addch(stdscr, sy, sx, ch_obj, obj_attr, clip_borders=True)


def draw_player_on_top(stdscr, model, map_top_offset):
    """
    Draw the player above everything, but allow certain objects (e.g. TreeTop)
    to render last (so they can obscure the player if desired).
    """
    px = model.player.x - model.camera_x
    py = model.player.y - model.camera_y + map_top_offset
    max_h, max_w = stdscr.getmaxyx()

    if not (0 <= px < max_w and 0 <= py < max_h):
        return  # The player is off-screen

    tile_dict = model.placed_scenery.get((model.player.x, model.player.y), {})
    # Determine the floor color for background merging
    floor_obj = tile_dict.get("floor")
    floor_color_name = "white_on_black"
    if floor_obj:
        fdef = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {})
        floor_color_name = fdef.get("color_name", "white_on_black")

    # Draw the player using the floor's background color
    player_fg = getattr(model.player, "color_name", "white")  # e.g. "cyan"
    player_char = getattr(model.player, "char", "@")          # e.g. '@'

    player_attr = compose_fg_with_floor_bg(floor_color_name, player_fg)
    safe_addch(stdscr, py, px, player_char, player_attr, clip_borders=True)
    # If you have certain objects that should obscure the player (like "TreeTop"),
    # gather them from the "objects" or "overhead" layer, etc.:
    trunk_tops = []
    from_layers = get_layers_in_draw_order()
    # We skip "floor" since it doesn't contain lists. But we might check "objects"/"overhead".
    for layer_name in from_layers:
        if layer_name in ("floor",):  
            continue
        maybe_list = tile_dict.get(layer_name, [])
        if isinstance(maybe_list, list):
            for obj in maybe_list:
                if obj.definition_id in ("TreeTop", "TreeTrunk"):
                    trunk_tops.append(obj)

    # Re-draw those trunk/tops last, so they appear over the player
    for t_obj in trunk_tops:
        info = ALL_SCENERY_DEFS.get(t_obj.definition_id, {})
        ch = info.get("ascii_char", t_obj.char)
        top_color = info.get("color_name", "white_on_black")

        trunk_attr = compose_fg_with_floor_bg(floor_color_name, top_color)
        safe_addch(stdscr, py, px, ch, trunk_attr, clip_borders=True)


# FileName: curses_utils.py
#
# version: 1.1
#
# Summary: Provides safe curses output helpers and color attribute assembly.
#
# Tags: curses, utils

import curses
from typing import Optional
from .curses_color_init import color_pairs

def get_color_attr(color_name: str, bold: bool = False, blink: bool = False, underline: bool = False) -> int:
    """
    Given a color name like "white_on_black", returns a curses attribute
    including optional BOLD/BLINK/UNDERLINE bits.
    """
    pair_id = color_pairs.get(color_name, 0)
    attr = curses.color_pair(pair_id)
    if bold:
        attr |= curses.A_BOLD
    if blink:
        attr |= curses.A_BLINK
    if underline:
        attr |= curses.A_UNDERLINE
    return attr

def parse_two_color_names(fg_bg: str) -> (str, str):
    """
    Splits a string like "white_on_blue" into ("white","blue").
    If invalid, returns ("white","black").
    """
    parts = fg_bg.split("_on_")
    if len(parts) == 2:
        return parts[0], parts[1]
    return ("white", "black")

def _clip_coords_for_borders(row: int, col: int, max_h: int, max_w: int) -> (int, int):
    if row < 1 or row > (max_h - 2):
        return (-1, -1)
    if col < 1:
        col = 1
    if col > (max_w - 2):
        return (-1, -1)
    return (row, col)

def _truncate_for_borders_text(col: int, text: str, max_w: int) -> str:
    available_width = (max_w - 2) - col + 1
    if available_width < 1:
        return ""
    return text[:available_width]

def safe_addstr(stdscr: curses.window, row: int, col: int, text: str, attr: int, clip_borders: bool = True) -> None:
    """
    Safely add a string at (row, col), optionally clipping to a border if clip_borders=True.
    """
    max_h, max_w = stdscr.getmaxyx()

    if clip_borders:
        row2, col2 = _clip_coords_for_borders(row, col, max_h, max_w)
        if row2 < 0 or col2 < 0:
            return
        text = _truncate_for_borders_text(col2, text, max_w)
        if not text:
            return
        row, col = row2, col2
    else:
        if row < 0 or row >= max_h:
            return
        if col < 0 or col >= max_w:
            return
        available_width = max_w - col
        if available_width < 1:
            return
        text = text[:available_width]

    try:
        stdscr.addstr(row, col, text, attr)
    except curses.error:
        pass

def safe_addch(stdscr: curses.window, row: int, col: int, ch, attr: int, clip_borders: bool = True) -> None:
    """
    Safely add a single character at (row, col).
    """
    max_h, max_w = stdscr.getmaxyx()

    if clip_borders:
        row2, col2 = _clip_coords_for_borders(row, col, max_h, max_w)
        if row2 < 0 or col2 < 0:
            return
        row, col = row2, col2
    else:
        if row < 0 or row >= max_h:
            return
        if col < 0 or col >= max_w:
            return

    try:
        stdscr.addch(row, col, ch, attr)
    except curses.error:
        pass


# File: global_effects_manager.py
# version: 1.0
#
# Summary:
#   Manages global effect layers by aggregating them into one list.
#   You can add or remove effect layers here and then import the aggregated list
#   in your scene base class so every scene automatically draws these effects.
#
# Usage:
#   from global_effects_manager import add_effect_layer, get_effect_layers
#
#   # In your initialization code:
#   add_effect_layer(SnowEffectLayer(num_flakes=80, color_name="white_on_black"))
#   add_effect_layer(RainEffectLayer(num_drops=60, color_name="blue_on_black", direction="down"))

global_effect_layers = []

def add_effect_layer(layer):
    """Add an effect layer instance to the global list."""
    global_effect_layers.append(layer)

def remove_effect_layer(layer):
    """Remove an effect layer from the global list."""
    if layer in global_effect_layers:
        global_effect_layers.remove(layer)

def clear_effect_layers():
    """Clear all global effect layers."""
    global_effect_layers.clear()

def get_effect_layers():
    """Return the aggregated list of global effect layers."""
    return global_effect_layers


# File: curses_frontend/scene_base.py
# version: 1.1 (updated to include global effect layers)
#
# Summary:
#   Provides a base class for Scene objects that manage multiple SceneLayer plugins.
#   The get_layers() method now returns the scene's own layers plus any globally enabled effect layers.
from .global_effects_manager import get_effect_layers

class Scene:
    """
    A Scene manages one or more SceneLayer objects.
    """
    def __init__(self):
        self.layers = []  # Scene-specific layers

    def get_layers(self):
        """
        Return the list of SceneLayer objects that should be drawn.
        This includes the scene's own layers plus any global effect layers.
        """
        return self.layers + get_effect_layers()

    def handle_input(self, key):
        """
        Optional: Scenes can process input themselves.
        Return a new state, a choice, or None.
        """
        pass


# File: curses_frontend/scene_layer_base.py
# version: 1.0
#
# Summary:
#   Provides the base class for scene layers (plugin objects that know how to draw).
#   Each layer has a name, a z_index, and a .draw(renderer, dt, context) method.

class SceneLayer:
    """
    Base class for 'layer plugins'. Each layer knows:
      - self.name: a string identifying the layer
      - self.z_index: an integer controlling draw order
      - a .draw(renderer, dt, context) method to perform drawing.
    """
    def __init__(self, name, z_index=0):
        self.name = name
        self.z_index = z_index

    def draw(self, renderer, dt, context):
        """
        Subclasses should override this method.
        :param renderer: instance of your renderer (e.g., CursesGameRenderer)
        :param dt: a time delta or frame count for animations
        :param context: a game model or dictionary of data
        """
        pass



# FileName: where_curses_art_lives.py
#
# version: 1.2
#
# Summary: Stores ASCII art or special graphics needed for titles, load screens, or decorative UI elements.
#
# Tags: art, ui

HEADER_ART = [
    "=== HEADER ART PLACEHOLDER ===",
    "You can replace this with your own artwork."
]

LOADING_ART = [
    "--- LOADING ART PLACEHOLDER ---",
    "You can replace this with your own artwork."
]

HOMESCREEN_ART = [
    "::: HOMESCREEN ART PLACEHOLDER :::",
    "You can replace this with your own artwork."
]

DECORATION = [
    "... DECORATION PLACEHOLDER ...",
    "You can replace this with your own artwork."
]

BANNER = [
    "~~~ BANNER PLACEHOLDER ~~~"
]

BORDERS = [
    "+++ BORDERS PLACEHOLDER +++"
]

MAIN_MENU_ART = [
    "     .       +  ':.  .      *              '            *  '",
    "                  '::._                                      ",
    "                    '._)                 * +              ' ",
    "                          .              .        |         ",
    "           .      o.               +            - o -.      ",
    " o'          '    .    /  .         o             |         ",
    "    .  *   '          /                         +           ",
    "   .                 *          '                      .    ",
    "                 .             .             .  .           ",
    "   *         .   .       .                   | '.           ",
    "  +          '+                .           - o -            ",
    "          .                                . |              ",
    "            '  '     ..                   +  .  . +.        ",
    "  .                              |          .-.             ",
    " '                 .'  * '     - o -         ) )            ",
    " +        '   .                   |          '-´         '  ",
    "                       +      .'                   '.       ",
    " .           .           o      .       . .      .          ",
    "                       '       . +~~                       .",
]

CROCODILE = [
    "                _ ___                /^^\\ /^\\  /^^\\*",
    "    _          *@)@) \\            ,,/ '`~`'~~ ', `\\.",
    "  _/o\\_ _ _ _/~`.`...'~\\        ./~~..,'`','',.,' '  ~:",
    " / `','.~,~.~  .   , . , ~|,   ,/ .,' , ,. .. ,,.   `,  ~\\*",
    "( ' *' _ '*`_  '  .    ,`\\*/ .' ..' '  `  `   `..  `,   \\*",
    "  V~ V~ V~ ~\\ `   ' .  '    , ' .,.,''`.,.''`.,.``. ',   \\_",
    "  _/\\ /\\ /\\ /\\_/, . ' ,   `*/\\_ `. `. '.,  \\*",
    "< ~ ~ '~`'~'`, .,  .   `_: ::: \\_ '      `*/ ::: \\_ `.,' . ',  \\_",
    "  \\ ' `_  '`_    _    ',/ _::_::_ \\ _    _/ _::_::_ \\   `.,'.,`., \\-,-,-,_,_,",
    "   `'~~ `'~~ `'~~ `'~~  \\_)(_)(_)/  `~~' \\_)(*)(*)/ ~'`\\*..*,.*,'*;*;*;*;*;"
]

#


# FileName: where_curses_input_lives.py
# version: 2.4
#
# Summary: A curses-based front-end implementing IGameInput for user interaction.
#          Updated to remove the 'y' => YES_QUIT logic, so only 'q'/ESC quits.
#          Now also maps 'i' / 'I' => SHOW_INVENTORY.
#
# Tags: curses, ui, rendering

import curses
from engine.engine_interfaces import IGameInput

class CursesGameInput(IGameInput):
    """
    Implements IGameInput for curses: get_actions() reads the keyboard buffer,
    returns a list of action strings like ["MOVE_UP", "QUIT", "INTERACT", etc.].
    """

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.stdscr.nodelay(True)
        self.stdscr.keypad(True)
        curses.curs_set(0)

    def get_actions(self):
        actions = []
        # read up to ~5 keystrokes at once
        for _ in range(5):
            key = self.stdscr.getch()
            if key == -1:
                break
            act = self._interpret_key(key)
            if act:
                actions.append(act)
        return actions

    def _interpret_key(self, key):
        # Quit => q, Q, ESC
        if key in (ord('q'), ord('Q'), 27):
            return "QUIT"

        # Movement
        if key in (ord('w'), ord('W'), curses.KEY_UP):
            return "MOVE_UP"
        if key in (ord('s'), ord ('S'), curses.KEY_DOWN):
            return "MOVE_DOWN"
        if key in (ord('a'), ord ('A'), curses.KEY_LEFT):
            return "MOVE_LEFT"
        if key in (ord('d'), ord('D'), curses.KEY_RIGHT):
            return "MOVE_RIGHT"

        # Editor toggle
        if key in (ord('e'), ord('E')):
            return "EDITOR_TOGGLE"

        # Quick-save
        if key in (ord('o'), ord('O')):
            return "SAVE_QUICK"

        # Debug
        if key in (ord('v'), ord('V')):
            return "DEBUG_TOGGLE"

        # Interact
        if key == ord(' '):
            return "INTERACT"

        # Editor keys
        if key in (ord('p'), ord('P')):
            return "PLACE_ITEM"
        if key in (ord('x'), ord ('X')):
            return "REMOVE_TOP"
        if key in (ord('u'), ord('U')):
            return "UNDO"
        if key in (ord('l'), ord('L')):
            return "NEXT_ITEM"
        if key in (ord('k'), ord('K')):
            return "PREV_ITEM"

        # Show Inventory (new)
        if key in (ord('i'), ord('I')):
            return "SHOW_INVENTORY"

        return None


# FileName: where_curses_themes_lives.py
#
# version: 1.1
#
# Summary: Holds multiple named theme definitions (colors and ASCII art).
#          Provides a global CURRENT_THEME for the rest of the UI.
#
# Tags: themes, curses

from .where_curses_art_lives import (
    HEADER_ART,
    LOADING_ART,
    HOMESCREEN_ART,
    DECORATION,
    BANNER,
    BORDERS,
    MAIN_MENU_ART,
    CROCODILE
)

THEMES = {
    "default": {
        "border_color":              "blue_on_black",
        "title_color":               "green_on_black",
        "instructions_color":        "white_on_black",   
        "text_color":                "white_on_black",
        "ascii_art_color":           "magenta_on_black",

        "highlight_selected_color":  "yellow_on_black",   
        "highlight_unselected_color": "white_on_black", 

        # Added keys to handle previously hard-coded colors:
        "prompt_color":        "cyan_on_black",   
        "menu_item_color":     "yellow_on_black", 
        "confirmation_color":  "white_on_black",   

        "header_art":      HEADER_ART,
        "loading_art":     LOADING_ART,
        "homescreen_art":  HOMESCREEN_ART,
        "decoration_art":  DECORATION,
        "banner_art":      BANNER,
        "borders_art":     BORDERS,
        "main_menu_art":   MAIN_MENU_ART,
        "crocodile_art":   CROCODILE,
    },

    "dark": {
        "border_color":              "magenta_on_black", 
        "title_color":               "white_on_blue",    
        "instructions_color":        "cyan_on_black",
        "text_color":"yellow_on_black",   
        "ascii_art_color":           "white_on_black",

        "highlight_selected_color":  "yellow_on_black",
        "highlight_unselected_color": "white_on_black", 

        # Same added keys for a consistent dictionary:
        "prompt_color":        "magenta_on_black",
        "menu_item_color":     "yellow_on_black",
        "confirmation_color":  "white_on_black",  

        "header_art":      HEADER_ART,
        "loading_art":     LOADING_ART,
        "homescreen_art":  HOMESCREEN_ART,
        "decoration_art":  DECORATION,
        "banner_art":      BANNER,
        "borders_art":     BORDERS,
        "main_menu_art":   MAIN_MENU_ART,
        "crocodile_art":   CROCODILE,
    },
}

CURRENT_THEME = THEMES["default"]

def set_theme(theme_name: str):
    """
    Switch the global CURRENT_THEME to a different named theme.
    Fallbacks to 'default' if not found.
    """
    global CURRENT_THEME
    if theme_name in THEMES:
        CURRENT_THEME = THEMES[theme_name]
    else:
        CURRENT_THEME = THEMES["default"]

