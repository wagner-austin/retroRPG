==== File: ui_main.py ====
# FileName: ui_main.py
# version: 2.6
# Summary: Provides functions and helpers for drawing frames, labels, etc.
#          Now includes a universal draw_text helper for flexible FG/BG usage.
# Tags: ui, rendering, curses

import curses
from color_init import color_pairs
from animator_draw import draw_border, draw_art

# Existing color constants or aliases (now mapped in color_init.py):
INSTRUCTION_COLOR_NAME = "UI_MAGENTA"
BORDER_COLOR_NAME      = "UI_CYAN"
TITLE_COLOR_NAME       = "UI_WHITE_ON_BLUE"
TEXT_COLOR_NAME        = "YELLOW_TEXT"
ART_COLOR_NAME         = "ASCII_ART"

# This config remains from your existing code
UI_FONT_CONFIG = {
    "font_color_name": TEXT_COLOR_NAME,
    "font_size": None,
    "font_type": None,
}

def set_ui_font_config(**kwargs):
    for key, val in kwargs.items():
        if key in UI_FONT_CONFIG:
            UI_FONT_CONFIG[key] = val

def draw_title(stdscr, text, row=1, color_name=TITLE_COLOR_NAME):
    max_h, max_w = stdscr.getmaxyx()
    if row < 0 or row >= max_h:
        return
    col = 2
    title_color = curses.color_pair(color_pairs[color_name]) | curses.A_BOLD
    truncated = text[:max_w - col - 1]
    try:
        stdscr.addstr(row, col, truncated, title_color)
    except curses.error:
        pass

def draw_instructions(stdscr, lines, from_bottom=2, color_name=INSTRUCTION_COLOR_NAME):
    h, w = stdscr.getmaxyx()
    color = curses.color_pair(color_pairs[color_name])
    start_row = h - from_bottom - len(lines)
    if start_row < 1:
        start_row = 1

    row = start_row
    for line in lines:
        if row >= h - 1:
            break
        truncated = line[:w - 4]
        try:
            stdscr.addstr(row, 2, truncated, color)
        except curses.error:
            pass
        row += 1

def draw_screen_frame(stdscr, color_name=BORDER_COLOR_NAME):
    draw_border(stdscr, color_name)
    # Show "Debug mode" in top-right if debug enabled
    try:
        import debug
        if debug.DEBUG_CONFIG["enabled"]:
            max_h, max_w = stdscr.getmaxyx()
            label = "Debug mode: On"
            col = max_w - len(label) - 2
            debug_color = curses.color_pair(color_pairs["WHITE_TEXT"])
            stdscr.addstr(0, col, label, debug_color)
    except:
        pass

# --------------------------------------------------------------------
# NEW HELPER: draw_text for direct FG/BG usage
# --------------------------------------------------------------------
def draw_text(stdscr, row, col, text,
              fg="white",
              bg="black",
              bold=False,
              underline=False):
    """
    Draw text at (row, col) with a direct FG_on_BG approach,
    e.g. draw_text(..., fg="light_gray", bg="black", bold=True).
    """
    pair_name = f"{fg}_on_{bg}"
    pair_id = color_pairs.get(pair_name, 0)  # 0 => default color if not found
    attr = curses.color_pair(pair_id)
    if bold:
        attr |= curses.A_BOLD
    if underline:
        attr |= curses.A_UNDERLINE

    max_h, max_w = stdscr.getmaxyx()
    truncated = text[: (max_w - col)]

    try:
        stdscr.addstr(row, col, truncated, attr)
    except curses.error:
        pass

==== File: animator_draw.py ====
# FileName: animator_draw.py
# version: 1.2
# Summary: Houses the drawing routines for sprite or scene animations, used by the animator logic.
# Tags: animation, drawing

import curses

# Previously: from colors import color_pairs
# Then we changed: from color_init import color_pairs
# Now do an absolute import from topdownrpg_v3:
from color_init import color_pairs

def draw_border(stdscr, color_name="UI_CYAN"):
    """
    Draws a rectangular border around the entire screen using the given color_name.
    """
    h, w = stdscr.getmaxyx()
    if h < 3 or w < 3:
        return
    border_color = curses.color_pair(color_pairs[color_name])
    try:
        stdscr.hline(0, 0, curses.ACS_HLINE, w, border_color)
        stdscr.addch(0, 0, curses.ACS_ULCORNER, border_color)
        stdscr.addch(0, w-1, curses.ACS_URCORNER, border_color)
        stdscr.hline(h-1, 0, curses.ACS_HLINE, w, border_color)
        stdscr.addch(h-1, 0, curses.ACS_LLCORNER, border_color)
        stdscr.addch(h-1, w-1, curses.ACS_LRCORNER, border_color)
        for row in range(1, h-1):
            stdscr.addch(row, 0, curses.ACS_VLINE, border_color)
            stdscr.addch(row, w-1, curses.ACS_VLINE, border_color)
    except curses.error:
        pass

def draw_art(stdscr, art_lines, start_row=1, start_col=2, color_name="ASCII_ART"):
    """
    Renders 'art_lines' at (start_row, start_col), truncating if needed.
    """
    art_color = curses.color_pair(color_pairs[color_name])
    max_h, max_w = stdscr.getmaxyx()
    row = start_row
    for line in art_lines:
        if row >= max_h - 1:
            break
        available_width = max_w - start_col - 1
        if available_width < 1:
            continue
        truncated = line[:available_width]
        try:
            stdscr.addstr(row, start_col, truncated, art_color)
        except curses.error:
            pass
        row += 1

==== File: art_main.py ====
# FileName: art_main.py
# version: 1.2
# Summary: Stores ASCII art or special graphics needed for titles, load screens, or decorative UI elements.
# Tags: art, ui

HEADER_ART = [
    "=== HEADER ART PLACEHOLDER ===",
    "You can replace this with your own artwork."
]

LOADING_ART = [
    "--- LOADING ART PLACEHOLDER ---",
    "You can replace this with your own artwork."
]

HOMESCREEN_ART = [
    "::: HOMESCREEN ART PLACEHOLDER :::",
    "You can replace this with your own artwork."
]

DECORATION = [
    "... DECORATION PLACEHOLDER ...",
    "You can replace this with your own artwork."
]

BANNER = [
    "~~~ BANNER PLACEHOLDER ~~~"
]

BORDERS = [
    "+++ BORDERS PLACEHOLDER +++"
]

MAIN_MENU_ART = [
    "     .       +  ':.  .      *              '            *  '",
    "                  '::._                                      ",
    "                    '._)                 * +              ' ",
    "                          .              .        |         ",
    "           .      o.               +            - o -.      ",
    " o'          '    .    /  .         o             |         ",
    "    .  *   '          /                         +           ",
    "   .                 *          '                      .    ",
    "                 .             .             .  .           ",
    "   *         .   .       .                   | '.           ",
    "  +          '+                .           - o -            ",
    "          .                                . |              ",
    "            '  '     ..                   +  .  . +.        ",
    "  .                              |          .-.             ",
    " '                 .'  * '     - o -         ) )            ",
    " +        '   .                   |          '-´         '  ",
    "                       +      .'                   '.       ",
    " .           .           o      .       . .      .          ",
    "                       '       . +~~                       .",
]

CROCODILE = [
    "                _ ___                /^^\\ /^\\  /^^\\_",
    "    _          _@)@) \\            ,,/ '` ~ `'~~ ', `\\.",
    "  _/o\\_ _ _ _/~`.`...'~\\        ./~~..,'`','',.,' '  ~:",
    " / `','.~,~.~  .   , . , ~|,   ,/ .,' , ,. .. ,,.   `,  ~\\_",
    "( ' _' _ '_` _  '  .    , `\\_/ .' ..' '  `  `   `..  `,   \\_",
    " ~V~ V~ V~ V~ ~\\ `   ' .  '    , ' .,.,''`.,.''`.,.``. ',   \\_",
    "  _/\\ /\\ /\\ /\\_/, . ' ,   `_/~\\_ .' .,. ,, , _/~\\_ `. `. '.,  \\_",
    " < ~ ~ '~`'~'`, .,  .   `_: ::: \\_ '      `_/ ::: \\_ `.,' . ',  \\_",
    "  \\ ' `_  '`_    _    ',/ _::_::_ \\ _    _/ _::_::_ \\   `.,'.,`., \\-,-,-,_,_,",
    "   `'~~ `'~~ `'~~ `'~~  \\_)(_)(_)/  `~~' \\_)(_)(_)/ ~'`\\_.._,._,'_;_;_;_;_;"
]

DRAGON_ART_1 = [
    "       \\****__              ____",
    "         |    *****\\_      --/ *\\-__",
    "         /_          (_    ./ ,/----'",
    "Art by     \\__         (_./  /",
    " Ironwing     \\__           \\___----^__",
    "               _/   _                  \\",
    "        |    _/  __/ )\\\"\\ _____         *\\",
    "        |\\__/   /    ^ ^       \\____      )",
    "         \\___--\"                    \\_____ )",
    "                                          \"",
    "Red Phoenix"
]

DRAGON_ART_2 = [
    "                __        _      ",
    "              _/  \\    _(\o     ",
    "             /     \\  /  _  ^^^o ",
    "            /   !   \\/  ! '!!!v' ",
    "           !  !  \\ _' ( \\____    ",
    "           ! . \\ _!\\   \\===^\   ",
    "Art by      \\ \\_!  / __!         ",
    " Gunnar Z.   \\!   /    \\         ",
    "       (\\_      _/   _\\ )        ",
    "        \\ ^^--^^ __-^ /(__       ",
    "         ^^----^^    \"^--v'"
]

DRAGON_ART_3 = [
    "                \\||/",
    "                |  @___oo",
    "      /\\  /\\   / (__,,,,|",
    "     ) /^\ ^\\/ _)",
    "     )   /^\\/   _)",
    "     )   _ /  / _)",
    " /\\  )/\\/ ||  | )_)",
    "<  >      |(,,) )__)",
    " ||      /    \\___)\\",
    " | \\____(      )___) )___",
    "  \\______(_______;;; __;;;"
]

==== File: main_RetroRPG.py ====
# FileName: main_RetroRPG.py
# version: 1.6 (modified to use MenuFlowManager)
# Summary: Main entry point for RetroRPG, handling high-level init, config loading, and main menu dispatch.
# Tags: main, entry, initialization

import curses
from color_init import init_colors
from menu_flow_manager import MenuFlowManager

def run_game(stdscr):
    # Let the terminal size stabilize before we draw anything
    curses.napms(100)

    init_colors()
    # Instead of manually looping the home scene, we delegate to our new menu flow manager
    flow_manager = MenuFlowManager(stdscr)
    flow_manager.run()

def main():
    curses.wrapper(run_game)

if __name__ == "__main__":
    main()

==== File: animator_main.py ====
# FileName: animator_main.py
# version: 2.1
# Summary: Manages low-level animation updates (e.g. subtle ASCII art shifts). 
#          High-level "scene" logic has been moved to scene_main.py.
# Tags: animation, transitions

import curses
from animator_draw import draw_art


def animate_art_subtle(
    stdscr,
    art_lines,
    title_text=None,
    max_shift=2,
    frame_delay_ms=50,
    shift_delay_frames=20
):
    """
    Slowly shifts ASCII art left/right by ±max_shift columns,
    pausing shift_delay_frames between shifts.
    Press 'q'/'Q' or ESC to exit.
    Optional: 'title_text' can be displayed at row=1, col=2 (if desired).
    """
    stdscr.nodelay(True)
    curses.curs_set(0)

    offset_x = -2
    direction = -1
    frame_count = 0

    while True:
        # You can optionally clear or let the caller draw a frame, etc.
        stdscr.erase()

        # If given, display some title text
        if title_text:
            try:
                stdscr.addstr(1, 2, title_text, curses.A_BOLD)
            except curses.error:
                pass

        # Render art offset by offset_x
        draw_art(stdscr, art_lines, start_row=3, start_col=2 + offset_x)

        # Double-buffer
        stdscr.noutrefresh()
        curses.doupdate()

        key = stdscr.getch()
        if key in (ord('q'), ord('Q'), 27):
            break
        elif key == ord('v'):
            import debug
            debug.toggle_debug()

        frame_count += 1
        if frame_count % shift_delay_frames == 0:
            offset_x += direction
            if offset_x >= max_shift:
                offset_x = max_shift
                direction = -1
            elif offset_x <= -max_shift:
                offset_x = -max_shift
                direction = 1

        curses.napms(frame_delay_ms)

==== File: color_init.py ====
# FileName: color_init.py
# version: 3.1
# Summary: Initializes curses color pairs. Skips invalid indexes if terminal supports fewer colors.
# Tags: colors, curses, setup

import curses
from color_library import BASE_COLORS, EXTENDED_COLORS, define_extended_colors

color_pairs = {}

def init_colors():
    curses.start_color()
    curses.use_default_colors()

    # Attempt to define extended colors if supported
    define_extended_colors()

    # Merge base + extended color definitions
    all_colors = dict(BASE_COLORS)
    all_colors.update(EXTENDED_COLORS)

    pair_index = 1
    for fg_name, fg_val in all_colors.items():
        for bg_name, bg_val in all_colors.items():
            # Only define pairs if fg_val & bg_val are within the supported range
            if fg_val < curses.COLORS and bg_val < curses.COLORS:
                pair_name = f"{fg_name}_on_{bg_name}"
                curses.init_pair(pair_index, fg_val, bg_val)
                color_pairs[pair_name] = pair_index
                pair_index += 1

    # Create alias names for legacy references
    ALIAS_MAP = {
        "UI_YELLOW":    "yellow_on_black",
        "WHITE_TEXT":   "white_on_black",
        "UI_CYAN":      "cyan_on_black",
        "UI_MAGENTA":   "magenta_on_black",
        "UI_WHITE_ON_BLUE": "white_on_blue",
        "YELLOW_TEXT":  "yellow_on_black",
        "ASCII_ART":    "white_on_black",
        "TREE_TOP":     "green_on_black",
        "ROCK":         "white_on_black",
        "RIVER":        "white_on_blue",
        "GRASS":        "white_on_green",
        "PATH":         "black_on_yellow",
        # Add more if needed
    }

    for alias_name, real_name in ALIAS_MAP.items():
        if real_name in color_pairs:
            color_pairs[alias_name] = color_pairs[real_name]
        else:
            # fallback to white_on_black if real_name not defined
            color_pairs[alias_name] = color_pairs.get("white_on_black", 0)

==== File: controls_main.py ====
# FileName: controls_main.py
# version: 2.9
# Summary: Interprets user input for both play and editor modes, including movement, undo, toggles, etc.
#          Modified so that the inline yes/no prompt for generated maps appears at the bottom of the screen.
# Tags: controls, input, main

import curses
from scenery_main import (
    place_scenery_item,
    _get_objects_at,
    _remove_scenery,
    _append_scenery
)
from utils_main import get_front_tile
import debug


def handle_common_keys(key, model, stdscr, mark_dirty_func):
    """
    Handle keys that apply to *both* play and editor modes:
      - Quitting (y):
         * If existing map => quick-save silently, then quit
         * If generated map => prompt "Save? y/n" at the bottom of the screen;
           if y => do the normal save UI logic, else skip, then quit
      - Movement (WASD or arrow keys)
      - Debug toggle (v)
      - Mode switch (e)
      - Quick-save (o)
    """
    player = model.player
    context = model.context
    
    did_move = False
    should_quit = False

    def _perform_quick_save():
        from map_io_ui import save_map_ui
        # If we have a loaded filename, overwrite it
        if hasattr(model, "loaded_map_filename") and model.loaded_map_filename:
            save_map_ui(
                stdscr,
                model.placed_scenery,
                player=model.player,
                world_width=model.world_width,
                world_height=model.world_height,
                filename_override=model.loaded_map_filename
            )
        else:
            # Prompt for new filename
            save_map_ui(
                stdscr,
                model.placed_scenery,
                player=model.player,
                world_width=model.world_width,
                world_height=model.world_height,
                filename_override=None
            )
        model.full_redraw_needed = True

    def _prompt_yes_no(stdscr, question="Save this generated map? (y/n)"):
        """
        Inline yes/no prompt at the bottom of the screen.
        Returns True if user pressed y/Y, False if n/N.
        """
        max_h, max_w = stdscr.getmaxyx()
        qy = max_h - 1  # bottom row
        qx = 2

        # Try clearing that line
        try:
            stdscr.move(qy, 0)
            stdscr.clrtoeol()
        except:
            pass

        # Now print the prompt
        try:
            stdscr.addstr(qy, qx, question, curses.color_pair(0))
            stdscr.refresh()
        except:
            pass

        while True:
            c = stdscr.getch()
            if c in (ord('y'), ord('Y')):
                return True
            elif c in (ord('n'), ord('N')):
                return False

    # Quit key
    if key == ord('y'):
        # Check if it's an existing map or generated
        if model.loaded_map_filename:
            # 1) Existing map => silent quick-save, then quit
            _perform_quick_save()
            should_quit = True
        else:
            # 2) Generated map => prompt user at bottom row
            save_decision = _prompt_yes_no(stdscr, "Save this generated map? (y/n)")
            if save_decision:
                _perform_quick_save()
            should_quit = True
        return (did_move, should_quit)

    # Movement (WASD or arrow keys), factoring in debug walk speed
    elif key in (ord('w'), ord('W'), curses.KEY_UP):
        for _ in range(debug.DEBUG_CONFIG["walk_speed_multiplier"]):
            old_x, old_y = player.x, player.y
            player.move("up", model.world_width, model.world_height, model.placed_scenery)
            if (player.x, player.y) != (old_x, old_y):
                mark_dirty_func(old_x, old_y)
                mark_dirty_func(player.x, player.y)
                did_move = True

    elif key in (ord('s'), ord('S'), curses.KEY_DOWN):
        for _ in range(debug.DEBUG_CONFIG["walk_speed_multiplier"]):
            old_x, old_y = player.x, player.y
            player.move("down", model.world_width, model.world_height, model.placed_scenery)
            if (player.x, player.y) != (old_x, old_y):
                mark_dirty_func(old_x, old_y)
                mark_dirty_func(player.x, player.y)
                did_move = True

    elif key in (ord('a'), ord('A'), curses.KEY_LEFT):
        for _ in range(debug.DEBUG_CONFIG["walk_speed_multiplier"]):
            old_x, old_y = player.x, player.y
            player.move("left", model.world_width, model.world_height, model.placed_scenery)
            if (player.x, player.y) != (old_x, old_y):
                mark_dirty_func(old_x, old_y)
                mark_dirty_func(player.x, player.y)
                did_move = True

    elif key in (ord('d'), ord('D'), curses.KEY_RIGHT):
        for _ in range(debug.DEBUG_CONFIG["walk_speed_multiplier"]):
            old_x, old_y = player.x, player.y
            player.move("right", model.world_width, model.world_height, model.placed_scenery)
            if (player.x, player.y) != (old_x, old_y):
                mark_dirty_func(old_x, old_y)
                mark_dirty_func(player.x, player.y)
                did_move = True

    # Toggle Debug Mode
    elif key == ord('v'):
        debug.toggle_debug()
        model.full_redraw_needed = True

    # Switch between play and editor mode using 'e'
    elif key == ord('e'):
        if context.mode_name == "play":
            context.mode_name = "editor"
            context.enable_editor_commands = True
            context.enable_sliding = False
            context.enable_respawn = False

            if not model.editor_scenery_list:
                from scenery_main import get_placeable_scenery_defs
                dynamic_defs = get_placeable_scenery_defs()
                model.editor_scenery_list = [(def_id, None, None) for def_id in dynamic_defs]
        else:
            context.mode_name = "play"
            context.enable_editor_commands = False
            context.enable_sliding = True
            context.enable_respawn = True

        model.full_redraw_needed = True

    # Quick-save with 'o'
    elif key == ord('o'):
        _perform_quick_save()

    return (did_move, should_quit)


def handle_editor_keys(key, model, stdscr, full_redraw_needed, mark_dirty_func):
    """
    Editor-only keys:
      - p (Place object)
      - x (Delete the topmost object at player's tile)
      - u (Undo last place or delete)
      - l, k (Next/Prev item)
    """
    if not model.context.enable_editor_commands:
        return full_redraw_needed

    editor_scenery_list = model.editor_scenery_list
    editor_scenery_index = model.editor_scenery_index
    player = model.player

    if key == ord('p'):
        if editor_scenery_list:
            current_def_id = editor_scenery_list[editor_scenery_index][0]
            newly_placed = place_scenery_item(
                current_def_id,
                player,
                model.placed_scenery,
                mark_dirty_func=mark_dirty_func,
                is_editor=True,
                world_width=model.world_width,
                world_height=model.world_height
            )
            if newly_placed:
                model.editor_undo_stack.append(("added", newly_placed))

    elif key == ord('x'):
        px, py = player.x, player.y
        tile_objs = _get_objects_at(model.placed_scenery, px, py)
        if tile_objs:
            top_obj = tile_objs[-1]
            _remove_scenery(model.placed_scenery, top_obj)
            model.editor_undo_stack.append(("removed", [top_obj]))
            mark_dirty_func(px, py)

    elif key == ord('u'):
        if model.editor_undo_stack:
            action, objects_list = model.editor_undo_stack.pop()
            if action == "added":
                for obj in reversed(objects_list):
                    _remove_scenery(model.placed_scenery, obj)
                    mark_dirty_func(obj.x, obj.y)
            elif action == "removed":
                for obj in objects_list:
                    _append_scenery(model.placed_scenery, obj)
                    mark_dirty_func(obj.x, obj.y)

    elif key == ord('l'):
        if editor_scenery_list:
            model.editor_scenery_index = (editor_scenery_index + 1) % len(editor_scenery_list)
            full_redraw_needed = True

    elif key == ord('k'):
        if editor_scenery_list:
            model.editor_scenery_index = (editor_scenery_index - 1) % len(editor_scenery_list)
            full_redraw_needed = True

    return full_redraw_needed


def handle_play_keys(key, model, full_redraw_needed, mark_dirty_func):
    """
    Play-mode-specific keys, e.g. space for chop or mine.
    """
    if model.context.enable_editor_commands:
        return full_redraw_needed

    player = model.player
    from_scenery = model.placed_scenery
    if key == ord(' '):
        fx, fy = get_front_tile(player)
        found_something = False
        removed_objs = []

        tile_objs = _get_objects_at(from_scenery, fx, fy)
        trunk = next((o for o in tile_objs if o.definition_id == "TreeTrunk"), None)
        if trunk:
            found_something = True
            removed_objs.append(trunk)
            player.wood += 1
            full_redraw_needed = True

            top_objs = _get_objects_at(from_scenery, fx, fy - 1)
            top_o = next((o for o in top_objs if o.definition_id == "TreeTop"), None)
            if top_o:
                removed_objs.append(top_o)

            if model.context.enable_respawn:
                sublist = [(obj.x, obj.y, obj.char, obj.color_pair) for obj in removed_objs]
                model.respawn_list.append({"countdown": 50, "objects": sublist})

        rock_o = next((o for o in tile_objs if o.definition_id == "Rock"), None)
        if rock_o:
            found_something = True
            removed_objs.append(rock_o)
            player.stone += 1
            full_redraw_needed = True
            if model.context.enable_respawn:
                sublist = [(rock_o.x, rock_o.y, rock_o.char, rock_o.color_pair)]
                model.respawn_list.append({"countdown": 50, "objects": sublist})

        if found_something:
            for ro in removed_objs:
                _remove_scenery(from_scenery, ro)
                mark_dirty_func(ro.x, ro.y)

            model.action_flash_info = (fx, fy, 1)
            mark_dirty_func(fx, fy)

    return full_redraw_needed

==== File: engine_actionflash.py ====
# FileName: engine_actionflash.py
# version: 1.0
# Summary: Displays and updates short-lived visual indicators (flashes) when player chops, mines, or interacts.
# Tags: engine, feedback, effects

def update_action_flash(model, mark_dirty_func):
    """
    Decrements the action_flash_info counter. If it's done, clears it and marks dirty.
    """
    if model.action_flash_info is None:
        return

    fx, fy, count = model.action_flash_info
    count -= 1
    if count <= 0:
        model.action_flash_info = None
        mark_dirty_func(fx, fy)
    else:
        model.action_flash_info = (fx, fy, count)
        mark_dirty_func(fx, fy)

==== File: engine_camera.py ====
# FileName: engine_camera.py
# version: 2.3
# Summary: Implements camera logic (dead-zone scrolling, centering) to keep the player in view on large maps.
# Tags: engine, camera, scrolling

import curses

def update_camera_with_deadzone(player_x, player_y,
                                camera_x, camera_y,
                                visible_cols, visible_rows,
                                world_width, world_height,
                                dead_zone=2):
    """
    Moves the camera only if the player is within 'dead_zone' tiles of an edge.
    Prevents constant recentering on small moves.
    Returns (new_camera_x, new_camera_y).
    """
    # Convert player's world coords to on-screen coords
    screen_px = player_x - camera_x
    screen_py = player_y - camera_y

    # Horizontal deadzone
    if screen_px < dead_zone:
        camera_x -= (dead_zone - screen_px)
    elif screen_px > (visible_cols - dead_zone - 1):
        camera_x += (screen_px - (visible_cols - dead_zone - 1))

    # Vertical deadzone
    if screen_py < dead_zone:
        camera_y -= (dead_zone - screen_py)
    elif screen_py > (visible_rows - dead_zone - 1):
        camera_y += (screen_py - (visible_rows - dead_zone - 1))

    # Clamp to map bounds
    if camera_x < 0:
        camera_x = 0
    if camera_y < 0:
        camera_y = 0
    if camera_x > (world_width - visible_cols):
        camera_x = (world_width - visible_cols)
    if camera_y > (world_height - visible_rows):
        camera_y = (world_height - visible_rows)

    return camera_x, camera_y

def center_camera_on_player(model, stdscr, map_top_offset):
    """
    Centers the camera on the player initially (or whenever called).
    Previously in camera_system.py
    """
    max_scr_rows, max_scr_cols = stdscr.getmaxyx()
    visible_cols = max_scr_cols
    visible_rows = max_scr_rows - map_top_offset

    model.camera_x = model.player.x - (visible_cols // 2)
    model.camera_y = model.player.y - (visible_rows // 2)

    if model.camera_x < 0:
        model.camera_x = 0
    if model.camera_y < 0:
        model.camera_y = 0
    if model.camera_x > (model.world_width - visible_cols):
        model.camera_x = (model.world_width - visible_cols)
    if model.camera_y > (model.world_height - visible_rows):
        model.camera_y = (model.world_height - visible_rows)

def partial_scroll_vertical(model, stdscr, dy, map_top_offset):
    """
    Scrolls the screen vertically by 1 tile if dy is ±1,
    or triggers a fallback reblit if needed.
    Previously in camera_system.py
    """
    max_scr_rows, max_scr_cols = stdscr.getmaxyx()
    visible_cols = max_scr_cols
    visible_rows = max_scr_rows - map_top_offset

    def fallback_reblit():
        for row in range(model.camera_y, model.camera_y + visible_rows):
            for col in range(model.camera_x, model.camera_x + visible_cols):
                model.dirty_tiles.add((col, row))

    stdscr.setscrreg(map_top_offset, max_scr_rows - 1)
    try:
        if dy == 1:
            stdscr.scroll(1)
            new_row = model.camera_y + visible_rows - 1
            for col in range(model.camera_x, model.camera_x + visible_cols):
                model.dirty_tiles.add((col, new_row))
        elif dy == -1:
            stdscr.scroll(-1)
            new_row = model.camera_y
            for col in range(model.camera_x, model.camera_x + visible_cols):
                model.dirty_tiles.add((col, new_row))
    except curses.error:
        fallback_reblit()
    stdscr.setscrreg(0, max_scr_rows - 1)

def partial_scroll_horizontal(model, stdscr, dx, map_top_offset):
    """
    Scrolls the screen horizontally by 1 tile if dx is ±1,
    or triggers a fallback reblit if the jump is big.
    Now truly does a partial horizontal scroll (shifting screen text).
    """
    max_scr_rows, max_scr_cols = stdscr.getmaxyx()
    visible_cols = max_scr_cols
    visible_rows = max_scr_rows - map_top_offset

    def fallback_reblit():
        for row in range(model.camera_y, model.camera_y + visible_rows):
            for col in range(model.camera_x, model.camera_x + visible_cols):
                model.dirty_tiles.add((col, row))

    # If the camera jumped more than 1 tile horizontally, do a full redraw
    if abs(dx) > 1:
        fallback_reblit()
        return

    # Otherwise, we try to shift by exactly 1 column (left or right)
    try:
        if dx == 1:
            # Move everything left by 1 column
            for screen_row in range(map_top_offset, map_top_offset + visible_rows):
                # Read current row (starting from col=1)
                line_bytes = stdscr.instr(screen_row, 1, visible_cols - 1)
                # Write them back at col=0
                stdscr.addstr(screen_row, 0, line_bytes)
                # Clear the last column
                stdscr.addch(screen_row, visible_cols - 1, ' ')

            # Mark the newly exposed column on the right as dirty
            new_col = model.camera_x + visible_cols - 1
            for row in range(model.camera_y, model.camera_y + visible_rows):
                model.dirty_tiles.add((new_col, row))

        elif dx == -1:
            # Move everything right by 1 column
            for screen_row in range(map_top_offset, map_top_offset + visible_rows):
                line_bytes = stdscr.instr(screen_row, 0, visible_cols - 1)
                # Write them starting from col=1
                stdscr.addstr(screen_row, 1, line_bytes)
                # Clear the first column
                stdscr.addch(screen_row, 0, ' ')

            # Mark the newly exposed column on the left as dirty
            new_col = model.camera_x
            for row in range(model.camera_y, model.camera_y + visible_rows):
                model.dirty_tiles.add((new_col, row))

    except curses.error:
        fallback_reblit()

==== File: engine_framerate.py ====
# FileName: engine_framerate.py
# version: 1.0
# Summary: Manages timing and frame delays to maintain a target FPS, preventing overly fast or slow loops.
# Tags: engine, performance, timing

import time

def manage_framerate(desired_fps=20):
    """
    If you want a variable time step or more advanced timing, 
    you can store 'last_time' and measure dt here, etc.
    
    Currently, we just do a simple sleep for a fixed FPS (20).
    """
    # 1 / 20 = 0.05
    frame_time = 1.0 / desired_fps
    time.sleep(frame_time)


==== File: engine_main.py ====
# FileName: engine_main.py
# version: 2.11
# Summary: Core game loop integrating updates (NPCs, respawns, network) and rendering each frame.
# Tags: engine, main, loop

import curses

from engine_camera import (
    update_camera_with_deadzone,
    center_camera_on_player,
    partial_scroll_vertical,
    partial_scroll_horizontal
)
from engine_render import (
    draw_layers,
    mark_dirty,
    update_partial_tiles_in_view
)
from ui_main import draw_screen_frame
from color_init import color_pairs
from scenery_main import (
    get_placeable_scenery_defs,
    apply_tile_effects,
    get_scenery_def_id_at,
    # Below imports are needed for our layering fix:
    _layer_for_def_id,
    FLOOR_LAYER, OBJECTS_LAYER, ITEMS_LAYER, ENTITIES_LAYER
)
from model_main import GameModel
from controls_main import (
    handle_common_keys,
    handle_editor_keys,
    handle_play_keys
)
from engine_respawn import handle_respawns
from engine_actionflash import update_action_flash
from engine_npc import update_npcs
from engine_network import handle_network
from engine_transition import handle_transitions
from engine_framerate import manage_framerate


class GameContext:
    def __init__(self, mode_name="play"):
        self.mode_name = mode_name
        self.enable_editor_commands = False
        self.enable_sliding = False
        self.enable_respawn = False
        self.require_bridge_supplies = False
        self.enable_monster_ai = False
        self.enable_damage = False

        if mode_name == "editor":
            self.enable_editor_commands = True
            self.enable_sliding = False
            self.enable_respawn = False
            self.enable_monster_ai = False
            self.enable_damage = False
        elif mode_name == "play":
            self.enable_editor_commands = False
            self.enable_sliding = True
            self.enable_respawn = True


def _ensure_layered_scenery_format(placed_scenery):
    """
    Ensures that placed_scenery[(x,y)] is a dictionary with keys:
      'floor', 'objects', 'items', 'entities'
    rather than just a list of SceneryObjects.
    
    If it finds a dictionary (with 'floor' etc.) at (x,y), we assume it's
    already in the new layered format. Otherwise, we convert the old
    list-of-objects format to the layered structure.
    """
    if not placed_scenery:
        return placed_scenery  # Nothing to convert

    # Peek at one tile to see if it's already a dict
    first_key = next(iter(placed_scenery))
    first_val = placed_scenery[first_key]

    # If it's already { 'floor': ..., 'objects': [...], ... }, do nothing
    if isinstance(first_val, dict) and FLOOR_LAYER in first_val:
        return placed_scenery

    # Otherwise, convert each tile's list-of-objects into a layered dict
    new_dict = {}
    for (x, y), obj_list in placed_scenery.items():
        tile_dict = {
            FLOOR_LAYER: None,
            OBJECTS_LAYER: [],
            ITEMS_LAYER: [],
            ENTITIES_LAYER: []
        }
        for obj in obj_list:
            layer_name = _layer_for_def_id(obj.definition_id)
            if layer_name == FLOOR_LAYER:
                # Overwrite any previous floor
                tile_dict[FLOOR_LAYER] = obj
            else:
                tile_dict[layer_name].append(obj)
        new_dict[(x, y)] = tile_dict

    return new_dict


def run_engine(stdscr,
               context,
               player,
               placed_scenery,
               respawn_list=None,
               map_top_offset=3,
               world_width=100,
               world_height=60,
               loaded_map_filename=None):
    """
    Main loop for both play and editor modes.

    :param loaded_map_filename: If not None, quick-save overwrites this file;
                               else we prompt for a new filename.
    """
    model = GameModel()
    model.player = player
    model.world_width = world_width
    model.world_height = world_height
    model.context = context

    # Store the loaded filename in the model
    model.loaded_map_filename = loaded_map_filename

    # Convert 'placed_scenery' into a dict-of-lists if needed
    if isinstance(placed_scenery, dict):
        model.placed_scenery = placed_scenery
    else:
        dict_scenery = {}
        for obj in placed_scenery:
            if hasattr(obj, 'x') and hasattr(obj, 'y'):
                dict_scenery.setdefault((obj.x, obj.y), []).append(obj)
        model.placed_scenery = dict_scenery

    # Now ensure it's in the layered (floor/objects/items/entities) format
    model.placed_scenery = _ensure_layered_scenery_format(model.placed_scenery)

    # Optionally store the respawn list
    if respawn_list:
        model.respawn_list = respawn_list

    # If in editor mode, load placeable items
    if context.enable_editor_commands:
        dynamic_defs = get_placeable_scenery_defs()
        model.editor_scenery_list = [(def_id, None, None) for def_id in dynamic_defs]

    # Non-blocking input
    stdscr.nodelay(True)
    stdscr.timeout(0)

    # Center camera
    center_camera_on_player(model, stdscr, map_top_offset)

    def full_redraw(stdscr):
        stdscr.clear()
        draw_screen_frame(stdscr, "UI_CYAN")

        # Editor or inventory line
        if model.context.enable_editor_commands and model.editor_scenery_list:
            current_def_id = model.editor_scenery_list[model.editor_scenery_index][0]
            try:
                stdscr.addstr(
                    1, 2,
                    f"Editor Mode - Selected: {current_def_id}",
                    curses.color_pair(color_pairs["WHITE_TEXT"])
                )
            except:
                pass
        else:
            inv_text = (
                f"Inventory: Gold={model.player.gold}, "
                f"Wood={model.player.wood}, "
                f"Stone={model.player.stone}"
            )
            try:
                stdscr.addstr(
                    1, 2,
                    inv_text,
                    curses.color_pair(color_pairs["WHITE_TEXT"])
                )
            except:
                pass

        model.dirty_tiles.clear()

    model.full_redraw_needed = True

    while True:
        key = stdscr.getch()
        did_move = False

        # CAMERA
        max_scr_rows, max_scr_cols = stdscr.getmaxyx()
        visible_cols = max_scr_cols
        visible_rows = max_scr_rows - map_top_offset

        old_cam_x, old_cam_y = model.camera_x, model.camera_y
        model.camera_x, model.camera_y = update_camera_with_deadzone(
            model.player.x,
            model.player.y,
            model.camera_x,
            model.camera_y,
            visible_cols,
            visible_rows,
            model.world_width,
            model.world_height,
            dead_zone=2
        )

        dx = model.camera_x - old_cam_x
        dy = model.camera_y - old_cam_y

        if abs(dx) > 1 or abs(dy) > 1:
            model.full_redraw_needed = True
        else:
            if dy in (1, -1):
                partial_scroll_vertical(model, stdscr, dy, map_top_offset)
            if dx in (1, -1):
                partial_scroll_horizontal(model, stdscr, dx, map_top_offset)

        if key != -1:
            did_move, should_quit = handle_common_keys(key, model, stdscr, lambda x, y: mark_dirty(model, x, y))
            if should_quit:
                break

            model.full_redraw_needed = handle_editor_keys(
                key,
                model,
                stdscr,
                model.full_redraw_needed,
                lambda x, y: mark_dirty(model, x, y)
            )
            model.full_redraw_needed = handle_play_keys(
                key,
                model,
                model.full_redraw_needed,
                lambda x, y: mark_dirty(model, x, y)
            )

        # ENGINE UPDATES
        handle_network(model)
        update_npcs(model, lambda x, y: mark_dirty(model, x, y))
        handle_respawns(model, lambda x, y: mark_dirty(model, x, y))

        # Sliding
        if model.context.enable_sliding and not did_move:
            tile_def_id = get_scenery_def_id_at(
                model.player.x,
                model.player.y,
                model.placed_scenery
            )
            old_x, old_y = model.player.x, model.player.y
            apply_tile_effects(
                model.player,
                tile_def_id,
                model.placed_scenery,
                is_editor=model.context.enable_editor_commands,
                world_width=model.world_width,
                world_height=model.world_height
            )
            if (model.player.x, model.player.y) != (old_x, old_y):
                mark_dirty(model, old_x, old_y)
                mark_dirty(model, model.player.x, model.player.y)

        update_action_flash(model, lambda x, y: mark_dirty(model, x, y))
        handle_transitions(model, lambda x, y: mark_dirty(model, x, y))

        # DRAW
        if model.full_redraw_needed:
            full_redraw(stdscr)
            for wx in range(model.camera_x, min(model.camera_x + visible_cols, model.world_width)):
                for wy in range(model.camera_y, min(model.camera_y + visible_rows, model.world_height)):
                    model.dirty_tiles.add((wx, wy))
            model.full_redraw_needed = False

        update_partial_tiles_in_view(
            stdscr,
            model.player,
            model.placed_scenery,
            model.camera_x,
            model.camera_y,
            map_top_offset,
            model.dirty_tiles,
            action_flash_info=model.action_flash_info,
            world_width=model.world_width,
            world_height=model.world_height
        )
        model.dirty_tiles.clear()

        draw_layers(stdscr, model)
        manage_framerate(20)

==== File: engine_network.py ====
# FileName: engine_network.py
# version: 1.0
# Summary: Provides stubs or logic for multiplayer or network-driven interactions, sending/receiving game state.
# Tags: engine, network, multiplayer

def handle_network(model):
    """
    If you later want to add online or local co-op, 
    you'd handle sending/receiving data here each frame.
    """
    if not hasattr(model, 'network_state'):
        model.network_state = {'connected': False, 'host': None, 'port': None}
    
    # e.g. if model.network_state['connected']:
    #     # read incoming packets, update positions
    #     pass


==== File: engine_npc.py ====
# FileName: engine_npc.py
# version: 1.0
# Summary: Updates non-player characters, handling their AI states, movement, and any interactions with the world.
# Tags: engine, npc, ai

def update_npcs(model, mark_dirty_func):
    """
    If you have AI or NPC creatures, you'd loop through them and do pathfinding, 
    movement, or dialogue logic here.
    """
    if not hasattr(model, 'npcs'):
        model.npcs = []
    # for npc in model.npcs:
    #     npc.update_ai(...)
    #     mark_dirty_func(npc.old_x, npc.old_y)
    #     mark_dirty_func(npc.x, npc.y)


==== File: engine_render.py ====
# FileName: engine_render.py
# version: 3.2
# Summary: Renders terrain, objects, items, partial updates, and the player in layers.
#          - "floor" -> "objects" -> "items" -> then player
#          - If a tree trunk or top is on the player's tile, it is drawn last with a white background.
# Tags: engine, rendering, optimization

import curses
from color_init import color_pairs
from scenery_defs import (
    ALL_SCENERY_DEFS,
    TREE_TRUNK_ID,
    TREE_TOP_ID
)
from scenery_main import (
    FLOOR_TYPE_IDS,
    FLOOR_LAYER, OBJECTS_LAYER, ITEMS_LAYER, ENTITIES_LAYER
)


##############################################################################
# PART 1: Legacy color map for ASCII usage
##############################################################################
LEGACY_COLOR_MAP = {
    1:  "green_on_black",
    2:  "yellow_on_black",
    3:  "white_on_black",
    4:  "white_on_blue",
    5:  "white_on_green",
    7:  "green_on_white",
    8:  "black_on_yellow",
    12: "yellow_on_black",
    16: "white_on_black",
    17: "red_on_black",
    # etc.
}

##############################################################################
# PART 2: LAYERED RENDER
##############################################################################
RENDER_MODE = "ascii"


def _build_color_attr(fg_index, bg_name):
    """
    Given a numeric 'ascii_color' or 'color_pair' for the foreground,
    and a string color name for the background (e.g. "black", "blue", "green"),
    create a curses attribute that merges them.
    """
    # Look up the base color name
    base_color = LEGACY_COLOR_MAP.get(fg_index, "white_on_black")
    splitted = base_color.split("_on_")
    if len(splitted) == 2:
        fg_part, _ = splitted
    else:
        fg_part = "white"

    # final "fg_part_on_bg_name"
    final_name = f"{fg_part}_on_{bg_name}"
    pair_id = color_pairs.get(final_name, 0)
    return curses.color_pair(pair_id)


def _render_one_ascii(stdscr, x_screen, y_screen, ascii_char, attr):
    """
    Safely render a single character with the given curses attribute at (y_screen, x_screen).
    """
    max_h, max_w = stdscr.getmaxyx()
    if 0 <= x_screen < max_w and 0 <= y_screen < max_h:
        try:
            stdscr.addch(y_screen, x_screen, ascii_char, attr)
        except curses.error:
            pass


def _draw_floor(stdscr, floor_obj, sx, sy):
    if floor_obj is None:
        return
    info = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {})
    ch = info.get("ascii_char", floor_obj.char)
    fg_index = info.get("ascii_color", floor_obj.color_pair)

    # The floor uses its own background color (from legacy_color_map).
    base_color = LEGACY_COLOR_MAP.get(fg_index, "white_on_black")
    pair_id = color_pairs.get(base_color, 0)
    attr = curses.color_pair(pair_id)

    _render_one_ascii(stdscr, sx, sy, ch, attr)


def _draw_object(stdscr, obj, sx, sy, floor_fg_index):
    """
    Draw a single object with:
      - object’s foreground color
      - the floor’s background color
    Except for TREE_TOP_ID, which always uses green_on_black so it doesn't vanish on grass.
    """
    info = ALL_SCENERY_DEFS.get(obj.definition_id, {})
    ch = info.get("ascii_char", obj.char)
    obj_fg_index = info.get("ascii_color", obj.color_pair)

    # Special case: Tree top always green_on_black, ignoring floor
    if obj.definition_id == TREE_TOP_ID:
        top_color_name = LEGACY_COLOR_MAP.get(obj_fg_index, "green_on_black")  
        pair_id = color_pairs.get(top_color_name, 0)
        attr = curses.color_pair(pair_id)
        _render_one_ascii(stdscr, sx, sy, ch, attr)
        return

    # Normal objects => use the floor's background
    floor_base = LEGACY_COLOR_MAP.get(floor_fg_index, "white_on_black")
    parts = floor_base.split("_on_")
    if len(parts) == 2:
        floor_bg = parts[1]
    else:
        floor_bg = "black"

    attr = _build_color_attr(obj_fg_index, floor_bg)
    _render_one_ascii(stdscr, sx, sy, ch, attr)


def _draw_items(stdscr, items_list, sx, sy, floor_fg_index):
    for it in items_list:
        _draw_object(stdscr, it, sx, sy, floor_fg_index)


def _draw_entities(stdscr, entities_list, sx, sy, floor_fg_index):
    for ent in entities_list:
        _draw_object(stdscr, ent, sx, sy, floor_fg_index)


def mark_dirty(model, x, y):
    model.dirty_tiles.add((x, y))


def update_partial_tiles_in_view(
    stdscr,
    player,
    placed_scenery,
    camera_x,
    camera_y,
    map_top_offset,
    dirty_tiles,
    action_flash_info=None,
    world_width=100,
    world_height=60
):
    """
    Only re-draw the (x,y) in dirty_tiles, by layering approach:
      floor -> objects -> items -> entities
    We'll skip drawing tree trunk/tops if the player is on that tile,
    so we can handle them specially after the player is drawn.
    """
    max_h, max_w = stdscr.getmaxyx()
    player_wx, player_wy = player.x, player.y

    for (wx, wy) in dirty_tiles:
        if not (0 <= wx < world_width and 0 <= wy < world_height):
            continue

        sx = wx - camera_x
        sy = wy - camera_y + map_top_offset
        if sx < 0 or sy < 0 or sx >= max_w or sy >= max_h:
            continue

        # Clear/blank first
        blank_attr = curses.color_pair(color_pairs.get("white_on_black", 0))
        try:
            stdscr.addch(sy, sx, " ", blank_attr)
        except curses.error:
            pass

        tile_layers = placed_scenery.get((wx, wy), None)
        if not tile_layers:
            # No tile => black
            continue

        # 1) draw floor
        floor_obj = tile_layers.get(FLOOR_LAYER)
        _draw_floor(stdscr, floor_obj, sx, sy)

        # We need floor's ascii_color to pass as "background" to objects/items
        floor_info = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {}) if floor_obj else {}
        floor_fg_index = floor_info.get("ascii_color", floor_obj.color_pair if floor_obj else 0)

        # 2) draw objects (except trunk/top if player is here)
        objects_list = tile_layers.get(OBJECTS_LAYER, [])
        for obj in objects_list:
            if obj.definition_id in (TREE_TRUNK_ID, TREE_TOP_ID):
                # If the player is on the same tile, we skip for now
                # so we can handle it in draw_layers (which draws it last).
                if (wx, wy) == (player_wx, player_wy):
                    continue
            _draw_object(stdscr, obj, sx, sy, floor_fg_index)

        # 3) draw items
        items_list = tile_layers.get(ITEMS_LAYER, [])
        _draw_items(stdscr, items_list, sx, sy, floor_fg_index)

        # 4) draw entities
        ent_list = tile_layers.get(ENTITIES_LAYER, [])
        _draw_entities(stdscr, ent_list, sx, sy, floor_fg_index)

        # action flash, if any, can be drawn here if you want
        # (omitted for brevity)


def draw_layers(stdscr, model):
    """
    After partial updates. The player is drawn (normally) last, so it appears
    above objects – except for tree trunk/tops if the user is on that tile,
    which we specifically draw after the player to simulate "behind the tree."

    The player's background always uses the floor tile's background color,
    ignoring objects on that tile (like a bridge post).
    """
    # 1) Draw the player normally
    px = model.player.x - model.camera_x
    py = model.player.y - model.camera_y + 3
    max_h, max_w = stdscr.getmaxyx()
    if 0 <= px < max_w and 0 <= py < max_h:
        tile_layers = model.placed_scenery.get((model.player.x, model.player.y), None)
        if tile_layers:
            floor_obj = tile_layers.get(FLOOR_LAYER)
            if floor_obj:
                floor_info = ALL_SCENERY_DEFS.get(floor_obj.definition_id, {})
                floor_fg_index = floor_info.get("ascii_color", floor_obj.color_pair)
            else:
                floor_fg_index = 0

            # build "white_on_<floor_bg>" for the player's color
            floor_base = LEGACY_COLOR_MAP.get(floor_fg_index, "white_on_black")
            parts = floor_base.split("_on_")
            if len(parts) == 2:
                floor_bg = parts[1]
            else:
                floor_bg = "black"

            # The player's foreground is white, background = floor_bg
            color_name = f"white_on_{floor_bg}"
            pair_id = color_pairs.get(color_name, 0)
            attr = curses.color_pair(pair_id) | curses.A_BOLD

            # Draw the player '@'
            try:
                stdscr.addch(py, px, "@", attr)
            except curses.error:
                pass

    # 2) If there's a tree trunk or top in the player's tile, draw it on top with white background
    #    to simulate the player being "behind" the tree.
    tile_layers = model.placed_scenery.get((model.player.x, model.player.y), None)
    if tile_layers:
        objects_list = tile_layers.get(OBJECTS_LAYER, [])
        trunk_or_top = [obj for obj in objects_list if obj.definition_id in (TREE_TRUNK_ID, TREE_TOP_ID)]
        if trunk_or_top:
            # We forcibly draw them again, using a white background
            for obj in trunk_or_top:
                obj_info = ALL_SCENERY_DEFS.get(obj.definition_id, {})
                ch = obj_info.get("ascii_char", obj.char)
                fg_index = obj_info.get("ascii_color", obj.color_pair)

                # We want to keep the original object's foreground but place background = white
                base_color = LEGACY_COLOR_MAP.get(fg_index, "white_on_black")
                parts = base_color.split("_on_")
                if len(parts) == 2:
                    obj_fg = parts[0]
                else:
                    obj_fg = "white"
                final_color = f"{obj_fg}_on_white"
                pair_id = color_pairs.get(final_color, 0)
                attr = curses.color_pair(pair_id)
                try:
                    stdscr.addch(py, px, ch, attr)
                except curses.error:
                    pass

==== File: engine_respawn.py ====
# FileName: engine_respawn.py
# version: 1.1
# Summary: Tracks and respawns resources (trees, rocks) or other entities after a set timer.
# Tags: engine, respawn, resources

from scenery_main import SceneryObject
# We import the dictionary-friendly helper:
from scenery_main import _append_scenery

def handle_respawns(model, mark_dirty_func):
    """
    If context.enable_respawn is true, decrement countdowns and respawn scenery.
    Each entry in model.respawn_list is a dict like:
      { "countdown": N, "objects": [(sx, sy, schar, scolor), ...] }
    Once countdown <= 0, we respawn those objects at (sx, sy).
    """
    if not model.context.enable_respawn:
        return

    # We copy the list so we can safely remove entries while iterating
    for r in model.respawn_list[:]:
        r["countdown"] -= 1
        if r["countdown"] <= 0:
            # Time to respawn these objects
            for (sx, sy, schar, scolor) in r["objects"]:
                new_obj = SceneryObject(sx, sy, schar, scolor)
                # Instead of model.placed_scenery.append(...), we do:
                _append_scenery(model.placed_scenery, new_obj)
                mark_dirty_func(sx, sy)

            # Remove this entry from respawn_list now that we've respawned
            model.respawn_list.remove(r)

==== File: engine_transition.py ====
# FileName: engine_transition.py
# version: 1.0
# Summary: Handles scene/area transitions triggered by stepping on special tiles or meeting conditions.
# Tags: engine, transitions

def handle_transitions(model, mark_dirty_func):
    """
    For now, this function does nothing. In the future, you can:
      - track a 'current_transition' in model
      - fade screen in/out
      - animate scene changes
    """
    if not hasattr(model, 'transition_state'):
        # Could store e.g. model.transition_state = {'active': False, 'alpha': 0}
        model.transition_state = {'active': False, 'timer': 0}

    # Example usage:
    # If model.transition_state['active']:
    #     # do alpha fade, reduce timer, etc.
    #     mark_dirty_func(...) as needed
    pass


==== File: model_main.py ====
# FileName: model_main.py
# version: 1.0
# Summary: Defines the GameModel class storing player, scenery, camera, and other state needed for the engine.
# Tags: model, data, state

class GameModel:
    def __init__(self):
        # Core references
        self.player = None

        # Instead of a list, store a dictionary for placed_scenery
        # so collisions and rendering see the same data structure.
        # Example: (x, y) -> [SceneryObject, SceneryObject, ...]
        self.placed_scenery = {}

        # World geometry
        self.world_width = 100
        self.world_height = 60

        # Context (play vs. editor settings)
        self.context = None

        # Respawn logic (for trees, rocks, etc.)
        self.respawn_list = []

        # Editor-related fields
        self.editor_scenery_list = []
        self.editor_scenery_index = 0

        # [ADDED for Undo] Track recently placed objects for undo
        self.editor_undo_stack = []

        # Camera and rendering
        self.camera_x = 0
        self.camera_y = 0
        self.dirty_tiles = set()
        self.action_flash_info = None
        self.full_redraw_needed = True

==== File: debug.py ====
# FileName: debug.py
# version: 1.0
# Summary: Holds global debugging flags and configuration toggles (speed multipliers, log verbosity, etc.).
# Tags: debug, config, developer

DEBUG_CONFIG = {
    "enabled":              False,
    "ignore_collisions":    False,
    "walk_speed_multiplier": 1,
    # You can add more debug features here in the future.
}


def toggle_debug():
    """
    Toggle the global debug configuration on/off. 
    When 'enabled' is True, we set all desired debug features. 
    When 'enabled' is False, we revert them to normal.
    """
    DEBUG_CONFIG["enabled"] = not DEBUG_CONFIG["enabled"]
    if DEBUG_CONFIG["enabled"]:
        # Enable debug features
        DEBUG_CONFIG["ignore_collisions"] = True
        DEBUG_CONFIG["walk_speed_multiplier"] = 4  # Walk 2x faster
    else:
        # Disable debug features
        DEBUG_CONFIG["ignore_collisions"] = False
        DEBUG_CONFIG["walk_speed_multiplier"] = 1

==== File: entities_main.py ====
# FileName: entities_main.py
# version: 1.0
# Summary: Defines entity logic or classes for monsters, NPCs, or interactive objects in the game world.
# Tags: entities, ai, monster, npc

class Monster:
    def __init__(self, x, y, name="Goblin"):
        self.x = x
        self.y = y
        self.name = name
        self.hp = 10
        self.attack = 2
        self.defense = 1

    def take_damage(self, amount):
        self.hp -= amount
        if self.hp <= 0:
            # monster dies
            pass

class Item:
    def __init__(self, x, y, item_type="potion"):
        self.x = x
        self.y = y
        self.item_type = item_type

    def on_pickup(self, player):
        pass

==== File: items_main.py ====
# FileName: items_main.py
# version: 1.0
# Summary: Manages item definitions, handling creation, inventory, usage effects, or item-based interactions.
# Tags: items, gameplay, inventory


##############################################################################
# 1) Item Registry
##############################################################################

ALL_ITEMS = {
    "BasicSword": {
        "slot": "weapon",
        "bonus_stats": {"attack": 2}
    },
    "HealingPotion": {
        "consumable": True,
        "use_func": "heal_20hp"
    },
    "IronArmor": {
        "slot": "armor",
        "bonus_stats": {"defense": 3}
    },
    # Add more items as needed
}

##############################################################################
# 2) ItemInstance class
##############################################################################

class ItemInstance:
    """
    Represents one "instance" of an item in a player's inventory.
    - definition_id => key in ALL_ITEMS
    - instance_data => dict for overrides (e.g. custom name, color, etc.)

    Example usage:
        sword = ItemInstance("BasicSword", {"custom_name": "Sword of Fire", "attack_bonus": 5})
    """
    def __init__(self, definition_id, instance_data=None):
        self.definition_id = definition_id
        if instance_data is None:
            instance_data = {}
        self.instance_data = instance_data  # Could store durability, enchantments, etc.

    @property
    def base_def(self):
        """
        Returns the base item definition from ALL_ITEMS.
        e.g. base_def["slot"], base_def["consumable"], etc.
        """
        return ALL_ITEMS.get(self.definition_id, {})

    def get_slot(self):
        """
        Returns the equip slot if any. e.g. "weapon", "armor", or None
        """
        return self.base_def.get("slot")

    def is_consumable(self):
        """
        Returns True if item is consumable, else False
        """
        return self.base_def.get("consumable", False)

    def get_bonus_stats(self):
        """
        Combine base_def's bonus_stats with any instance overrides.
        e.g. base bonus_stats => {"attack":2}, instance_data => {"attack_bonus":5}
        """
        base = self.base_def.get("bonus_stats", {})
        # Merge with instance_data keys if relevant
        # For example, instance_data might store extra bonus points
        combined = dict(base)  # shallow copy
        # If we have "attack_bonus" in instance_data, add it to combined
        if "attack_bonus" in self.instance_data:
            combined["attack"] = combined.get("attack", 0) + self.instance_data["attack_bonus"]
        return combined

    def __repr__(self):
        return f"<ItemInstance({self.definition_id}, data={self.instance_data})>"


==== File: map_io_main.py ====
# FileName: map_io_main.py
# version: 3.2
# Summary: Handles raw map data reading/writing (JSON) and structure building, no curses or UI logic.
# Tags: map, io

import os
import json

from map_io_storage import parse_map_dict, load_map_file, save_map_file

def load_map_data(filename):
    """
    Loads map data (JSON) from the given filename as a Python dict.
    Returns the loaded dict or None on failure.
    """
    try:
        return load_map_file(filename)
    except:
        return None

def build_map_data(placed_scenery, player=None, world_width=100, world_height=100):
    """
    Builds a Python dict representing the map data, with optional player
    coordinates and the given world dimensions. 'placed_scenery' can be:
      1) A dict-of-lists keyed by (x,y), each list is SceneryObjects;
      2) A dict-of-dicts keyed by (x,y), each dict is layered data
         (e.g. { 'floor': obj, 'objects': [...], ... });
      3) A simple list of SceneryObjects.

    This function now gracefully skips any entries that are
    not valid SceneryObjects (e.g. a stray string).
    """
    map_data = {
        "world_width": world_width,
        "world_height": world_height,
        "scenery": []
    }

    if player is not None:
        map_data["player_x"] = player.x
        map_data["player_y"] = player.y

    # Helper function to safely add an object to map_data["scenery"]
    def add_scenery_obj(obj):
        if hasattr(obj, "x") and hasattr(obj, "y") and hasattr(obj, "definition_id"):
            map_data["scenery"].append({
                "x": obj.x,
                "y": obj.y,
                "definition_id": obj.definition_id
            })

    # Convert placed_scenery to a list of dicts
    if isinstance(placed_scenery, dict):
        # We expect keys like (x, y), values can be either a list or a layered dict
        for (tile_x, tile_y), tile_data in placed_scenery.items():
            if isinstance(tile_data, list):
                # Old-style: list of objects
                for obj in tile_data:
                    add_scenery_obj(obj)
            elif isinstance(tile_data, dict):
                # Possibly layered data, e.g. { "floor": ..., "objects": [...], "items": [...], ... }
                for layer_key, layer_val in tile_data.items():
                    if isinstance(layer_val, list):
                        # e.g. "objects" => a list of objects
                        for obj in layer_val:
                            add_scenery_obj(obj)
                    else:
                        # e.g. "floor" => single object
                        add_scenery_obj(layer_val)
            else:
                # If it's neither a list nor a dict, skip (e.g. a stray string)
                pass

    else:
        # If it's just a list, assume it's a list of objects
        for obj in placed_scenery:
            add_scenery_obj(obj)

    return map_data


==== File: map_io_storage.py ====
# FileName: map_io_storage.py
# version: 1.1
# Summary: Handles the underlying JSON I/O logic for parsing and serializing map files, separate from UI code.
# Tags: map, io, storage

import os
import json

def parse_map_dict(raw_dict):
    """
    Takes a raw dictionary from JSON and extracts:
      world_width, world_height, scenery, extras
    ignoring any 'player' keys.
    """
    world_width = raw_dict.get("world_width", 100)
    world_height = raw_dict.get("world_height", 60)
    scenery = raw_dict.get("scenery", [])

    known_keys = {"world_width", "world_height", "scenery", "player_x", "player_y", "player"}
    extras = {}
    for k, v in raw_dict.items():
        if k not in known_keys:
            extras[k] = v

    return {
        "world_width": world_width,
        "world_height": world_height,
        "scenery": scenery,
        "extras": extras
    }

def load_map_file(filepath):
    """
    Reads a JSON file from 'filepath' and returns the parsed dict.
    Returns None if there's an error.
    """
    if not os.path.exists(filepath):
        return None
    try:
        with open(filepath, "r") as f:
            data = json.load(f)
        return data
    except:
        return None

def save_map_file(filepath, map_data):
    """
    Writes 'map_data' (a dict with world_width, world_height, scenery, etc.)
    to JSON at 'filepath'. Ignores errors.
    """
    try:
        with open(filepath, "w") as f:
            json.dump(map_data, f)
    except:
        pass

==== File: map_io_ui.py ====
# FileName: map_io_ui.py
# version: 2.7
# Summary: Contains curses-based UI routines (map list, save prompts, load prompts).
#          Now does no text on overwrite, just a 500ms nap if `notify_overwrite=True`.
# Tags: map, ui, io

import curses
import os

from color_init import init_colors, color_pairs
from ui_main import (
    draw_screen_frame,
    draw_title,
    draw_art,
    draw_instructions
)
from art_main import CROCODILE
from highlight_selector import draw_global_selector_line


def draw_load_map_screen(stdscr):
    stdscr.clear()
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)
    draw_screen_frame(stdscr)
    draw_title(stdscr, "Load Map", row=1)
    draw_art(stdscr, CROCODILE, start_row=3, start_col=2, color_name="ASCII_ART")

    instructions = [
        "↑/↓ = select, ENTER=load, 'd'=del, 'q'=back, 'v'=toggle debug"
    ]
    draw_instructions(stdscr, instructions, from_bottom=3, color_name="UI_YELLOW")


def draw_save_map_screen(stdscr):
    stdscr.clear()
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)
    draw_screen_frame(stdscr)
    draw_title(stdscr, "Save Map", row=1)
    draw_art(stdscr, CROCODILE, start_row=3, start_col=2, color_name="ASCII_ART")

    instructions = [
        "Select a map to overwrite, 'n'=new, 'ENTER'=cancel, 'v'=toggle debug"
    ]
    draw_instructions(stdscr, instructions, from_bottom=3, color_name="UI_YELLOW")


def prompt_for_filename(stdscr, prompt):
    init_colors()
    draw_save_map_screen(stdscr)
    max_h, max_w = stdscr.getmaxyx()
    row = 10
    if row < max_h - 1:
        stdscr.refresh()
        stdscr.addstr(row, 2, prompt, curses.color_pair(color_pairs["UI_CYAN"]))
        stdscr.refresh()
        curses.echo()
        filename_bytes = stdscr.getstr(row, 2 + len(prompt) + 1, 20)
        curses.noecho()
        if filename_bytes:
            return filename_bytes.decode('utf-8', errors='ignore').strip()
    return ""


def display_map_list(stdscr):
    init_colors()
    maps_dir = "maps"
    if not os.path.isdir(maps_dir):
        os.makedirs(maps_dir, exist_ok=True)

    files = [f for f in os.listdir(maps_dir) if f.endswith(".json")]
    files.sort()
    files.insert(0, "0) Generate a new map>")

    selected_index = 0
    frame_count = 0

    while True:
        draw_load_map_screen(stdscr)
        max_h, max_w = stdscr.getmaxyx()
        row = 10

        for i, fname in enumerate(files):
            if row >= max_h - 2:
                break
            if i == 0:
                display_text = "Generate a new map"
            else:
                display_text = f"{i}) {fname}"

            is_sel = (i == selected_index)
            draw_global_selector_line(
                stdscr,
                row,
                f"> {display_text}" if is_sel else f"  {display_text}",
                is_selected=is_sel,
                frame=frame_count
            )
            row += 1

        stdscr.refresh()
        key = stdscr.getch()
        if key in (curses.KEY_UP, ord('w'), ord('W')):
            selected_index = max(0, selected_index - 1)
        elif key in (curses.KEY_DOWN, ord('s'), ord('S')):
            selected_index = min(len(files) - 1, selected_index + 1)
        elif key in (curses.KEY_ENTER, 10, 13):
            if selected_index == 0:
                return "GENERATE"
            else:
                return files[selected_index]
        elif key in (ord('q'), ord('y')):
            return ""
        elif key == ord('e'):
            if selected_index == 0:
                return ("EDIT_GENERATE", None)
            else:
                return ("EDIT", files[selected_index])
        elif key == ord('v'):
            import debug
            debug.toggle_debug()
        elif ord('0') <= key <= ord('9'):
            typed = key - ord('0')
            if 0 <= typed < len(files):
                selected_index = typed

        if len(files) == 1:
            selected_index = 0

        frame_count += 1


def display_map_list_for_save(stdscr):
    init_colors()
    maps_dir = "maps"
    if not os.path.isdir(maps_dir):
        os.makedirs(maps_dir, exist_ok=True)

    files = [f for f in os.listdir(maps_dir) if f.endswith(".json")]
    files.sort()

    while True:
        draw_save_map_screen(stdscr)
        max_h, max_w = stdscr.getmaxyx()
        row = 10

        if files:
            stdscr.refresh()
            try:
                stdscr.addstr(
                    row, 2,
                    "Maps (pick number to overwrite) or 'n' for new, 'v' toggles debug:",
                    curses.color_pair(color_pairs["UI_CYAN"])
                )
            except:
                pass
            row += 1
            for i, filename in enumerate(files, start=1):
                if row >= max_h - 1:
                    break
                try:
                    stdscr.addstr(row, 2, f"{i}. {filename}",
                                  curses.color_pair(color_pairs["UI_YELLOW"]))
                except:
                    pass
                row += 1
            if row < max_h - 1:
                try:
                    stdscr.addstr(row, 2,
                                  "Enter choice or press Enter to cancel:",
                                  curses.color_pair(color_pairs["UI_CYAN"]))
                except:
                    pass
                row += 1
        else:
            stdscr.refresh()
            try:
                stdscr.addstr(
                    row, 2,
                    "No existing maps. Press 'n' to create new, 'v' toggles debug, or Enter to cancel:",
                    curses.color_pair(color_pairs["UI_CYAN"])
                )
            except:
                pass
            row += 1

        stdscr.refresh()
        try:
            if row < max_h:
                selection_bytes = stdscr.getstr(row, 2, 20)
                if not selection_bytes:
                    return ""
                selection = selection_bytes.decode('utf-8').strip()
            else:
                return ""

            if not selection:
                return ""
            if selection.lower() == 'n':
                return "NEW_FILE"
            elif selection.lower() == 'v':
                import debug
                debug.toggle_debug()
                continue
            elif selection.isdigit():
                idx = int(selection) - 1
                if 0 <= idx < len(files):
                    return files[idx]
        except:
            pass


def load_map_ui(stdscr):
    selection = display_map_list(stdscr)
    if not selection:
        return ""
    if selection == "GENERATE":
        from procedural_map_generator.generator import generate_procedural_map
        return generate_procedural_map()
    if isinstance(selection, tuple):
        if selection[0] == "EDIT_GENERATE":
            from procedural_map_generator.generator import generate_procedural_map
            data = generate_procedural_map()
            return ("EDIT_GENERATE", data)
        elif selection[0] == "EDIT":
            return ("EDIT", selection[1])
        return ""
    return selection


def save_map_ui(stdscr, placed_scenery, player=None,
                world_width=100, world_height=100,
                filename_override=None,
                notify_overwrite=False):
    """
    notify_overwrite=True => if a file is being overwritten, do a 500ms nap (no text).
    notify_overwrite=False => skip any nap or notification.
    """
    import map_io_main
    from map_io_storage import save_map_file

    if filename_override:
        filename = filename_override
    else:
        overwrite_or_new = display_map_list_for_save(stdscr)
        if not overwrite_or_new:
            return  # user canceled
        if overwrite_or_new == "NEW_FILE":
            filename = prompt_for_filename(stdscr, "Enter filename to save as: ")
            if not filename:
                return
            if not filename.endswith(".json"):
                filename += ".json"
        else:
            filename = overwrite_or_new

    maps_dir = "maps"
    if not os.path.isdir(maps_dir):
        os.makedirs(maps_dir, exist_ok=True)

    save_path = os.path.join(maps_dir, filename)
    file_existed = os.path.exists(save_path)

    map_data = map_io_main.build_map_data(
        placed_scenery,
        player=player,
        world_width=world_width,
        world_height=world_height
    )

    # Actually save the file
    save_map_file(save_path, map_data)

    # if overwriting
    if file_existed and notify_overwrite:
        # just do a 500ms nap, no text
        curses.napms(500)
    # else no message or nap

def ask_save_generated_map_ui(stdscr, placed_scenery, world_width, world_height, player=None):
    """
    Disabled to avoid a second "save generated map?" prompt.
    """
    return

==== File: play_main.py ====
# FileName: play_main.py
# version: 2.2
# Summary: Top-level function for entering Play mode, linking user’s map choice to the engine loop.
# Tags: play, main, engine

import curses
from map_io_ui import load_map_ui  # CHANGED: we now import from map_io_ui
from play_runner import parse_and_run_play


def play_main(stdscr):
    """
    Called when user chooses "Play" from main menu.
    We always load a map in play mode, then inside the game,
    you can press 'e' to toggle to the editor if desired.
    """
    while True:
        selection = load_map_ui(stdscr)  # formerly load_map(stdscr) from map_io_main
        if not selection:
            # user canceled => back to main menu
            return

        # If load_map_ui returns a tuple (e.g. ("EDIT", filename)),
        # we pass the second item into parse_and_run_play.
        if isinstance(selection, tuple):
            action_type, actual_map = selection[0], selection[1]
            if action_type == "EDIT_GENERATE":
                parse_and_run_play(stdscr, actual_map, is_generated=True)
            else:
                # e.g. ("EDIT", "filename")
                parse_and_run_play(stdscr, actual_map, is_generated=False)
        elif isinstance(selection, dict):
            # user chose "Generate a new map" => run in play mode
            parse_and_run_play(stdscr, selection, is_generated=True)
        else:
            # user picked an existing file => play mode
            parse_and_run_play(stdscr, selection, is_generated=False)

==== File: play_runner.py ====
# FileName: play_runner.py
# version: 2.0 (updated to fix player position bug)
# Summary: Orchestrates map loading (parse_and_run_play/editor), calling engine_main for either mode.
# Tags: play, runner, map, editor

import os
import json
import curses

from player_char import Player
from player_char_io import load_player, save_player
from scenery_main import SceneryObject
from engine_main import run_engine, GameContext

# We'll import parse_map_dict directly from map_io_storage:
from map_io_storage import parse_map_dict, load_map_file

# For UI-based saving logic:
from map_io_ui import save_map_ui, ask_save_generated_map_ui

def parse_and_run_editor(stdscr, filename_or_data, is_generated=False):
    """
    If filename_or_data is a dict => parse the map data directly,
    else load the JSON map from disk => parse => run editor mode.

    After the editor exits, we always save player data.
    If this map was generated, we also prompt if they want to save scenery.
    """
    # 1) Load or parse raw map data
    if isinstance(filename_or_data, dict):
        raw_data = filename_or_data
        model_filename = None
    else:
        model_filename = filename_or_data
        maps_dir = "maps"
        load_path = os.path.join(maps_dir, filename_or_data)
        try:
            with open(load_path, "r") as f:
                raw_data = json.load(f)
        except:
            return

    # 2) Convert raw dict -> structured map_data
    map_data = parse_map_dict(raw_data)
    world_width = map_data["world_width"]
    world_height = map_data["world_height"]
    sinfo = map_data["scenery"]

    # 3) Load or create the Player
    player = load_player()
    if not player:
        player = Player()

    # 4) If newly generated, center player. Otherwise, if map_data has coords, use them.
    if is_generated:
        player.x = world_width // 2
        player.y = world_height // 2
    else:
        px = raw_data.get("player_x", None)
        py = raw_data.get("player_y", None)
        if px is not None and py is not None:
            player.x = px
            player.y = py

    # 5) Clamp
    player.x = max(0, min(player.x, world_width - 1))
    player.y = max(0, min(player.y, world_height - 1))

    # 6) Build placed_scenery as a dict-of-lists
    placed_scenery = {}
    for s in sinfo:
        if "definition_id" in s:
            x, y = s["x"], s["y"]
            obj = SceneryObject(x, y, s["definition_id"])
            placed_scenery.setdefault((x, y), []).append(obj)

    # 7) Run the engine in 'editor' mode
    context = GameContext(mode_name="editor")
    run_engine(
        stdscr,
        context,
        player,
        placed_scenery,
        respawn_list=None,
        map_top_offset=3,
        world_width=world_width,
        world_height=world_height,
        loaded_map_filename=None if is_generated else model_filename
    )

    # 8) After user quits, save the player data globally
    save_player(player)

    # 8.5) If this was a non-generated map, automatically update the map's JSON with new coords
    if (not is_generated) and model_filename:
        maps_dir = "maps"
        map_path = os.path.join(maps_dir, model_filename)
        from map_io_main import load_map_data
        from map_io_storage import save_map_file

        existing_data = load_map_data(map_path)
        if existing_data:
            existing_data["player_x"] = player.x
            existing_data["player_y"] = player.y
            save_map_file(map_path, existing_data)

    # 9) If it's a generated map, prompt for saving
    if is_generated:
        ask_save_generated_map_ui(stdscr, placed_scenery, world_width, world_height, player=player)

def parse_and_run_play(stdscr, filename_or_data, is_generated=False):
    """
    If it's a dict => parse directly (generated map),
    else load from file => parse => run "play" mode.

    After the user exits, we always save player data.
    If this map was generated, prompt to save scenery.
    """
    if isinstance(filename_or_data, dict):
        raw_data = filename_or_data
        model_filename = None
    else:
        model_filename = filename_or_data
        maps_dir = "maps"
        load_path = os.path.join(maps_dir, filename_or_data)
        try:
            with open(load_path, "r") as f:
                raw_data = json.load(f)
        except:
            return

    map_data = parse_map_dict(raw_data)
    world_width = map_data["world_width"]
    world_height = map_data["world_height"]
    sinfo = map_data["scenery"]

    # 1) Load or create the Player
    player = load_player()
    if not player:
        player = Player()

    # 2) If newly generated, center. Else, if coords exist in file, use them.
    if is_generated:
        player.x = world_width // 2
        player.y = world_height // 2
    else:
        px = raw_data.get("player_x", None)
        py = raw_data.get("player_y", None)
        if px is not None and py is not None:
            player.x = px
            player.y = py

    # 3) Clamp
    player.x = max(0, min(player.x, world_width - 1))
    player.y = max(0, min(player.y, world_height - 1))

    # 4) Build placed_scenery
    placed_scenery = {}
    for s in sinfo:
        if "definition_id" in s:
            x, y = s["x"], s["y"]
            obj = SceneryObject(x, y, s["definition_id"])
            placed_scenery.setdefault((x, y), []).append(obj)

    # 5) Run the engine in 'play' mode
    ctx = GameContext(mode_name="play")
    run_engine(
        stdscr,
        ctx,
        player,
        placed_scenery,
        respawn_list=[],
        map_top_offset=3,
        world_width=world_width,
        world_height=world_height,
        loaded_map_filename=None if is_generated else model_filename
    )

    # 6) Once user quits, save the Player globally
    save_player(player)

    # 6.5) For a non-generated map, also update that map's JSON with the new coords
    if (not is_generated) and model_filename:
        maps_dir = "maps"
        map_path = os.path.join(maps_dir, model_filename)
        from map_io_main import load_map_data
        from map_io_storage import save_map_file

        existing_data = load_map_data(map_path)
        if existing_data:
            existing_data["player_x"] = player.x
            existing_data["player_y"] = player.y
            save_map_file(map_path, existing_data)

    # 7) If it's a generated map, prompt to save scenery
    if is_generated:
        ask_save_generated_map_ui(stdscr, placed_scenery, world_width, world_height, player=player)

==== File: player_char.py ====
# FileName: player_char.py
# version: 1.2
# Summary: Defines the Player class with movement, stats, and inventory fields used in the game engine.
# Tags: player, character, movement

import debug
from scenery_main import is_blocked

class Player:
    def __init__(
        self,
        x=0,
        y=0,
        name="Hero",
        hp=100,
        level=1,
        char="@"
    ):
        """
        A unified Player constructor that supports position, name, hp, level,
        plus a 'char' attribute for rendering.

        If you'd like to load 'char' from JSON, simply add it to your load/save logic.
        """
        self.x = x
        self.y = y
        self.name = name
        self.hp = hp
        self.level = level

        # The character used when drawing the player on-screen
        self.char = char

        # Common resource stats
        self.gold = 0
        self.wood = 0
        self.stone = 0

        # Inventory system (list), and equipment slots (dict)
        self.inventory = []
        self.equipped = {}

        # Last movement direction
        self.last_move_direction = None

    def add_item(self, item_instance):
        """
        Add an item_instance (from items_main.ItemInstance) to the player's inventory.
        """
        self.inventory.append(item_instance)

    def move(self, direction, world_width, world_height, placed_scenery):
        """
        Move the player by 1 tile in the given direction (up/down/left/right).
        If debug mode is ON & ignore_collisions is True, skip collision checks.
        Otherwise, do normal collision blocking.
        """
        dx, dy = 0, 0
        if direction == "up":
            dy = -1
            self.last_move_direction = "up"
        elif direction == "down":
            dy = 1
            self.last_move_direction = "down"
        elif direction == "left":
            dx = -1
            self.last_move_direction = "left"
        elif direction == "right":
            dx = 1
            self.last_move_direction = "right"

        new_x = self.x + dx
        new_y = self.y + dy

        # Clamp to world boundaries
        new_x = max(0, min(new_x, world_width - 1))
        new_y = max(0, min(new_y, world_height - 1))

        # If debug mode is ON and ignore_collisions is True, skip collision checks
        if debug.DEBUG_CONFIG["enabled"] and debug.DEBUG_CONFIG["ignore_collisions"]:
            self.x = new_x
            self.y = new_y
        else:
            # Normal collision check
            if not is_blocked(new_x, new_y, placed_scenery):
                self.x = new_x
                self.y = new_y

==== File: player_char_io.py ====
# FileName: player_char_io.py
# version: 2.1
# Summary: Persists or loads player data (stats, position) to/from JSON files, ensuring continuity of progress.
# Tags: player, io

"""
Handles saving/loading the Player object to JSON (single file),
stored in a "character" subfolder.

No partial merges. We overwrite the JSON with the current data
whenever we save.
"""

import os
import json

from items_main import ItemInstance
from player_char import Player

CHARACTER_FOLDER = "character"
CHARACTER_FILE = os.path.join(CHARACTER_FOLDER, "character_data.json")

def save_player(player, filename=CHARACTER_FILE):
    """
    Write player's data to 'filename' as JSON.

    This includes:
      - name, hp, level
      - x, y (map position)
      - gold, wood, stone
      - entire inventory (list of items)
      - equipped items
    """
    # Ensure the "character" folder exists
    os.makedirs(CHARACTER_FOLDER, exist_ok=True)

    data = {
        "name": player.name,
        "hp": player.hp,
        "level": player.level,
        "x": player.x,
        "y": player.y,
        "gold": player.gold,
        "wood": player.wood,
        "stone": player.stone,
        "inventory": [],
        "equipped": {},
    }

    # Fill inventory
    for item in player.inventory:
        data["inventory"].append({
            "definition_id": item.definition_id,
            "instance_data": item.instance_data
        })

    # Fill equipped
    for slot, item in player.equipped.items():
        if item:
            data["equipped"][slot] = {
                "definition_id": item.definition_id,
                "instance_data": item.instance_data
            }
        else:
            data["equipped"][slot] = None

    try:
        with open(filename, "w") as f:
            json.dump(data, f, indent=2)
    except Exception as e:
        print(f"Error saving player: {e}")


def load_player(filename=CHARACTER_FILE):
    """
    Read JSON from 'filename' => build a Player object => return it.
    If file not found or error, return None.

    Reconstructs each item as ItemInstance(definition_id, instance_data).
    """
    if not os.path.exists(filename):
        return None

    try:
        with open(filename, "r") as f:
            data = json.load(f)
    except:
        return None

    # Build player
    name = data.get("name", "Hero")
    hp = data.get("hp", 100)
    level = data.get("level", 1)

    player = Player(
        x=data.get("x", 0),
        y=data.get("y", 0),
        name=name,
        hp=hp,
        level=level
    )
    player.gold = data.get("gold", 0)
    player.wood = data.get("wood", 0)
    player.stone = data.get("stone", 0)

    # Rebuild inventory
    inv_list = data.get("inventory", [])
    for it in inv_list:
        definition_id = it.get("definition_id", "")
        instance_data = it.get("instance_data", {})
        item_instance = ItemInstance(definition_id, instance_data)
        player.add_item(item_instance)

    # Rebuild equipped
    eq_dict = data.get("equipped", {})
    for slot, info in eq_dict.items():
        if info:
            definition_id = info.get("definition_id", "")
            instance_data = info.get("instance_data", {})
            eq_item = ItemInstance(definition_id, instance_data)
            player.equipped[slot] = eq_item
        else:
            player.equipped[slot] = None

    return player

==== File: scenery_main.py ====
# FileName: scenery_main.py
# version: 3.5
# Summary: Manages all scenery objects (trees, rocks, bridges), ensuring "floor" tiles
#          (grass, river, path, etc.) are placed at the bottom of the stack.
#          Also ensures robust handling of '_prev_floor' in legacy or partially-initialized tiles,
#          so we don't get KeyError on deletion.
# Tags: scenery, map, collision

from scenery_defs import (
    ALL_SCENERY_DEFS,  # The shared dictionary from scenery_defs.py
    TREE_TRUNK_ID,
    TREE_TOP_ID,
    ROCK_ID,
    BRIDGE_ID,
    BRIDGE_END_ID,
    RIVER_ID,
    GRASS_ID,
    PATH_ID,
    TREE_ID,
    BRIDGE_TOOL_ID,
    SEMICOLON_FLOOR_ID,
    EMPTY_FLOOR_ID,
    DEBUG_DOT_ID
)

##############################################################################
# 0) LAYER CONSTANTS
##############################################################################
FLOOR_LAYER   = "floor"    # Single tile terrain
OBJECTS_LAYER = "objects"  # e.g. rocks, trees, bridges
ITEMS_LAYER   = "items"    # items on the ground
ENTITIES_LAYER= "entities" # future usage if you want to store NPCs here

# All "floor" type IDs => stored in the 'floor' layer
FLOOR_TYPE_IDS = {
    RIVER_ID,
    GRASS_ID,
    PATH_ID,
    SEMICOLON_FLOOR_ID,
    EMPTY_FLOOR_ID
}

# Some "object" type IDs => stored in the 'objects' layer
OBJECT_TYPE_IDS = {
    ROCK_ID,
    TREE_TRUNK_ID,
    TREE_TOP_ID,
    BRIDGE_ID,
    BRIDGE_END_ID,
    BRIDGE_TOOL_ID,
    # etc. You can add more
}

# If you eventually define item IDs in scenery_defs, put them in ITEM_TYPE_IDS
ITEM_TYPE_IDS = set()

# If you want to store monsters/NPCs in scenery, define them in ENTITIES_TYPE_IDS
ENTITIES_TYPE_IDS = set()

##############################################################################
# LEGACY REGISTER FUNCTIONALITY
##############################################################################
def register_scenery(definition_id, char, color_pair, blocking, placeable):
    ALL_SCENERY_DEFS[definition_id] = {
        "char": char,
        "color_pair": color_pair,
        "blocking": blocking,
        "placeable": placeable
    }

def get_placeable_scenery_defs():
    return [
        def_id
        for def_id, info in ALL_SCENERY_DEFS.items()
        if info.get("placeable", False)
    ]

##############################################################################
# Build forward/reverse maps
##############################################################################
def build_forward_map():
    forward = {}
    for def_id, info in ALL_SCENERY_DEFS.items():
        c = info.get("ascii_char", info.get("char", "?"))
        cp = info.get("ascii_color", info.get("color_pair", 0))
        forward[def_id] = (c, cp)
    return forward

def build_reverse_map():
    reverse = {}
    for def_id, info in ALL_SCENERY_DEFS.items():
        c = info.get("ascii_char", info.get("char", "?"))
        cp = info.get("ascii_color", info.get("color_pair", 0))
        reverse[(c, cp)] = def_id
    return reverse

##############################################################################
# SCENERYOBJECT
##############################################################################
class SceneryObject:
    """
    Basic container for definition_id, char, color_pair, x, y.
    """
    def __init__(self, x, y, paramA, paramB=None):
        self.x = x
        self.y = y
        self.definition_id = None
        self.char = "?"
        self.color_pair = 0

        if not hasattr(self.__class__, "_forward_cache"):
            from scenery_main import build_forward_map, build_reverse_map
            self.__class__._forward_cache = build_forward_map()
            self.__class__._reverse_cache = build_reverse_map()

        forward_map = self.__class__._forward_cache
        reverse_map = self.__class__._reverse_cache

        if paramB is None:
            def_id = paramA
            self.definition_id = def_id
            char_col = forward_map.get(def_id, ("?", 0))
            self.char = char_col[0]
            self.color_pair = char_col[1]
        else:
            c = paramA
            col = paramB
            self.char = c
            self.color_pair = col
            self.definition_id = reverse_map.get((c, col), None)

##############################################################################
# 1) LAYER-BASED DICTIONARY
##############################################################################
def _init_tile_layers(placed_scenery, x, y):
    """
    Ensures placed_scenery[(x,y)] has a dict with keys:
      'floor', 'objects', 'items', 'entities', '_prev_floor'
    """
    if (x,y) not in placed_scenery:
        placed_scenery[(x,y)] = {
            FLOOR_LAYER:   None,
            OBJECTS_LAYER: [],
            ITEMS_LAYER:   [],
            ENTITIES_LAYER: [],
            '_prev_floor': None
        }
    else:
        tile_layers = placed_scenery[(x,y)]
        if FLOOR_LAYER not in tile_layers:
            tile_layers[FLOOR_LAYER] = None
        if OBJECTS_LAYER not in tile_layers:
            tile_layers[OBJECTS_LAYER] = []
        if ITEMS_LAYER not in tile_layers:
            tile_layers[ITEMS_LAYER] = []
        if ENTITIES_LAYER not in tile_layers:
            tile_layers[ENTITIES_LAYER] = []
        if '_prev_floor' not in tile_layers:
            tile_layers['_prev_floor'] = None

def _layer_for_def_id(def_id):
    """
    Decide which layer to place a definition_id into.
    If unknown, we default to 'objects' so it remains visible.
    """
    if def_id in FLOOR_TYPE_IDS:
        return FLOOR_LAYER
    elif def_id in OBJECT_TYPE_IDS:
        return OBJECTS_LAYER
    elif def_id in ITEM_TYPE_IDS:
        return ITEMS_LAYER
    elif def_id in ENTITIES_TYPE_IDS:
        return ENTITIES_LAYER
    else:
        return OBJECTS_LAYER

def _append_scenery(placed_scenery, obj):
    """
    Places 'obj' into the correct layer at (obj.x, obj.y).
    - If floor => overwrites the old floor (storing it in '_prev_floor')
    - If object => appends in objects layer
    - If item => appends in the items layer
    - If entity => appends in the entities layer
    If there's no floor present, we default to EMPTY_FLOOR.
    """
    x, y = obj.x, obj.y
    _init_tile_layers(placed_scenery, x, y)

    tile_layers = placed_scenery[(x,y)]
    layer_name = _layer_for_def_id(obj.definition_id)

    if layer_name == FLOOR_LAYER:
        if tile_layers[FLOOR_LAYER] and tile_layers[FLOOR_LAYER].definition_id != obj.definition_id:
            tile_layers['_prev_floor'] = tile_layers[FLOOR_LAYER]
        tile_layers[FLOOR_LAYER] = obj
    else:
        if tile_layers[FLOOR_LAYER] is None:
            from scenery_main import SceneryObject, EMPTY_FLOOR_ID
            tile_layers[FLOOR_LAYER] = SceneryObject(x, y, EMPTY_FLOOR_ID)
        tile_layers[layer_name].append(obj)

def _remove_scenery(placed_scenery, obj):
    """
    Removes 'obj' from whichever layer it belongs to.
    If removing a floor object:
      - If '_prev_floor' is not None, revert to that old floor
      - Otherwise, set floor to None
    Then if everything is empty/no floor, we set floor to EMPTY_FLOOR.
    """
    x, y = obj.x, obj.y
    if (x,y) not in placed_scenery:
        return

    tile_layers = placed_scenery[(x,y)]
    # Ensure _prev_floor is set (avoid KeyError if tile data was not fully init):
    if '_prev_floor' not in tile_layers:
        tile_layers['_prev_floor'] = None

    layer_name = _layer_for_def_id(obj.definition_id)

    if layer_name == FLOOR_LAYER:
        if tile_layers[FLOOR_LAYER] == obj:
            if tile_layers['_prev_floor'] is not None:
                tile_layers[FLOOR_LAYER] = tile_layers['_prev_floor']
                tile_layers['_prev_floor'] = None
            else:
                tile_layers[FLOOR_LAYER] = None
    elif layer_name == OBJECTS_LAYER:
        if obj in tile_layers[OBJECTS_LAYER]:
            tile_layers[OBJECTS_LAYER].remove(obj)
    elif layer_name == ITEMS_LAYER:
        if obj in tile_layers[ITEMS_LAYER]:
            tile_layers[ITEMS_LAYER].remove(obj)
    elif layer_name == ENTITIES_LAYER:
        if obj in tile_layers[ENTITIES_LAYER]:
            tile_layers[ENTITIES_LAYER].remove(obj)

    # If everything else is empty/no floor, set a default floor
    if (tile_layers[FLOOR_LAYER] is None and
        not tile_layers[OBJECTS_LAYER] and
        not tile_layers[ITEMS_LAYER] and
        not tile_layers[ENTITIES_LAYER]):
        tile_layers[FLOOR_LAYER] = SceneryObject(x, y, EMPTY_FLOOR_ID)
        tile_layers['_prev_floor'] = None

def _get_objects_at(placed_scenery, x, y):
    """
    Merges floor + objects + items + entities into a single list from bottom -> top.
    floor (if any) -> objects -> items -> entities
    """
    if (x,y) not in placed_scenery:
        return []
    tile_layers = placed_scenery[(x,y)]
    merged = []
    if tile_layers[FLOOR_LAYER]:
        merged.append(tile_layers[FLOOR_LAYER])
    merged.extend(tile_layers[OBJECTS_LAYER])
    merged.extend(tile_layers[ITEMS_LAYER])
    merged.extend(tile_layers[ENTITIES_LAYER])
    return merged

##############################################################################
# COLLISION & LOOKUP LOGIC
##############################################################################
def is_blocked(x, y, placed_scenery):
    merged_stack = _get_objects_at(placed_scenery, x, y)
    if not merged_stack:
        return False
    top_obj = merged_stack[-1]
    info = ALL_SCENERY_DEFS.get(top_obj.definition_id, None)
    return (info and info.get("blocking", False))

def get_stacked_objs(x, y, placed_scenery):
    return _get_objects_at(placed_scenery, x, y)

def get_topmost_obj(x, y, placed_scenery):
    merged_stack = _get_objects_at(placed_scenery, x, y)
    return merged_stack[-1] if merged_stack else None

def get_scenery_def_id_at(x, y, placed_scenery):
    top = get_topmost_obj(x, y, placed_scenery)
    return top.definition_id if top else None

def get_scenery_color_at(x, y, placed_scenery):
    top = get_topmost_obj(x, y, placed_scenery)
    return top.color_pair if top else 0

##############################################################################
# PLACEMENT LOGIC
##############################################################################
def place_scenery_item(def_id, player, placed_scenery, mark_dirty_func,
                       is_editor=False, world_width=100, world_height=60):
    newly_placed = []

    if def_id == BRIDGE_TOOL_ID and is_editor:
        new_objs = place_bridge_across_river(
            player, placed_scenery, mark_dirty_func,
            world_width=world_width,
            world_height=world_height,
            is_editor=True
        )
        newly_placed.extend(new_objs)
    elif def_id == TREE_ID and is_editor:
        trunk_obj, top_obj = place_tree(player, placed_scenery, mark_dirty_func)
        newly_placed.append(trunk_obj)
        if top_obj:
            newly_placed.append(top_obj)
    else:
        obj = _place_single_tile(player.x, player.y, def_id,
                                 placed_scenery, mark_dirty_func)
        newly_placed.append(obj)

    return newly_placed

def place_tree(player, placed_scenery, mark_dirty_func):
    px, py = player.x, player.y
    trunk_obj = SceneryObject(px, py, TREE_TRUNK_ID)
    _append_scenery(placed_scenery, trunk_obj)
    mark_dirty_func(px, py)

    top_obj = None
    if py > 0:
        top_obj = SceneryObject(px, py - 1, TREE_TOP_ID)
        _append_scenery(placed_scenery, top_obj)
        mark_dirty_func(px, py - 1)

    return trunk_obj, top_obj

def place_bridge_across_river(player, placed_scenery, mark_dirty_func,
                              world_width=100, world_height=60,
                              is_editor=False):
    dx = dy = 0
    if player.last_move_direction == "up":
        dy = -1
    elif player.last_move_direction == "down":
        dy = 1
    elif player.last_move_direction == "left":
        dx = -1
    elif player.last_move_direction == "right":
        dx = 1

    cx = player.x + dx
    cy = player.y + dy

    water_tiles = []
    while 0 <= cx < world_width and 0 <= cy < world_height:
        tile_objs = _get_objects_at(placed_scenery, cx, cy)
        found_river = None
        for obj in tile_objs:
            if obj.definition_id == RIVER_ID:
                found_river = obj
                break
        if not found_river:
            break
        water_tiles.append(found_river)
        cx += dx
        cy += dy

    if not water_tiles:
        return []

    newly_placed = []
    for wobj in water_tiles:
        # Keep the river as the floor, do NOT remove it.
        # Remove any existing BridgeEnd in that same tile.
        tile_objs2 = _get_objects_at(placed_scenery, wobj.x, wobj.y)
        endpoints = [o for o in tile_objs2 if o.definition_id == BRIDGE_END_ID]
        for e in endpoints:
            _remove_scenery(placed_scenery, e)

        new_bridge = SceneryObject(wobj.x, wobj.y, BRIDGE_ID)
        _append_scenery(placed_scenery, new_bridge)
        mark_dirty_func(wobj.x, wobj.y)
        newly_placed.append(new_bridge)

    start_x = water_tiles[0].x - dx
    start_y = water_tiles[0].y - dy
    end_x   = water_tiles[-1].x + dx
    end_y   = water_tiles[-1].y + dy
    for (ex, ey) in [(start_x, start_y), (end_x, end_y)]:
        if 0 <= ex < world_width and 0 <= ey < world_height:
            tile_objs3 = _get_objects_at(placed_scenery, ex, ey)
            has_bridge = any(o.definition_id == BRIDGE_ID for o in tile_objs3)
            is_river   = any(o.definition_id == RIVER_ID  for o in tile_objs3)
            if not has_bridge and not is_river:
                bend = SceneryObject(ex, ey, BRIDGE_END_ID)
                _append_scenery(placed_scenery, bend)
                mark_dirty_func(ex, ey)
                newly_placed.append(bend)

    return newly_placed

def _place_single_tile(x, y, def_id, placed_scenery, mark_dirty_func):
    obj = SceneryObject(x, y, def_id)
    _append_scenery(placed_scenery, obj)
    mark_dirty_func(x, y)
    return obj

##############################################################################
# TILE EFFECT LOGIC
##############################################################################
def apply_tile_effects(player, tile_def_id, placed_scenery,
                       is_editor=False, world_width=100, world_height=60):
    if tile_def_id == PATH_ID:
        old_x, old_y = player.x, player.y
        player.move(player.last_move_direction, world_width, world_height, placed_scenery)
        # stops sliding if blocked

##############################################################################
# EXPORTS
##############################################################################
__all__ = [
    "ALL_SCENERY_DEFS",
    "SceneryObject",
    "FLOOR_TYPE_IDS", "OBJECT_TYPE_IDS", "ITEM_TYPE_IDS", "ENTITIES_TYPE_IDS",
    "FLOOR_LAYER", "OBJECTS_LAYER", "ITEMS_LAYER", "ENTITIES_LAYER",

    "build_forward_map",
    "build_reverse_map",
    "_append_scenery",
    "_remove_scenery",
    "_get_objects_at",

    "place_scenery_item",
    "apply_tile_effects",
    "place_tree",
    "place_bridge_across_river",
    "is_blocked",
    "get_stacked_objs",
    "get_topmost_obj",
    "get_scenery_def_id_at",
    "get_scenery_color_at",
    "register_scenery",
    "get_placeable_scenery_defs",
]

==== File: summary.py ====
#!/usr/bin/env python3
# FileName: summary.py
# version 1.4
# Summary: A command-line tool to scan Python files in a project directory for:
#   - FileName
#   - version
#   - Summary
#   - Tags
#
# Tags: help, info, summary, tool
#
# Features:
#   - Automatic discovery of *.py files (except itself, if desired)
#   - Filtering by file(s), tags, or a search term (checks file name, FileName line,
#     version, summary, and tags)
#   - Optionally printing the full code for each matched file
#   - Saving summary data as JSON:
#      --save-json with no argument => automatically names file in ./summary_print/
#      --save-json myfile.json => saves with a custom name
#   - NEW: Saving all matched files’ code to a .txt file (with line breaks) via --save-code

import os
import re
import json
import sys
import argparse
from datetime import datetime
from typing import List, Dict

# Regex patterns for the 4 lines:
RE_FILEHEADER = re.compile(r'^#\s*FileName\s*:\s*(.*)$', re.IGNORECASE)
RE_VERSION    = re.compile(r'^#\s*version\s*:\s*(.*)$', re.IGNORECASE)
RE_SUMMARY    = re.compile(r'^#\s*Summary\s*:\s*(.*)$', re.IGNORECASE)
RE_TAGS       = re.compile(r'^#\s*Tags\s*:\s*(.*)$', re.IGNORECASE)


class CustomArgParser(argparse.ArgumentParser):
    """
    Subclass ArgumentParser so that when there's an error
    (e.g., an unrecognized argument), it prints the full
    help text instead of just a short usage message.
    Also overrides help to be more concise & colored.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Provide a custom usage line, remove default 'positional arguments' display
        self.usage = "\033[1;34mUsage:\033[0m summary.py [OPTIONS] [FILES...]"

    def error(self, message):
        # Print our custom help on error
        sys.stderr.write(f"\n\033[1;31mError:\033[0m {message}\n\n")
        self.print_help()
        sys.exit(2)

    def print_help(self):
        # Print a simpler, colored help message (override default).
        # We omit big details about "positional arguments," synonyms, etc.
        help_text = f"""
\033[1;34mUsage:\033[0m summary.py [OPTIONS] [FILES...]

\033[1;36mScan Python files for FileName, version, Summary, and Tags.\033[0m

\033[1;33mOptions:\033[0m
  \033[1;32m-r, --root\033[0m
    Root directory to search for .py files (default is current dir).

  \033[1;32m-f, --files\033[0m
    Specific .py files to summarize. Overrides auto-discovery.

  \033[1;32m-t, --tags\033[0m
    Filter results by these tag(s). Multiple tags => include if any match.

  \033[1;32m-s, --search\033[0m
    Case-insensitive search in OS filename, FileName header, version, summary, or tags.

  \033[1;32m-pc, --print-code\033[0m
    Print the full code for each matched file to console.

  \033[1;32m-sj, --save-json\033[0m  [optional filename or no argument]
    Save results to JSON file. No argument => auto-naming.

  \033[1;32m-sc, --save-code\033[0m  [optional filename or no argument]
    Save all matched files' code to a .txt file, with a blank line separating each file.
    No argument => auto-naming.

  \033[1;32m-h, --help\033[0m
    Show this help message and exit.

Examples:
  summary.py --root . --tags engine --print-code
  summary.py -s 'animation' -pc -sc code_dump.txt
"""
        sys.stdout.write(help_text + "\n")


def gather_all_py_files(root_dir: str) -> List[str]:
    """
    Recursively gather all .py files under root_dir.
    """
    all_py = []
    for dirpath, _, filenames in os.walk(root_dir):
        for fname in filenames:
            if fname.endswith(".py"):
                full_path = os.path.join(dirpath, fname)
                all_py.append(full_path)
    return all_py


def parse_summaries_from_file(filepath: str) -> Dict:
    """
    Parse the file for:
        # FileName: ...
        # version: ...
        # Summary: ...
        # Tags: ...
    Returns a dict with:
       {
         "filename": os.path.basename(filepath),
         "fullpath": filepath,
         "header_filename": str or None,
         "version": str or None,
         "summary": str or None,
         "tags": [list of strings],
       }
    """
    header_filename = None
    version_str     = None
    summary_str     = None
    tags_list       = []

    try:
        with open(filepath, "r", encoding="utf-8") as f:
            for line in f:
                line_stripped = line.strip()

                # Check for each pattern
                match_fileheader = RE_FILEHEADER.match(line_stripped)
                if match_fileheader:
                    header_filename = match_fileheader.group(1).strip()
                    continue

                match_version = RE_VERSION.match(line_stripped)
                if match_version:
                    version_str = match_version.group(1).strip()
                    continue

                match_summary = RE_SUMMARY.match(line_stripped)
                if match_summary:
                    summary_str = match_summary.group(1).strip()
                    continue

                match_tags = RE_TAGS.match(line_stripped)
                if match_tags:
                    raw_tags = match_tags.group(1).strip()
                    tags_list = [
                        t.strip()
                        for t in re.split(r'[,\s]+', raw_tags)
                        if t.strip()
                    ]
    except (IOError, OSError):
        pass

    return {
        "filename": os.path.basename(filepath),
        "fullpath": filepath,
        "header_filename": header_filename,
        "version": version_str,
        "summary": summary_str,
        "tags": tags_list
    }


def main():
    parser = CustomArgParser(
        add_help=False,  # We'll add our custom -h/--help
        description="Scan Python files for FileName, version, Summary, and Tags."
    )

    # Add a simple custom help
    parser.add_argument(
        "-h", "--help",
        action="store_true",
        help=argparse.SUPPRESS
    )

    parser.add_argument(
        "-r", "--root",
        default=".",
        help="Root directory to search for .py files (default current dir)."
    )
    parser.add_argument(
        "-f", "--files",
        nargs="*",
        default=None,
        help="Specific .py files to summarize. This overrides auto-discovery."
    )
    parser.add_argument(
        "-t", "--tags",
        nargs="*",
        default=None,
        help="Filter results by these tag(s). Multiple tags => any match triggers inclusion."
    )
    parser.add_argument(
        "-s", "--search",
        default=None,
        help="Search term (case-insensitive) in OS filename, # FileName, version, summary, or tags."
    )
    parser.add_argument(
        "-pc", "--print-code",
        action="store_true",
        help="If specified, also print the full code for each matched file."
    )
    # Save JSON (auto or custom name)
    parser.add_argument(
        "-sj", "--save-json",
        nargs="?",
        const="AUTO",
        default=None,
        help="Save results as JSON to a file. If no argument => auto-naming."
    )
    # Save code to a .txt file (auto or custom name)
    parser.add_argument(
        "-sc", "--save-code",
        nargs="?",
        const="AUTO",
        default=None,
        help="Save full code of matched files to a .txt file. If no argument => auto-naming."
    )

    # Hidden positional argument(s), not shown in help
    parser.add_argument(
        "files_pos",
        nargs="*",
        help=argparse.SUPPRESS
    )

    args = parser.parse_args()

    # If user asked for help, show it and exit
    if args.help:
        parser.print_help()
        sys.exit(0)

    # Merge positional files with --files if any
    if args.files_pos:
        if args.files is not None:
            args.files.extend(args.files_pos)
        else:
            args.files = args.files_pos

    # 1) Determine which files to process
    if args.files:
        py_files = [os.path.abspath(f) for f in args.files]
    else:
        py_files = gather_all_py_files(os.path.abspath(args.root))

    # 2) Parse each file for summaries
    all_summaries = []
    for fpath in py_files:
        info = parse_summaries_from_file(fpath)
        all_summaries.append(info)

    # 3) Filter by tags if specified
    if args.tags:
        lower_tags = [t.lower() for t in args.tags]
        filtered = []
        for summ in all_summaries:
            file_tags_lower = [t.lower() for t in summ["tags"]]
            if any(t in file_tags_lower for t in lower_tags):
                filtered.append(summ)
        all_summaries = filtered

    # 4) Filter by search term (checks file name, FileName line, version, summary, and tags)
    if args.search:
        search_lower = args.search.lower()
        filtered = []
        for summ in all_summaries:
            text_to_search = summ["filename"].lower()
            if summ["header_filename"]:
                text_to_search += " " + summ["header_filename"].lower()
            if summ["version"]:
                text_to_search += " " + summ["version"].lower()
            if summ["summary"]:
                text_to_search += " " + summ["summary"].lower()
            if summ["tags"]:
                text_to_search += " " + " ".join(t.lower() for t in summ["tags"])
            if search_lower in text_to_search:
                filtered.append(summ)
        all_summaries = filtered

    # 5) Display results in console (with some color)
    for summ in all_summaries:
        print(f"\033[93m{'=' * 60}\033[0m")
        print(f"\033[92mFile:\033[0m {summ['filename']}  \033[94m(Path:\033[0m {summ['fullpath']}\033[94m)\033[0m")
        print(f"\033[92mFileName header:\033[0m {summ['header_filename'] or '[None found]'}")
        print(f"\033[92mVersion:\033[0m {summ['version'] or '[None found]'}")
        print(f"\033[92mSummary:\033[0m {summ['summary'] or '[None found]'}")
        if summ["tags"]:
            print(f"\033[92mTags:\033[0m {', '.join(summ['tags'])}")
        else:
            print("\033[92mTags:\033[0m [None found]")

        # 6) Print code if requested
        if args.print_code:
            print(f"\033[96m{'-' * 60}\033[0m")
            print("\033[95mFile Content:\033[0m")
            print(f"\033[96m{'-' * 60}\033[0m")
            try:
                with open(summ["fullpath"], "r", encoding="utf-8") as fc:
                    code_lines = fc.read()
                print(code_lines)
            except Exception as e:
                print(f"Error reading file content: {e}")

    # 7) If requested, save results to JSON
    #    (We do the "stype + date" naming if user didn't provide a filename)
    json_file_path = None
    if args.save_json is not None:
        if args.save_json == "AUTO":
            # Automatic filename
            if args.search:
                stype = f"search_{args.search}"
            elif args.tags:
                stype = "tags_" + "_".join(args.tags)
            elif args.files:
                stype = "files"
            else:
                stype = "all"
            short_dt = datetime.now().strftime("%Y%m%d_%H%M%S")
            os.makedirs("./summary_print", exist_ok=True)
            json_file_path = f"./summary_print/{stype}_results_{short_dt}.json"
        else:
            json_file_path = args.save_json

        try:
            with open(json_file_path, "w", encoding="utf-8") as outfile:
                json.dump(all_summaries, outfile, indent=2)
            print(f"\n\033[92mSaved summary data to JSON:\033[0m {json_file_path}")
        except Exception as e:
            print(f"Error saving JSON data: {e}")

    # 8) If requested, save the full code of matched files to a text file
    #    (We reuse the same "stype + date" pattern as JSON, just .txt)
    if args.save_code is not None:
        if args.save_code == "AUTO":
            # If we already auto-named for JSON, use the same base
            if json_file_path and args.save_json == "AUTO":
                # same base name as the JSON, but with .txt
                outfile_code_path = os.path.splitext(json_file_path)[0] + ".txt"
            else:
                # Automatic naming if JSON not used or user provided a custom JSON path
                if args.search:
                    stype = f"search_{args.search}"
                elif args.tags:
                    stype = "tags_" + "_".join(args.tags)
                elif args.files:
                    stype = "files"
                else:
                    stype = "all"
                short_dt = datetime.now().strftime("%Y%m%d_%H%M%S")
                os.makedirs("./summary_print", exist_ok=True)
                outfile_code_path = f"./summary_print/{stype}_results_{short_dt}.txt"
        else:
            outfile_code_path = args.save_code

        try:
            os.makedirs(os.path.dirname(outfile_code_path), exist_ok=True)
        except OSError:
            # Might happen if user gave just a filename without directory
            pass

        try:
            with open(outfile_code_path, "w", encoding="utf-8") as out_file:
                for idx, summ in enumerate(all_summaries):
                    # Attempt to read the file code
                    code_data = ""
                    try:
                        with open(summ["fullpath"], "r", encoding="utf-8") as fc:
                            code_data = fc.read()
                    except Exception as e:
                        code_data = f"Error reading file: {e}\n"

                    # Write a header, then the code, then a blank line
                    out_file.write(f"==== File: {summ['filename']} ====\n")
                    out_file.write(code_data)
                    out_file.write("\n\n")  # blank line between files

            print(f"\n\033[92mSaved code to:\033[0m {outfile_code_path}")
        except Exception as e:
            print(f"Error saving code to file: {e}")


if __name__ == "__main__":
    main()


==== File: scene_main.py ====
# FileName: scene_main.py
# version: 1.4 (Now uses the single global highlight config for the main menu)
# Summary: High-level scene functions (title screen, load screen, etc.).
# Tags: scene, animation, menu

import curses
from art_main import MAIN_MENU_ART, CROCODILE
from ui_main import (
    draw_screen_frame,
    draw_title,
    draw_instructions
)
from animator_draw import draw_art
# We import the single global highlight function:
from highlight_selector import draw_global_selector_line

def scene_home_screen(stdscr):
    """
    Animates MAIN_MENU_ART left/right ±2 columns, draws menu instructions,
    and allows user to select:
      1 => Play
      2 => Quit
      3 => Settings
    Either via arrow keys or pressing '1', '2', '3'.
    """
    stdscr.nodelay(True)
    stdscr.keypad(True)
    curses.curs_set(0)

    max_shift = 2
    frame_delay_ms = 50
    shift_delay_frames = 20

    offset_x = 0
    direction = -1
    frame_count = 0

    menu_lines = [
        "~~~~~~~~~",
        "1) Play",
        # "3) Settings",
        "2) Quit",
        "~~~~~~~~~"
    ]
    selectable_indices = [1, 2]  # lines #1 => "1) Play", #2 => "2) Quit"
    current_select_slot = 0

    while True:
        stdscr.erase()
        draw_screen_frame(stdscr)

        draw_title(stdscr, "Welcome to Retro RPG!", row=1)
        draw_art(stdscr, MAIN_MENU_ART, start_row=3, start_col=2 + offset_x)

        # Draw menu lines near bottom with a highlight on the selected index
        h, w = stdscr.getmaxyx()
        from_bottom = 2
        start_row = h - from_bottom - len(menu_lines)
        if start_row < 1:
            start_row = 1

        row = start_row
        for i, line_text in enumerate(menu_lines):
            is_selected = False
            if i in selectable_indices:
                sel_index = selectable_indices.index(i)
                if sel_index == current_select_slot:
                    is_selected = True

            draw_global_selector_line(
                stdscr,
                row,
                line_text,
                is_selected=is_selected,
                frame=frame_count
            )
            row += 1

        stdscr.noutrefresh()
        curses.doupdate()

        key = stdscr.getch()
        if key != -1:
            # Move highlight with up/down
            if key in (curses.KEY_UP, ord('w'), ord('W')):
                current_select_slot = max(0, current_select_slot - 1)
            elif key in (curses.KEY_DOWN, ord('s'), ord('S')):
                if current_select_slot < len(selectable_indices) - 1:
                    current_select_slot += 1

            # Press Enter => confirm
            elif key in (curses.KEY_ENTER, 10, 13):
                if current_select_slot == 0:
                    return 1
                else:
                    return 2

            # Numeric shortcuts remain
            elif key == ord('1'):
                return 1
            elif key == ord('2'):
                return 2
            elif key == ord('3') or key in (ord('s'), ord('S')):
                return 3
            elif key in (ord('q'), ord('Q'), 27):
                return 2
            elif key == ord('v'):
                import debug
                debug.toggle_debug()

        frame_count += 1
        if frame_count % shift_delay_frames == 0:
            offset_x += direction
            if offset_x >= max_shift:
                offset_x = max_shift
                direction = -1
            elif offset_x <= -max_shift:
                offset_x = -max_shift
                direction = 1

        curses.napms(frame_delay_ms)


def scene_load_screen(stdscr):
    """
    Shows animated CROCODILE art for the Load Map screen 
    until user presses certain keys (Enter, q, ESC, etc.).
    """
    stdscr.nodelay(True)
    stdscr.keypad(True)
    curses.curs_set(0)

    max_shift = 2
    frame_delay_ms = 50
    shift_delay_frames = 20

    offset_x = 0
    direction = -1
    frame_count = 0

    while True:
        stdscr.erase()
        draw_screen_frame(stdscr)
        draw_title(stdscr, "Load Map", row=1)
        draw_art(stdscr, CROCODILE, start_row=3, start_col=2 + offset_x)

        instructions = [
            "↑/↓=select, ENTER=load, 'd'=del, 'q'=back"
        ]
        draw_instructions(stdscr, instructions, from_bottom=3)

        stdscr.noutrefresh()
        curses.doupdate()

        key = stdscr.getch()
        if key in (
            ord('q'), ord('Q'), 27,
            curses.KEY_ENTER, 10, 13,
            curses.KEY_BACKSPACE, 127
        ):
            return None
        elif key == ord('v'):
            import debug
            debug.toggle_debug()

        frame_count += 1
        if frame_count % shift_delay_frames == 0:
            offset_x += direction
            if offset_x >= max_shift:
                offset_x = max_shift
                direction = -1
            elif offset_x <= -max_shift:
                offset_x = -max_shift
                direction = 1

        curses.napms(frame_delay_ms)


def scene_settings_screen(stdscr):
    """
    A placeholder "Settings" screen.
    Press 'q' or ESC to return to the main menu.
    """
    stdscr.nodelay(False)
    stdscr.keypad(True)
    curses.curs_set(0)

    while True:
        stdscr.erase()
        draw_screen_frame(stdscr)
        draw_title(stdscr, "Settings (Placeholder)", row=1)

        info_lines = [
            "Here is where you might configure volume, video settings, etc.",
            "Press 'q' or ESC to go back..."
        ]
        draw_instructions(stdscr, info_lines, from_bottom=2)

        stdscr.refresh()

        key = stdscr.getch()
        if key in (ord('q'), ord('Q'), 27):
            return
        elif key == ord('v'):
            import debug
            debug.toggle_debug()

==== File: menu_flow_manager.py ====
# FileName: menu_flow_manager.py
# version: 1.0
# Summary: A controller that manages high-level menu flow (title, play, settings, etc.)
# Tags: menu, flow, controller

import curses

# We import the scene functions and play_main so we can call them:
from scene_main import scene_home_screen, scene_settings_screen
from play_main import play_main

class MenuFlowManager:
    """
    A simple UI flow controller that organizes the main menu screens (home, settings, etc.)
    and transitions to play mode or quits. Future expansions (multiplayer, level select, etc.)
    can be plugged in here by adding new states and new scene calls.
    """

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.current_state = "HOME"
        self.running = True

    def run(self):
        """
        Main loop for the menu flow. Each screen function returns
        a choice that we interpret to move to the next state or exit.
        """
        while self.running:
            if self.current_state == "HOME":
                choice = scene_home_screen(self.stdscr)
                if choice == 1:
                    # user selected "Play"
                    self.current_state = "PLAY"
                elif choice == 2:
                    # user selected "Quit"
                    self.current_state = "QUIT"
                elif choice == 3:
                    # user selected "Settings"
                    self.current_state = "SETTINGS"
                else:
                    # Just in case we get something else, quit by default
                    self.current_state = "QUIT"

            elif self.current_state == "PLAY":
                # We run the existing play mode, then return to HOME afterward
                play_main(self.stdscr)
                self.current_state = "HOME"

            elif self.current_state == "SETTINGS":
                # Run the new (placeholder) settings screen,
                # then return to HOME after it's done
                scene_settings_screen(self.stdscr)
                self.current_state = "HOME"

            elif self.current_state == "QUIT":
                self.running = False

        # End of run() => Flow manager is done.


==== File: color_library.py ====
# FileName: color_library.py
# version: 1.0
# Summary: Defines base curses colors plus extended ones (light_gray, etc.).
# Tags: colors, config

import curses

# The standard 8 curses colors mapped to friendly names:
BASE_COLORS = {
    "black":   curses.COLOR_BLACK,
    "red":     curses.COLOR_RED,
    "green":   curses.COLOR_GREEN,
    "yellow":  curses.COLOR_YELLOW,
    "blue":    curses.COLOR_BLUE,
    "magenta": curses.COLOR_MAGENTA,
    "cyan":    curses.COLOR_CYAN,
    "white":   curses.COLOR_WHITE,
}

# Extended color indexes for e.g. light_gray, dark_gray, etc.
# Only works if curses.can_change_color() == True on your terminal.
EXTENDED_COLORS = {
    "light_gray": 8,
    "dark_gray":  9,
    # Add more if desired: "bright_green":10, etc.
}


def define_extended_colors():
    """
    Attempt to initialize extra colors if the terminal supports color redefinition.
    Each init_color(index, r, g, b) has r,g,b from 0..1000.
    """
    if not curses.can_change_color():
        return

    # light_gray => ~70% white
    curses.init_color(8, 700, 700, 700)
    # dark_gray  => ~30% white
    curses.init_color(9, 300, 300, 300)

==== File: highlight_selector.py ====
# FileName: highlight_selector.py
# version: 1.3 (Now uses separate selected_color_name vs. unselected_color_name)
# Summary: Provides a single, globally configurable highlight/selector system.
# Tags: selector, highlight, effects

import curses
from color_init import color_pairs

# -------------------------------------------------------------------
# 1) GLOBAL HIGHLIGHT CONFIG
# -------------------------------------------------------------------
GLOBAL_HIGHLIGHT_CONFIG = {
    "selected_color_name":   "UI_YELLOW",   # old name, mapped to "yellow_on_black"
    "unselected_color_name": "WHITE_TEXT",  # old name, mapped to "white_on_black"
    "effect_name":           "REVERSE_BLINK",
    "speed_factor":          5,
}

def get_global_selector_config():
    return GLOBAL_HIGHLIGHT_CONFIG

def get_selector_effect_attrs(effect="REVERSE_BLINK", frame=0, speed_factor=10):
    toggle_state = (frame // speed_factor) % 2
    if effect == "NONE":
        return curses.A_NORMAL
    elif effect == "REVERSE":
        return curses.A_REVERSE
    elif effect == "BLINK":
        return curses.A_BLINK
    elif effect == "REVERSE_BLINK":
        return (curses.A_REVERSE | curses.A_BLINK)
    elif effect == "FLASH":
        return curses.A_REVERSE if toggle_state == 0 else curses.A_NORMAL
    elif effect == "GLOW":
        return curses.A_BOLD if toggle_state == 0 else curses.A_NORMAL
    elif effect == "SHIMMER":
        return (curses.A_BOLD | curses.A_BLINK) if toggle_state == 0 else curses.A_NORMAL
    return curses.A_REVERSE  # fallback

def draw_global_selector_line(stdscr, row, text, is_selected=False, frame=0):
    config = get_global_selector_config()
    selected_color_name   = config["selected_color_name"]
    unselected_color_name = config["unselected_color_name"]
    effect_name           = config["effect_name"]
    speed_factor          = config["speed_factor"]

    _, w = stdscr.getmaxyx()
    truncated = text[: w - 4]

    try:
        if is_selected:
            attrs = get_selector_effect_attrs(effect=effect_name,
                                              frame=frame,
                                              speed_factor=speed_factor)
            color = curses.color_pair(color_pairs[selected_color_name]) | attrs
        else:
            color = curses.color_pair(color_pairs[unselected_color_name])
        stdscr.addstr(row, 2, truncated, color)
    except curses.error:
        pass

==== File: utils_main.py ====
# FileName: utils_main.py
# version: 3.4
# Summary: Contains miscellaneous utility functions (e.g., coordinate helpers, random picking) used by various modules.
# Tags: utils, general

import curses
import shutil

def get_terminal_size():
    try:
        size = shutil.get_terminal_size(fallback=(0, 0))
        if size.lines >= 10 and size.columns >= 10:
            return size.lines, size.columns
    except:
        pass
    return 60, 40

def get_front_tile(player):
    """
    Returns the (x, y) coordinates of the tile directly in front of the player,
    based on player.last_move_direction.
    """
    fx, fy = player.x, player.y
    if player.last_move_direction == "up":
        fy -= 1
    elif player.last_move_direction == "down":
        fy += 1
    elif player.last_move_direction == "left":
        fx -= 1
    elif player.last_move_direction == "right":
        fx += 1
    return fx, fy

# Any other purely generic helper functions can stay here.
# (All scenery, collision, or partial-draw code has moved elsewhere.)

==== File: scenery_defs.py ====
# FileName: scenery_defs.py
# version: 1.3
# Summary: Holds all scenery definitions (ASCII + future tile info),
#          plus the build_forward_map and build_reverse_map functions.
#          Updated so TREE_TOP_ID is green-on-black for the top of the tree.
# Tags: scenery, definitions

#############################
# SCENERY IDS AS CONSTANTS
#############################
TREE_TRUNK_ID       = "TreeTrunk"
TREE_TOP_ID         = "TreeTop"
ROCK_ID             = "Rock"
BRIDGE_ID           = "Bridge"
BRIDGE_END_ID       = "BridgeEnd"
RIVER_ID            = "River"
GRASS_ID            = "Grass"
PATH_ID             = "Path"
TREE_ID             = "Tree"
BRIDGE_TOOL_ID      = "BridgeTool"
SEMICOLON_FLOOR_ID  = "SemicolonFloor"
EMPTY_FLOOR_ID      = "EmptyFloor"
DEBUG_DOT_ID        = "DebugDot"

#############################
# ALL_SCENERY_DEFS DICTIONARY
#############################
ALL_SCENERY_DEFS = {
    TREE_TRUNK_ID: {
        "ascii_char": "|",
        "ascii_color": 2,  # "yellow_on_black" from your legacy color map
        "blocking": False,
        "placeable": False,
        "tile_image": "assets/tiles/tree_trunk.png",
    },
    TREE_TOP_ID: {
        "ascii_char": "§",
        "ascii_color": 1,  # "green_on_black" => top of the tree is green font on black background
        "blocking": False,
        "placeable": False,
        "tile_image": "assets/tiles/tree_top.png",
    },
    ROCK_ID: {
        "ascii_char": "o",
        "ascii_color": 3,  # "white_on_black"
        "blocking": True,
        "placeable": True,
        "tile_image": "assets/tiles/rock.png",
    },
    BRIDGE_ID: {
        "ascii_char": "#",
        "ascii_color": 2,
        "blocking": False,
        "placeable": False,
        "tile_image": "assets/tiles/bridge.png",
    },
    BRIDGE_END_ID: {
        "ascii_char": "l",
        "ascii_color": 2,
        "blocking": False,
        "placeable": False,
        "tile_image": "assets/tiles/bridge_end.png",
    },
    RIVER_ID: {
        "ascii_char": " ",
        "ascii_color": 4,  # "white_on_blue"
        "blocking": True,
        "placeable": True,
        "tile_image": "assets/tiles/river.png",
    },
    GRASS_ID: {
        "ascii_char": " ",
        "ascii_color": 5,  # "white_on_green"
        "blocking": False,
        "placeable": True,
        "tile_image": "assets/tiles/grass.png",
    },
    PATH_ID: {
        "ascii_char": " ",
        "ascii_color": 8,  # "black_on_yellow"
        "blocking": False,
        "placeable": True,
        "tile_image": "assets/tiles/path.png",
    },
    TREE_ID: {
        "ascii_char": "T",
        "ascii_color": 7,  # "green_on_white"
        "blocking": True,
        "placeable": True,
        "tile_image": "assets/tiles/tree.png",
    },
    BRIDGE_TOOL_ID: {
        "ascii_char": "=",
        "ascii_color": 2,  # "yellow_on_black"
        "blocking": False,
        "placeable": True,
        "tile_image": "assets/tiles/bridge_tool.png",
    },
    SEMICOLON_FLOOR_ID: {
        "ascii_char": ";",
        "ascii_color": 12, # "yellow_on_black"
        "blocking": False,
        "placeable": False,
        "tile_image": "assets/tiles/semicolon_floor.png",
    },
    EMPTY_FLOOR_ID: {
        "ascii_char": " ",
        "ascii_color": 16, # "white_on_black"
        "blocking": False,
        "placeable": False,
        "tile_image": "assets/tiles/empty_floor.png",
    },
    DEBUG_DOT_ID: {
        "ascii_char": ".",
        "ascii_color": 17, # "red_on_black"
        "blocking": False,
        "placeable": False,
        "tile_image": "assets/tiles/debug_dot.png",
    },
}

#############################
# BUILD FORWARD/REVERSE MAPS
#############################
def build_forward_map():
    """
    definition_id -> (char, color_pair)
    """
    forward = {}
    for def_id, info in ALL_SCENERY_DEFS.items():
        c = info.get("ascii_char", "?")
        cp = info.get("ascii_color", 0)
        forward[def_id] = (c, cp)
    return forward

def build_reverse_map():
    """
    (char, color_pair) -> definition_id
    """
    reverse = {}
    for def_id, info in ALL_SCENERY_DEFS.items():
        c = info.get("ascii_char", "?")
        cp = info.get("ascii_color", 0)
        reverse[(c, cp)] = def_id
    return reverse

##############################################################################
# EXPORTS
##############################################################################
__all__ = [
    "ALL_SCENERY_DEFS",
    "build_forward_map",
    "build_reverse_map",
    "TREE_TRUNK_ID",
    "TREE_TOP_ID",
    "ROCK_ID",
    "BRIDGE_ID",
    "BRIDGE_END_ID",
    "RIVER_ID",
    "GRASS_ID",
    "PATH_ID",
    "TREE_ID",
    "BRIDGE_TOOL_ID",
    "SEMICOLON_FLOOR_ID",
    "EMPTY_FLOOR_ID",
    "DEBUG_DOT_ID"
]

==== File: deprecated_color_defs.py ====
# FileName: color_defs.py
# version: 1.0
# Summary: Defines color constants or enums used throughout the game for consistent color referencing.
# Tags: colors, config

import curses

# Each tuple => (pair_index, foreground_color, background_color)
# Add or remove lines here to define new tile colors, UI colors, etc.
MAP_COLOR_DEFINITIONS = [
    (1, curses.COLOR_GREEN,   -1),  # Tree top
    (2, curses.COLOR_YELLOW,  -1),  # Bridge/trunk
    (3, curses.COLOR_WHITE,   -1),  # Rock
    (4, curses.COLOR_WHITE, curses.COLOR_BLUE),  # River
    (5, curses.COLOR_WHITE, curses.COLOR_GREEN), # Grass
    (6, curses.COLOR_WHITE,   -1),  # ASCII art
    (7, curses.COLOR_GREEN, curses.COLOR_WHITE), # Tree top hiding player
    (8, curses.COLOR_WHITE, curses.COLOR_YELLOW),# Path
    (9, curses.COLOR_WHITE,   -1),  # White text
    (10, curses.COLOR_BLACK, curses.COLOR_WHITE),# Flash highlight
]

UI_COLOR_DEFINITIONS = [
    (11, curses.COLOR_CYAN,   -1),
    (12, curses.COLOR_YELLOW, -1),
    (13, curses.COLOR_MAGENTA, -1),
    (14, curses.COLOR_WHITE,  curses.COLOR_BLUE),
    (15, curses.COLOR_GREEN,  -1),
    (16, curses.COLOR_YELLOW, -1), # Filler
    (17, curses.COLOR_RED,    -1)  # Used for DebugDot
]

# Combine them if you like, or keep them separate
ALL_COLOR_DEFINITIONS = MAP_COLOR_DEFINITIONS + UI_COLOR_DEFINITIONS

# A dictionary mapping human-friendly names -> pair index
COLOR_PAIR_NAMES = {
    "TREE_TOP": 1,
    "BRIDGE":   2,
    "ROCK":     3,
    "RIVER":    4,
    "GRASS":    5,
    "ASCII_ART":6,
    "TREE_HIDE_PLAYER":7,
    "PATH":     8,
    "WHITE_TEXT":9,
    "FLASH":    10,

    "UI_CYAN":  11,
    "UI_YELLOW":12,
    "UI_MAGENTA":13,
    "UI_WHITE_ON_BLUE":14,
    "UI_GREEN":15,
    "FILLER":   16,
    "DebugDot": 17,
}

==== File: deprecated_gen_scenery.py ====
# FileName: gen_scenery.py
# version: 1.0
# Summary: Consolidates all logic for placing procedural scenery: rivers, grass, rocks, trees, bridges, etc.
# Tags: map, generation, scenery

"""
All scenery-related functions have been moved into separate files:
  - gen_rivers.py      (rivers)
  - gen_grass.py       (grass patches, BFS, semicircle grass, etc.)
  - gen_rocks.py       (rocks)
  - gen_trees.py       (trees)
  - gen_bridges.py     (bridging)
This file is kept only for reference and is now effectively empty.
"""

==== File: generator.py ====
# FileName: generator.py
# version: 2.0
# Summary: Coordinates the procedural generation workflow, calling sub-generators (rivers, grass, etc.) in order.
# Tags: map, generation, pipeline

import random
from collections import deque  # for BFS queue

# Import sub-generators from their respective modules
from .gen_rivers import spawn_rivers
from .gen_grass import (
    spawn_large_semicircle_grass,
    find_grass_regions,
    find_random_grass_spot
)
# Potentially also import from gen_rocks, gen_trees, gen_bridges if needed:
# from .gen_rocks import spawn_rocks
# from .gen_trees import spawn_trees_non_grass
# from .gen_bridges import connect_grass_regions_with_bridges

# Import the ID constants and the forward/reverse maps from scenery_defs
from scenery_defs import (
    RIVER_ID,
    GRASS_ID,
    SEMICOLON_FLOOR_ID,
    EMPTY_FLOOR_ID,
    DEBUG_DOT_ID,
    build_forward_map,
    build_reverse_map
)

# We import the entire debug module
import debug

# Build caches for converting (char, color) <-> definition_id
FORWARD_MAP = build_forward_map()
REVERSE_MAP = build_reverse_map()

def tile_to_definition_id(ch, cpair):
    """
    Convert a (char, color_pair) tile into a recognized definition_id
    by looking it up in REVERSE_MAP (from scenery_defs).
    Fallback to EMPTY_FLOOR_ID if unknown.
    """
    return REVERSE_MAP.get((ch, cpair), EMPTY_FLOOR_ID)

def definition_id_to_tile(def_id):
    """
    Convert a definition_id into (char, color_pair) using FORWARD_MAP (from scenery_defs).
    Fallback to ('.', 17) if unknown, just for safety.
    """
    return FORWARD_MAP.get(def_id, ('.', 17))

def generate_procedural_map(width=100, height=100):
    """
    Orchestrates procedural map generation by calling sub-generation modules:
      1) spawn_rivers -> sets tiles to (' ', 4) => "RIVER_ID"
      2) spawn_large_semicircle_grass -> sets tiles to (' ', 5) => "GRASS_ID"
      3) BFS from grass to fill blank with either SEMICOLON_FLOOR or EMPTY_FLOOR
      4) Overwrite empty floor tiles with DEBUG_DOT if debug is enabled.

    Returns a dict: {
      "world_width":  width,
      "world_height": height,
      "scenery": [ {x, y, definition_id}, ... ]
    }
    """

    # 1) Initialize a 2D grid of None => blank
    grid = [[None for _ in range(width)] for _ in range(height)]

    # 2) Rivers => sets some tiles to (' ', 4)
    spawn_rivers(grid, width, height, min_rivers=1, max_rivers=2)

    # 3) Create large grass patches => (' ', 5)
    spawn_large_semicircle_grass(
        grid,
        width,
        height,
        bundles=20,
        patch_size=60
    )

    # BFS data
    distance_map = [[99999]*width for _ in range(height)]
    queue = deque()

    # Identify grass => BFS starting points
    for y in range(height):
        for x in range(width):
            if grid[y][x] is not None:
                ch, cpair = grid[y][x]
                def_id = tile_to_definition_id(ch, cpair)
                if def_id == GRASS_ID:
                    distance_map[y][x] = 0
                    queue.append((x, y))

    # Multi-source BFS outward from grass
    while queue:
        cx, cy = queue.popleft()
        current_dist = distance_map[cy][cx]
        for nx, ny in [(cx+1,cy), (cx-1,cy), (cx,cy+1), (cx,cy-1)]:
            if 0 <= nx < width and 0 <= ny < height:
                if distance_map[ny][nx] > current_dist + 1:
                    distance_map[ny][nx] = current_dist + 1
                    queue.append((nx, ny))

    # Fill blank tiles with SEMICOLON_FLOOR or EMPTY_FLOOR
    for y in range(height):
        for x in range(width):
            if grid[y][x] is None:
                dist = distance_map[y][x]
                if dist <= 5:
                    # near grass => semicolon
                    grid[y][x] = definition_id_to_tile(SEMICOLON_FLOOR_ID)
                else:
                    # far from grass => empty
                    grid[y][x] = definition_id_to_tile(EMPTY_FLOOR_ID)

    # If debug enabled => transform empty floors to debug dots
    if debug.DEBUG_CONFIG["enabled"]:
        for y in range(height):
            for x in range(width):
                ch, cpair = grid[y][x]
                def_id = tile_to_definition_id(ch, cpair)
                if def_id == EMPTY_FLOOR_ID:
                    # override with debug dot
                    grid[y][x] = definition_id_to_tile(DEBUG_DOT_ID)

    # Convert grid => scenery list
    scenery_list = []
    for y in range(height):
        for x in range(width):
            ch, cpair = grid[y][x]
            def_id = tile_to_definition_id(ch, cpair)
            scenery_list.append({
                "x": x,
                "y": y,
                "definition_id": def_id
            })

    return {
        "world_width": width,
        "world_height": height,
        "scenery": scenery_list
    }

==== File: gen_rivers.py ====
# gen_rivers.py
# Handles river spawning, from choosing edge points to thickening the water path.

import random

def spawn_rivers(grid, width, height, min_rivers=1, max_rivers=2):
    """
    Spawns a certain number of rivers (default 1-2).
    Each river starts on one edge, ends on the opposite edge,
    follows a path that mixes straight and diagonal movements,
    and alternates between 3-wide and 1-wide sections.
    """
    river_count = random.randint(min_rivers, max_rivers)
    for _ in range(river_count):
        start, end = pick_opposite_edges(width, height)
        path = trace_river_path_improved(start, end, width, height)
        fill_river_alternate_widths(grid, path, width, height)

def pick_opposite_edges(width, height):
    """
    Pick one edge of the map at random (top, bottom, left, right),
    then pick the opposite edge, and return (start, end) positions.
    For instance, if we pick "top," the opposite is "bottom."
    """
    # 0 = top->bottom, 1 = bottom->top,
    # 2 = left->right, 3 = right->left
    edge_type = random.randint(0, 3)

    if edge_type == 0:
        # top -> bottom
        sx = random.randint(0, width - 1)
        sy = 0
        ex = random.randint(0, width - 1)
        ey = height - 1
    elif edge_type == 1:
        # bottom -> top
        sx = random.randint(0, width - 1)
        sy = height - 1
        ex = random.randint(0, width - 1)
        ey = 0
    elif edge_type == 2:
        # left -> right
        sx = 0
        sy = random.randint(0, height - 1)
        ex = width - 1
        ey = random.randint(0, height - 1)
    else:
        # right -> left
        sx = width - 1
        sy = random.randint(0, height - 1)
        ex = 0
        ey = random.randint(0, height - 1)

    return (sx, sy), (ex, ey)

def trace_river_path_improved(start, end, width, height):
    """
    Generates a path from start->end with segments that may be:
      - Straight moves
      - Diagonal "over-over-down" or "down-over-over" patterns
    We'll keep going until we reach or are very close to end.
    """
    (sx, sy) = start
    (ex, ey) = end
    path = []
    curx, cury = sx, sy
    path.append((curx, cury))

    # A loose bound to prevent infinite loops
    max_steps = (abs(ex - sx) + abs(ey - sy)) * 3

    for _ in range(max_steps):
        if (curx, cury) == (ex, ey):
            break

        dx = ex - curx
        dy = ey - cury

        # If we're very close to the end, just jump there
        if abs(dx) <= 1 and abs(dy) <= 1:
            curx, cury = ex, ey
            path.append((curx, cury))
            break

        # Decide randomly whether to do a diagonal pattern or a straight move
        # (e.g. 30% chance to attempt a diagonal movement, otherwise straight).
        do_diagonal = (random.random() < 0.3 and dx != 0 and dy != 0)

        if do_diagonal:
            # "over-over-down" or "down-over-over"
            # Convert dx, dy to -1, 0, or 1 sign
            sxn = 1 if dx > 0 else -1
            syn = 1 if dy > 0 else -1

            # Randomly choose which pattern to do
            pattern_type = random.choice([0, 1])
            if pattern_type == 0:
                # over, over, down
                steps = [(sxn, 0), (sxn, 0), (0, syn)]
            else:
                # down, over, over
                steps = [(0, syn), (sxn, 0), (sxn, 0)]
        else:
            # Straight movement (horizontal or vertical).
            # Decide horizontal vs vertical by whichever is larger in magnitude.
            if abs(dx) > abs(dy):
                # Move horizontally up to 2 steps
                sxn = 1 if dx > 0 else -1
                steps = [(sxn, 0)] * random.randint(1, 2)
            else:
                # Move vertically up to 2 steps
                syn = 1 if dy > 0 else -1
                steps = [(0, syn)] * random.randint(1, 2)

        # Apply the steps in the chosen pattern
        for (mx, my) in steps:
            if (curx, cury) == (ex, ey):
                break
            curx += mx
            cury += my
            # Clamp
            curx = max(0, min(curx, width - 1))
            cury = max(0, min(cury, height - 1))
            path.append((curx, cury))
            if (curx, cury) == (ex, ey):
                break

    # Ensure the end is in the path
    if (curx, cury) != (ex, ey):
        path.append((ex, ey))

    return path

def fill_river_alternate_widths(grid, path, width, height):
    """
    For each index i in the path, if i is even => fill the tile + an extra
    'radius' around it (3-wide).
    If i is odd => fill just the center tile (1-wide).
    We use water = (' ', 4).
    """
    # Offsets for "3-wide": center + the 8 neighbors
    wide_offsets = [
        (0, 0), (1, 0), (-1, 0), (0, 1), (0, -1),
        (1, 1), (1, -1), (-1, 1), (-1, -1)
    ]

    for i, (x, y) in enumerate(path):
        if i % 2 == 0:
            # 3-wide
            for (ox, oy) in wide_offsets:
                nx = x + ox
                ny = y + oy
                if 0 <= nx < width and 0 <= ny < height:
                    grid[ny][nx] = (' ', 4)  # water
        else:
            # 1-wide
            grid[y][x] = (' ', 4)



==== File: gen_grass.py ====
# gen_grass.py
# Handles creation of grass patches, BFS for grass regions, and finding random grass spots.

import random
import math  # ADDED: for spawn_large_semicircle_grass (sqrt, sin, cos, etc.)

def spawn_grass_patches(grid, width, height, patch_count_min=3, patch_count_max=10):
    """
    Creates 3..10 separate grass patches, each ~10..20 tiles in size,
    typically placed near a water cell.
    """
    patch_count = random.randint(patch_count_min, patch_count_max)
    for _ in range(patch_count):
        create_grass_patch(grid, width, height, patch_size_min=10, patch_size_max=20)

def create_grass_patch(grid, width, height, patch_size_min=10, patch_size_max=20):
    """
    Creates one patch of grass (char=' ', color=5) near a random water tile,
    spreading BFS-like into ~10..20 cells.
    """
    water_positions = []
    for y in range(height):
        for x in range(width):
            if grid[y][x] is not None and grid[y][x][1] == 4:
                water_positions.append((x, y))
    if not water_positions:
        return  # no water found => skip

    # pick one water cell
    wx, wy = random.choice(water_positions)

    # find a neighbor cell that is None to start grass
    directions = [(0,1),(0,-1),(1,0),(-1,0)]
    random.shuffle(directions)
    start_cell = None
    for (dx, dy) in directions:
        nx, ny = wx + dx, wy + dy
        if 0 <= nx < width and 0 <= ny < height:
            if grid[ny][nx] is None:
                start_cell = (nx, ny)
                break
    if not start_cell:
        return

    patch_size = random.randint(patch_size_min, patch_size_max)
    queue = [start_cell]
    visited = set([start_cell])
    filled_count = 0

    while queue and filled_count < patch_size:
        cx, cy = queue.pop(0)
        if grid[cy][cx] is None:
            grid[cy][cx] = (' ', 5)  # grass
            filled_count += 1

        # expand neighbors
        random.shuffle(directions)
        for (dx, dy) in directions:
            nx, ny = cx + dx, cy + dy
            if 0 <= nx < width and 0 <= ny < height:
                if (nx, ny) not in visited and grid[ny][nx] is None:
                    visited.add((nx, ny))
                    queue.append((nx, ny))

def spawn_large_semicircle_grass(grid, width, height,
                                 bundles=5, patch_size=40):
    """
    Creates 'bundles' of large grass areas near the river.
    Each bundle picks a random river tile and forms a rough semi-circle
    of 'patch_size' tiles outward from that point.

    - We pick a center angle, then scatter grass within +/-90 degrees from it,
      up to some random radius, to emulate a semi-circular region.
    - 'bundles' => how many lumps
    - 'patch_size' => how many tiles in each lump
    - The tile for grass is (' ', 5).

    Updated for larger coverage:
      - radius is bigger => +8 instead of +4
    """
    # Gather all river (water) positions
    water_positions = []
    for y in range(height):
        for x in range(width):
            if grid[y][x] is not None:
                ch, cpair = grid[y][x]
                # water => (' ', 4)
                if ch == ' ' and cpair == 4:
                    water_positions.append((x, y))

    if not water_positions:
        return  # No rivers => skip

    for _ in range(bundles):
        # Pick a random water tile as "center"
        center_x, center_y = random.choice(water_positions)

        # Random "orientation" for the semicircle
        center_angle = random.uniform(0, 360)

        # We'll define a rough radius for the lumps.
        radius = int(math.sqrt(patch_size)) + 8

        placed = 0
        attempts = 0
        max_attempts = patch_size * 10

        while placed < patch_size and attempts < max_attempts:
            attempts += 1

            # Random angle within +/- 90 deg from center_angle
            angle_offset = random.uniform(-90, 90)
            angle = math.radians(center_angle + angle_offset)

            # Random distance from [0..radius]
            r = random.uniform(0, radius)

            # Compute potential coords
            dx = int(round(r * math.cos(angle)))
            dy = int(round(r * math.sin(angle)))
            x = center_x + dx
            y = center_y + dy

            if 0 <= x < width and 0 <= y < height:
                # Place grass if None
                if grid[y][x] is None:
                    grid[y][x] = (' ', 5)  # grass
                    placed += 1

def find_grass_regions(grid, width, height):
    """
    Uses BFS to identify distinct 'regions' of grass (char=' ', color=5).
    Returns a list of lists => each sublist is the set of coordinates for that region.
    """
    visited = [[False]*width for _ in range(height)]
    directions = [(0,1),(0,-1),(1,0),(-1,0)]
    regions = []

    for y in range(height):
        for x in range(width):
            if grid[y][x] is None:
                continue

            (ch, cpair) = grid[y][x]
            if ch == ' ' and cpair == 5 and not visited[y][x]:
                region_coords = []
                queue = [(x,y)]
                visited[y][x] = True

                while queue:
                    cx, cy = queue.pop(0)
                    region_coords.append((cx, cy))

                    for (dx, dy) in directions:
                        nx, ny = cx+dx, cy+dy
                        if 0 <= nx < width and 0 <= ny < height:
                            if not visited[ny][nx] and grid[ny][nx] is not None:
                                nch, ncp = grid[ny][nx]
                                if nch == ' ' and ncp == 5:
                                    visited[ny][nx] = True
                                    queue.append((nx, ny))
                regions.append(region_coords)

    return regions

def find_random_grass_spot(grid, width, height):
    """
    Return (x, y) of a random tile that is grass (char=' ', color=5).
    If none found, returns (0, 0).
    """
    grass_positions = []
    for y in range(height):
        for x in range(width):
            if grid[y][x] is not None:
                (ch, cp) = grid[y][x]
                if ch == ' ' and cp == 5:
                    grass_positions.append((x, y))
    if not grass_positions:
        return (0, 0)
    return random.choice(grass_positions)

==== File: gen_rocks.py ====
# gen_rocks.py
# Spawns rocks on existing grass tiles.

import random
from .gen_grass import find_random_grass_spot

def spawn_rocks(grid, width, height, rock_min=10, rock_max=20):
    """
    Randomly place 10..20 rocks (char='o', color=3) on grass.
    Each "group" is size 1..3, for a clustered feel.
    """
    count = random.randint(rock_min, rock_max)
    for _ in range(count):
        gx, gy = find_random_grass_spot(grid, width, height)
        # cluster size 1..3
        cluster_size = random.randint(1, 3)
        for _c in range(cluster_size):
            rx = gx + random.randint(-1,1)
            ry = gy + random.randint(-1,1)
            if 0 <= rx < width and 0 <= ry < height:
                if grid[ry][rx] is not None:
                    ch, cp = grid[ry][rx]
                    if ch == ' ' and cp == 5:  # grass
                        grid[ry][rx] = ('o', 3)


==== File: gen_trees.py ====
# gen_trees.py
# Spawns trees on non-grass tiles, at least 2 tiles from grass and 1 tile away from each other.

import random
from .utils import manhattan_dist

def spawn_trees_non_grass(grid, width, height, tree_min=5, tree_max=10):
    """
    Place trees (trunk '|', color=2, plus top '§', color=1) on tiles that are:
      - not grass
      - at least 2 tiles away from any grass
      - at least 1 tile away from other trees
    """
    grass_positions = []
    # Collect all grass coords
    for y in range(height):
        for x in range(width):
            if grid[y][x] is not None:
                ch, cpair = grid[y][x]
                if ch == ' ' and cpair == 5:
                    grass_positions.append((x, y))

    # Build a list of valid non-grass positions (>=2 away from grass)
    valid_positions = []
    for y in range(height):
        for x in range(width):
            if grid[y][x] is not None:
                (ch, cpair) = grid[y][x]
                # only consider if NOT grass
                if not (ch == ' ' and cpair == 5):
                    dist_ok = True
                    for (gx, gy) in grass_positions:
                        if manhattan_dist(x, y, gx, gy) < 2:
                            dist_ok = False
                            break
                    if dist_ok:
                        valid_positions.append((x, y))

    placed_trees = []
    count = random.randint(tree_min, tree_max)

    for _ in range(count):
        if not valid_positions:
            break
        tx, ty = random.choice(valid_positions)

        # We need space above for the top
        if ty > 0:
            # top cell is (tx, ty-1)
            if (tx, ty-1) in valid_positions:
                # also check adjacency to existing trunks
                too_close = any(manhattan_dist(tx, ty, px, py) <= 1 for (px, py) in placed_trees)
                if not too_close:
                    # place the tree
                    grid[ty][tx] = ('|', 2)   # trunk
                    grid[ty-1][tx] = ('§', 1) # top
                    placed_trees.append((tx, ty))

                    # remove trunk + top from valid_positions
                    valid_positions.remove((tx, ty))
                    valid_positions.remove((tx, ty-1))

                    # also remove anything else too close
                    purge_positions_close(valid_positions, tx, ty, 1)
                    purge_positions_close(valid_positions, tx, ty-1, 1)

def purge_positions_close(pos_list, cx, cy, radius=1):
    """
    Remove from pos_list any positions that are within 'radius' manhattan distance to (cx, cy).
    """
    removals = []
    for (vx, vy) in pos_list:
        if manhattan_dist(vx, vy, cx, cy) <= radius:
            removals.append((vx, vy))
    for r in removals:
        pos_list.remove(r)


==== File: gen_bridges.py ====
# gen_bridges.py
# Connects disconnected grass regions via bridging.

import random

def connect_grass_regions_with_bridges(grid, grass_regions):
    """
    For each pair of distinct grass regions, place bridging (#) across water so that
    everything eventually becomes one big connected set.
    Bridges have:
      - end-posts (char='l', color=2) at the first/last bridging cell
      - bridging (char='#', color=2) in between
    """
    if not grass_regions:
        return

    master = grass_regions[0]
    for i in range(1, len(grass_regions)):
        region = grass_regions[i]
        a = random.choice(master)
        b = random.choice(region)
        build_bridge_with_posts(grid, a, b)
        # add region to master
        master.extend(region)

def build_bridge_with_posts(grid, start, end):
    """
    Draw a straight line from start->end. For each water cell in the line, place bridging:
      - 'l' for the first/last bridging cell (end-post)
      - '#' for bridging in between
    """
    (sx, sy) = start
    (ex, ey) = end
    dx = ex - sx
    dy = ey - sy
    steps = max(abs(dx), abs(dy))
    if steps == 0:
        return

    for i in range(steps + 1):
        t = i / steps
        cx = int(round(sx + t * dx))
        cy = int(round(sy + t * dy))

        if grid[cy][cx] is not None:
            ch, cpair = grid[cy][cx]
            # If currently water, we place bridging
            if ch == ' ' and cpair == 4:
                # End-post vs. middle bridging
                if i == 0 or i == steps:
                    grid[cy][cx] = ('l', 2)
                else:
                    grid[cy][cx] = ('#', 2)


==== File: utils.py ====
# FileName: utils.py
# version: 1.0
# Summary: Shared helper functions for random distribution, sampling, or coordinate checks used by generation scripts.
# Tags: map, generation, utils

def manhattan_dist(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)


==== File: __init__.py ====
# FileName: __init__.py
# version: 1.0
# Summary: Marks this directory as a Python package for procedural map generation, enabling modular imports.
# Tags: package, generation, init

